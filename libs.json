[
    {
        "ID": "cQqLr9zqhD",
        "Name": "Roact",
        "Author": "Roblox",
        "Description": " A declarative Lua UI library similar to Facebook's React",
        "Downloads": 0,
        "Serialized": [
            {
                "Name": "Roact",
                "ClassName": "ModuleScript",
                "Source": "--~strict\n--[[\n\tPackages up the internals of Roact and exposes a public API for it.\n]]\n\nlocal GlobalConfig = require(script.GlobalConfig)\nlocal createReconciler = require(script.createReconciler)\nlocal createReconcilerCompat = require(script.createReconcilerCompat)\nlocal RobloxRenderer = require(script.RobloxRenderer)\nlocal strict = require(script.strict)\nlocal Binding = require(script.Binding)\n\nlocal robloxReconciler = createReconciler(RobloxRenderer)\nlocal reconcilerCompat = createReconcilerCompat(robloxReconciler)\n\nlocal Roact = strict({\n\tComponent = require(script.Component),\n\tcreateElement = require(script.createElement),\n\tcreateFragment = require(script.createFragment),\n\toneChild = require(script.oneChild),\n\tPureComponent = require(script.PureComponent),\n\tNone = require(script.None),\n\tPortal = require(script.Portal),\n\tcreateRef = require(script.createRef),\n\tforwardRef = require(script.forwardRef),\n\tcreateBinding = Binding.create,\n\tjoinBindings = Binding.join,\n\tcreateContext = require(script.createContext),\n\n\tChange = require(script.PropMarkers.Change),\n\tChildren = require(script.PropMarkers.Children),\n\tEvent = require(script.PropMarkers.Event),\n\tRef = require(script.PropMarkers.Ref),\n\n\tmount = robloxReconciler.mountVirtualTree,\n\tunmount = robloxReconciler.unmountVirtualTree,\n\tupdate = robloxReconciler.updateVirtualTree,\n\n\treify = reconcilerCompat.reify,\n\tteardown = reconcilerCompat.teardown,\n\treconcile = reconcilerCompat.reconcile,\n\n\tsetGlobalConfig = GlobalConfig.set,\n\n\t-- APIs that may change in the future without warning\n\tUNSTABLE = {},\n})\n\nreturn Roact\n",
                "Children": [
                    {
                        "Name": "strict.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal strict = require(script.Parent.strict)\n\n\tit(\"should error when getting a nonexistent key\", function()\n\t\tlocal t = strict({\n\t\t\ta = 1,\n\t\t\tb = 2,\n\t\t})\n\n\t\texpect(function()\n\t\t\treturn t.c\n\t\tend).to.throw()\n\tend)\n\n\tit(\"should error when setting a nonexistent key\", function()\n\t\tlocal t = strict({\n\t\t\ta = 1,\n\t\t\tb = 2,\n\t\t})\n\n\t\texpect(function()\n\t\t\tt.c = 3\n\t\tend).to.throw()\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "strict",
                        "ClassName": "ModuleScript",
                        "Source": "--!nonstrict\nlocal function strict(t, name)\n\tname = name or tostring(t)\n\n\treturn setmetatable(t, {\n\t\t__index = function(_self, key)\n\t\t\tlocal message = (\"%q (%s) is not a valid member of %s\"):format(tostring(key), typeof(key), name)\n\n\t\t\terror(message, 2)\n\t\tend,\n\n\t\t__newindex = function(_self, key, _value)\n\t\t\tlocal message = (\"%q (%s) is not a valid member of %s\"):format(tostring(key), typeof(key), name)\n\n\t\t\terror(message, 2)\n\t\tend,\n\t})\nend\n\nreturn strict\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "oneChild.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal createElement = require(script.Parent.createElement)\n\n\tlocal oneChild = require(script.Parent.oneChild)\n\n\tit(\"should get zero children from a table\", function()\n\t\tlocal children = {}\n\n\t\texpect(oneChild(children)).to.equal(nil)\n\tend)\n\n\tit(\"should get exactly one child\", function()\n\t\tlocal child = createElement(\"Frame\")\n\t\tlocal children = {\n\t\t\tfoo = child,\n\t\t}\n\n\t\texpect(oneChild(children)).to.equal(child)\n\tend)\n\n\tit(\"should error with more than one child\", function()\n\t\tlocal children = {\n\t\t\ta = createElement(\"Frame\"),\n\t\t\tb = createElement(\"Frame\"),\n\t\t}\n\n\t\texpect(function()\n\t\t\toneChild(children)\n\t\tend).to.throw()\n\tend)\n\n\tit(\"should handle being passed nil\", function()\n\t\texpect(oneChild(nil)).to.equal(nil)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "oneChild",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tRetrieves at most one child from the children passed to a component.\n\n\tIf passed nil or an empty table, will return nil.\n\n\tThrows an error if passed more than one child.\n]]\nlocal function oneChild(children)\n\tif not children then\n\t\treturn nil\n\tend\n\n\tlocal key, child = next(children)\n\n\tif not child then\n\t\treturn nil\n\tend\n\n\tlocal after = next(children, key)\n\n\tif after then\n\t\terror(\"Expected at most child, had more than one child.\", 2)\n\tend\n\n\treturn child\nend\n\nreturn oneChild\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "invalidSetStateMessages",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tThese messages are used by Component to help users diagnose when they're\n\tcalling setState in inappropriate places.\n\n\tThe indentation may seem odd, but it's necessary to avoid introducing extra\n\twhitespace into the error messages themselves.\n]]\nlocal ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)\n\nlocal invalidSetStateMessages = {}\n\ninvalidSetStateMessages[ComponentLifecyclePhase.WillUpdate] = [[\nsetState cannot be used in the willUpdate lifecycle method.\nConsider using the didUpdate method instead, or using getDerivedStateFromProps.\n\nCheck the definition of willUpdate in the component %q.]]\n\ninvalidSetStateMessages[ComponentLifecyclePhase.WillUnmount] = [[\nsetState cannot be used in the willUnmount lifecycle method.\nA component that is being unmounted cannot be updated!\n\nCheck the definition of willUnmount in the component %q.]]\n\ninvalidSetStateMessages[ComponentLifecyclePhase.ShouldUpdate] = [[\nsetState cannot be used in the shouldUpdate lifecycle method.\nshouldUpdate must be a pure function that only depends on props and state.\n\nCheck the definition of shouldUpdate in the component %q.]]\n\ninvalidSetStateMessages[ComponentLifecyclePhase.Render] = [[\nsetState cannot be used in the render method.\nrender must be a pure function that only depends on props and state.\n\nCheck the definition of render in the component %q.]]\n\ninvalidSetStateMessages[\"default\"] = [[\nsetState can not be used in the current situation, because Roact doesn't know\nwhich part of the lifecycle this component is in.\n\nThis is a bug in Roact.\nIt was triggered by the component %q.\n]]\n\nreturn invalidSetStateMessages\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "internalAssert",
                        "ClassName": "ModuleScript",
                        "Source": "local function internalAssert(condition, message)\n\tif not condition then\n\t\terror(message .. \" (This is probably a bug in Roact!)\", 3)\n\tend\nend\n\nreturn internalAssert\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "init.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal Roact = require(script.Parent)\n\n\tit(\"should load with all public APIs\", function()\n\t\tlocal publicApi = {\n\t\t\tcreateElement = \"function\",\n\t\t\tcreateFragment = \"function\",\n\t\t\tcreateRef = \"function\",\n\t\t\tforwardRef = \"function\",\n\t\t\tcreateBinding = \"function\",\n\t\t\tjoinBindings = \"function\",\n\t\t\tmount = \"function\",\n\t\t\tunmount = \"function\",\n\t\t\tupdate = \"function\",\n\t\t\toneChild = \"function\",\n\t\t\tsetGlobalConfig = \"function\",\n\t\t\tcreateContext = \"function\",\n\n\t\t\t-- These functions are deprecated and throw warnings!\n\t\t\treify = \"function\",\n\t\t\tteardown = \"function\",\n\t\t\treconcile = \"function\",\n\n\t\t\tComponent = true,\n\t\t\tPureComponent = true,\n\t\t\tPortal = true,\n\t\t\tChildren = true,\n\t\t\tEvent = true,\n\t\t\tChange = true,\n\t\t\tRef = true,\n\t\t\tNone = true,\n\t\t\tUNSTABLE = true,\n\t\t}\n\n\t\texpect(Roact).to.be.ok()\n\n\t\tfor key, valueType in pairs(publicApi) do\n\t\t\tlocal success\n\t\t\tif typeof(valueType) == \"string\" then\n\t\t\t\tsuccess = typeof(Roact[key]) == valueType\n\t\t\telse\n\t\t\t\tsuccess = Roact[key] ~= nil\n\t\t\tend\n\n\t\t\tif not success then\n\t\t\t\tlocal existence = typeof(valueType) == \"boolean\" and \"present\" or \"of type \" .. valueType\n\t\t\t\tlocal message = (\"Expected public API member %q to be %s, but instead it was of type %s\"):format(\n\t\t\t\t\ttostring(key),\n\t\t\t\t\texistence,\n\t\t\t\t\ttypeof(Roact[key])\n\t\t\t\t)\n\n\t\t\t\terror(message)\n\t\t\tend\n\t\tend\n\n\t\tfor key in pairs(Roact) do\n\t\t\tif publicApi[key] == nil then\n\t\t\t\tlocal message = (\"Found unknown public API key %q!\"):format(tostring(key))\n\n\t\t\t\terror(message)\n\t\t\tend\n\t\tend\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "getDefaultInstanceProperty.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)\n\n\tit(\"should get default name string values\", function()\n\t\tlocal _, defaultName = getDefaultInstanceProperty(\"StringValue\", \"Name\")\n\n\t\texpect(defaultName).to.equal(\"Value\")\n\tend)\n\n\tit(\"should get default empty string values\", function()\n\t\tlocal _, defaultValue = getDefaultInstanceProperty(\"StringValue\", \"Value\")\n\n\t\texpect(defaultValue).to.equal(\"\")\n\tend)\n\n\tit(\"should get default number values\", function()\n\t\tlocal _, defaultValue = getDefaultInstanceProperty(\"IntValue\", \"Value\")\n\n\t\texpect(defaultValue).to.equal(0)\n\tend)\n\n\tit(\"should get nil default values\", function()\n\t\tlocal _, defaultValue = getDefaultInstanceProperty(\"ObjectValue\", \"Value\")\n\n\t\texpect(defaultValue).to.equal(nil)\n\tend)\n\n\tit(\"should get bool default values\", function()\n\t\tlocal _, defaultValue = getDefaultInstanceProperty(\"BoolValue\", \"Value\")\n\n\t\texpect(defaultValue).to.equal(false)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "getDefaultInstanceProperty",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tAttempts to get the default value of a given property on a Roblox instance.\n\n\tThis is used by the reconciler in cases where a prop was previously set on a\n\tprimitive component, but is no longer present in a component's new props.\n\n\tEventually, Roblox might provide a nicer API to query the default property\n\tof an object without constructing an instance of it.\n]]\n\nlocal Symbol = require(script.Parent.Symbol)\n\nlocal Nil = Symbol.named(\"Nil\")\nlocal _cachedPropertyValues = {}\n\nlocal function getDefaultInstanceProperty(className, propertyName)\n\tlocal classCache = _cachedPropertyValues[className]\n\n\tif classCache then\n\t\tlocal propValue = classCache[propertyName]\n\n\t\t-- We have to use a marker here, because Lua doesn't distinguish\n\t\t-- between 'nil' and 'not in a table'\n\t\tif propValue == Nil then\n\t\t\treturn true, nil\n\t\tend\n\n\t\tif propValue ~= nil then\n\t\t\treturn true, propValue\n\t\tend\n\telse\n\t\tclassCache = {}\n\t\t_cachedPropertyValues[className] = classCache\n\tend\n\n\tlocal created = Instance.new(className)\n\tlocal ok, defaultValue = pcall(function()\n\t\treturn created[propertyName]\n\tend)\n\n\tcreated:Destroy()\n\n\tif ok then\n\t\tif defaultValue == nil then\n\t\t\tclassCache[propertyName] = Nil\n\t\telse\n\t\t\tclassCache[propertyName] = defaultValue\n\t\tend\n\tend\n\n\treturn ok, defaultValue\nend\n\nreturn getDefaultInstanceProperty\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "forwardRef.spec",
                        "ClassName": "ModuleScript",
                        "Source": "-- Tests loosely adapted from those found at:\n-- * https://github.com/facebook/react/blob/v17.0.1/packages/react/src/__tests__/forwardRef-test.js\n-- * https://github.com/facebook/react/blob/v17.0.1/packages/react/src/__tests__/forwardRef-test.internal.js\nreturn function()\n\tlocal assign = require(script.Parent.assign)\n\tlocal createElement = require(script.Parent.createElement)\n\tlocal createRef = require(script.Parent.createRef)\n\tlocal forwardRef = require(script.Parent.forwardRef)\n\tlocal createReconciler = require(script.Parent.createReconciler)\n\tlocal Component = require(script.Parent.Component)\n\tlocal GlobalConfig = require(script.Parent.GlobalConfig)\n\tlocal Ref = require(script.Parent.PropMarkers.Ref)\n\n\tlocal RobloxRenderer = require(script.Parent.RobloxRenderer)\n\n\tlocal reconciler = createReconciler(RobloxRenderer)\n\n\tit(\"should update refs when switching between children\", function()\n\t\tlocal function FunctionComponent(props)\n\t\t\tlocal forwardedRef = props.forwardedRef\n\t\t\tlocal setRefOnDiv = props.setRefOnDiv\n\t\t\t-- deviation: clearer to express this way, since we don't have real\n\t\t\t-- ternaries\n\t\t\tlocal firstRef, secondRef\n\t\t\tif setRefOnDiv then\n\t\t\t\tfirstRef = forwardedRef\n\t\t\telse\n\t\t\t\tsecondRef = forwardedRef\n\t\t\tend\n\t\t\treturn createElement(\"Frame\", nil, {\n\t\t\t\tFirst = createElement(\"Frame\", {\n\t\t\t\t\t[Ref] = firstRef,\n\t\t\t\t}, {\n\t\t\t\t\tChild = createElement(\"TextLabel\", {\n\t\t\t\t\t\tText = \"First\",\n\t\t\t\t\t}),\n\t\t\t\t}),\n\t\t\t\tSecond = createElement(\"ScrollingFrame\", {\n\t\t\t\t\t[Ref] = secondRef,\n\t\t\t\t}, {\n\t\t\t\t\tChild = createElement(\"TextLabel\", {\n\t\t\t\t\t\tText = \"Second\",\n\t\t\t\t\t}),\n\t\t\t\t}),\n\t\t\t})\n\t\tend\n\n\t\tlocal RefForwardingComponent = forwardRef(function(props, ref)\n\t\t\treturn createElement(FunctionComponent, assign({}, props, { forwardedRef = ref }))\n\t\tend)\n\n\t\tlocal ref = createRef()\n\n\t\tlocal element = createElement(RefForwardingComponent, {\n\t\t\t[Ref] = ref,\n\t\t\tsetRefOnDiv = true,\n\t\t})\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"switch refs\")\n\t\texpect(ref.current.ClassName).to.equal(\"Frame\")\n\t\treconciler.unmountVirtualTree(tree)\n\n\t\telement = createElement(RefForwardingComponent, {\n\t\t\t[Ref] = ref,\n\t\t\tsetRefOnDiv = false,\n\t\t})\n\t\ttree = reconciler.mountVirtualTree(element, nil, \"switch refs\")\n\t\texpect(ref.current.ClassName).to.equal(\"ScrollingFrame\")\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should support rendering nil\", function()\n\t\tlocal RefForwardingComponent = forwardRef(function(_props, _ref)\n\t\t\treturn nil\n\t\tend)\n\n\t\tlocal ref = createRef()\n\n\t\tlocal element = createElement(RefForwardingComponent, { [Ref] = ref })\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"nil ref\")\n\t\texpect(ref.current).to.equal(nil)\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should support rendering nil for multiple children\", function()\n\t\tlocal RefForwardingComponent = forwardRef(function(_props, _ref)\n\t\t\treturn nil\n\t\tend)\n\n\t\tlocal ref = createRef()\n\n\t\tlocal element = createElement(\"Frame\", nil, {\n\t\t\tNoRef1 = createElement(\"Frame\"),\n\t\t\tWithRef = createElement(RefForwardingComponent, { [Ref] = ref }),\n\t\t\tNoRef2 = createElement(\"Frame\"),\n\t\t})\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"multiple children nil ref\")\n\t\texpect(ref.current).to.equal(nil)\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\t-- We could support this by having forwardRef return a stateful component,\n\t-- but it's likely not necessary\n\titSKIP(\"should support defaultProps\", function()\n\t\tlocal function FunctionComponent(props)\n\t\t\tlocal forwardedRef = props.forwardedRef\n\t\t\tlocal optional = props.optional\n\t\t\tlocal required = props.required\n\t\t\treturn createElement(\"Frame\", {\n\t\t\t\t[Ref] = forwardedRef,\n\t\t\t}, {\n\t\t\t\tOptionalChild = optional,\n\t\t\t\tRequiredChild = required,\n\t\t\t})\n\t\tend\n\n\t\tlocal RefForwardingComponent = forwardRef(function(props, ref)\n\t\t\treturn createElement(\n\t\t\t\tFunctionComponent,\n\t\t\t\tassign({}, props, {\n\t\t\t\t\tforwardedRef = ref,\n\t\t\t\t})\n\t\t\t)\n\t\tend)\n\t\tRefForwardingComponent.defaultProps = {\n\t\t\toptional = createElement(\"TextLabel\"),\n\t\t}\n\n\t\tlocal ref = createRef()\n\n\t\tlocal element = createElement(RefForwardingComponent, {\n\t\t\t[Ref] = ref,\n\t\t\toptional = createElement(\"Frame\"),\n\t\t\trequired = createElement(\"ScrollingFrame\"),\n\t\t})\n\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"with optional\")\n\n\t\texpect(ref.current:FindFirstChild(\"OptionalChild\").ClassName).to.equal(\"Frame\")\n\t\texpect(ref.current:FindFirstChild(\"RequiredChild\").ClassName).to.equal(\"ScrollingFrame\")\n\n\t\treconciler.unmountVirtualTree(tree)\n\t\telement = createElement(RefForwardingComponent, {\n\t\t\t[Ref] = ref,\n\t\t\trequired = createElement(\"ScrollingFrame\"),\n\t\t})\n\t\ttree = reconciler.mountVirtualTree(element, nil, \"with default\")\n\n\t\texpect(ref.current:FindFirstChild(\"OptionalChild\").ClassName).to.equal(\"TextLabel\")\n\t\texpect(ref.current:FindFirstChild(\"RequiredChild\").ClassName).to.equal(\"ScrollingFrame\")\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should error if not provided a callback when type checking is enabled\", function()\n\t\tGlobalConfig.scoped({\n\t\t\ttypeChecks = true,\n\t\t}, function()\n\t\t\texpect(function()\n\t\t\t\tforwardRef(nil)\n\t\t\tend).to.throw()\n\t\tend)\n\n\t\tGlobalConfig.scoped({\n\t\t\ttypeChecks = true,\n\t\t}, function()\n\t\t\texpect(function()\n\t\t\t\tforwardRef(\"foo\")\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tit(\"should work without a ref to be forwarded\", function()\n\t\tlocal function Child()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal function Wrapper(props)\n\t\t\treturn createElement(Child, assign({}, props, { [Ref] = props.forwardedRef }))\n\t\tend\n\n\t\tlocal RefForwardingComponent = forwardRef(function(props, ref)\n\t\t\treturn createElement(Wrapper, assign({}, props, { forwardedRef = ref }))\n\t\tend)\n\n\t\tlocal element = createElement(RefForwardingComponent, { value = 123 })\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"nil ref\")\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should forward a ref for a single child\", function()\n\t\tlocal value\n\t\tlocal function Child(props)\n\t\t\tvalue = props.value\n\t\t\treturn createElement(\"Frame\", {\n\t\t\t\t[Ref] = props[Ref],\n\t\t\t})\n\t\tend\n\n\t\tlocal function Wrapper(props)\n\t\t\treturn createElement(Child, assign({}, props, { [Ref] = props.forwardedRef }))\n\t\tend\n\n\t\tlocal RefForwardingComponent = forwardRef(function(props, ref)\n\t\t\treturn createElement(Wrapper, assign({}, props, { forwardedRef = ref }))\n\t\tend)\n\n\t\tlocal ref = createRef()\n\n\t\tlocal element = createElement(RefForwardingComponent, { [Ref] = ref, value = 123 })\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"single child ref\")\n\t\texpect(value).to.equal(123)\n\t\texpect(ref.current.ClassName).to.equal(\"Frame\")\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should forward a ref for multiple children\", function()\n\t\tlocal function Child(props)\n\t\t\treturn createElement(\"Frame\", {\n\t\t\t\t[Ref] = props[Ref],\n\t\t\t})\n\t\tend\n\n\t\tlocal function Wrapper(props)\n\t\t\treturn createElement(Child, assign({}, props, { [Ref] = props.forwardedRef }))\n\t\tend\n\n\t\tlocal RefForwardingComponent = forwardRef(function(props, ref)\n\t\t\treturn createElement(Wrapper, assign({}, props, { forwardedRef = ref }))\n\t\tend)\n\n\t\tlocal ref = createRef()\n\n\t\tlocal element = createElement(\"Frame\", nil, {\n\t\t\tNoRef1 = createElement(\"Frame\"),\n\t\t\tWithRef = createElement(RefForwardingComponent, { [Ref] = ref }),\n\t\t\tNoRef2 = createElement(\"Frame\"),\n\t\t})\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"multi child ref\")\n\t\texpect(ref.current.ClassName).to.equal(\"Frame\")\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should maintain child instance and ref through updates\", function()\n\t\tlocal value\n\t\tlocal function Child(props)\n\t\t\tvalue = props.value\n\t\t\treturn createElement(\"Frame\", {\n\t\t\t\t[Ref] = props[Ref],\n\t\t\t})\n\t\tend\n\n\t\tlocal function Wrapper(props)\n\t\t\treturn createElement(Child, assign({}, props, { [Ref] = props.forwardedRef }))\n\t\tend\n\n\t\tlocal RefForwardingComponent = forwardRef(function(props, ref)\n\t\t\treturn createElement(Wrapper, assign({}, props, { forwardedRef = ref }))\n\t\tend)\n\n\t\tlocal setRefCount = 0\n\t\tlocal refValue\n\n\t\tlocal setRef = function(r)\n\t\t\tsetRefCount = setRefCount + 1\n\t\t\trefValue = r\n\t\tend\n\n\t\tlocal element = createElement(RefForwardingComponent, { [Ref] = setRef, value = 123 })\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"maintains instance\")\n\n\t\texpect(value).to.equal(123)\n\t\texpect(refValue.ClassName).to.equal(\"Frame\")\n\t\texpect(setRefCount).to.equal(1)\n\n\t\telement = createElement(RefForwardingComponent, { [Ref] = setRef, value = 456 })\n\t\ttree = reconciler.updateVirtualTree(tree, element)\n\n\t\texpect(value).to.equal(456)\n\t\texpect(setRefCount).to.equal(1)\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should not re-run the render callback on a deep setState\", function()\n\t\tlocal inst\n\t\tlocal renders = {}\n\n\t\tlocal Inner = Component:extend(\"Inner\")\n\t\tfunction Inner:render()\n\t\t\ttable.insert(renders, \"Inner\")\n\t\t\tinst = self\n\t\t\treturn createElement(\"Frame\", { [Ref] = self.props.forwardedRef })\n\t\tend\n\n\t\tlocal function Middle(props)\n\t\t\ttable.insert(renders, \"Middle\")\n\t\t\treturn createElement(Inner, props)\n\t\tend\n\n\t\tlocal Forward = forwardRef(function(props, ref)\n\t\t\ttable.insert(renders, \"Forward\")\n\t\t\treturn createElement(Middle, assign({}, props, { forwardedRef = ref }))\n\t\tend)\n\n\t\tlocal function App()\n\t\t\ttable.insert(renders, \"App\")\n\t\t\treturn createElement(Forward)\n\t\tend\n\n\t\tlocal tree = reconciler.mountVirtualTree(createElement(App), nil, \"deep setState\")\n\t\texpect(#renders).to.equal(4)\n\t\texpect(renders[1]).to.equal(\"App\")\n\t\texpect(renders[2]).to.equal(\"Forward\")\n\t\texpect(renders[3]).to.equal(\"Middle\")\n\t\texpect(renders[4]).to.equal(\"Inner\")\n\n\t\trenders = {}\n\t\tinst:setState({})\n\t\texpect(#renders).to.equal(1)\n\t\texpect(renders[1]).to.equal(\"Inner\")\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should not include the ref in the forwarded props\", function()\n\t\tlocal capturedProps\n\t\tlocal function CaptureProps(props)\n\t\t\tcapturedProps = props\n\t\t\treturn createElement(\"Frame\", { [Ref] = props.forwardedRef })\n\t\tend\n\n\t\tlocal RefForwardingComponent = forwardRef(function(props, ref)\n\t\t\treturn createElement(CaptureProps, assign({}, props, { forwardedRef = ref }))\n\t\tend)\n\n\t\tlocal ref = createRef()\n\t\tlocal element = createElement(RefForwardingComponent, {\n\t\t\t[Ref] = ref,\n\t\t})\n\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"no ref in props\")\n\t\texpect(capturedProps).to.be.ok()\n\t\texpect(capturedProps.forwardedRef).to.equal(ref)\n\t\texpect(capturedProps[Ref]).to.equal(nil)\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "forwardRef",
                        "ClassName": "ModuleScript",
                        "Source": "local assign = require(script.Parent.assign)\nlocal None = require(script.Parent.None)\nlocal Ref = require(script.Parent.PropMarkers.Ref)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal excludeRef = {\n\t[Ref] = None,\n}\n\n--[[\n\tAllows forwarding of refs to underlying host components. Accepts a render\n\tcallback which accepts props and a ref, and returns an element.\n]]\nlocal function forwardRef(render)\n\tif config.typeChecks then\n\t\tassert(typeof(render) == \"function\", \"Expected arg #1 to be a function\")\n\tend\n\n\treturn function(props)\n\t\tlocal ref = props[Ref]\n\t\tlocal propsWithoutRef = assign({}, props, excludeRef)\n\n\t\treturn render(propsWithoutRef, ref)\n\tend\nend\n\nreturn forwardRef\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createSpy.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal createSpy = require(script.Parent.createSpy)\n\n\tdescribe(\"createSpy\", function()\n\t\tit(\"should create spies\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\n\t\t\texpect(spy).to.be.ok()\n\t\tend)\n\n\t\tit(\"should throw if spies are indexed by an invalid key\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\n\t\t\texpect(function()\n\t\t\t\treturn spy.test\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tdescribe(\"value\", function()\n\t\tit(\"should increment callCount when called\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\t\t\tspy.value()\n\n\t\t\texpect(spy.callCount).to.equal(1)\n\t\tend)\n\n\t\tit(\"should store all values passed\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\t\t\tspy.value(1, true, \"3\")\n\n\t\t\texpect(spy.valuesLength).to.equal(3)\n\t\t\texpect(spy.values[1]).to.equal(1)\n\t\t\texpect(spy.values[2]).to.equal(true)\n\t\t\texpect(spy.values[3]).to.equal(\"3\")\n\t\tend)\n\n\t\tit(\"should return the value of the inner function\", function()\n\t\t\tlocal spy = createSpy(function()\n\t\t\t\treturn true\n\t\t\tend)\n\n\t\t\texpect(spy.value()).to.equal(true)\n\t\tend)\n\tend)\n\n\tdescribe(\"assertCalledWith\", function()\n\t\tit(\"should throw if the number of values differs\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\t\t\tspy.value(1, 2)\n\n\t\t\texpect(function()\n\t\t\t\tspy:assertCalledWith(1)\n\t\t\tend).to.throw()\n\t\tend)\n\n\t\tit(\"should throw if any value differs\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\t\t\tspy.value(1, 2)\n\n\t\t\texpect(function()\n\t\t\t\tspy:assertCalledWith(1, 3)\n\t\t\tend).to.throw()\n\n\t\t\texpect(function()\n\t\t\t\tspy:assertCalledWith(2, 3)\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tdescribe(\"captureValues\", function()\n\t\tit(\"should throw if the number of values differs\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\t\t\tspy.value(1, 2)\n\n\t\t\texpect(function()\n\t\t\t\tspy:captureValues(\"a\")\n\t\t\tend).to.throw()\n\t\tend)\n\n\t\tit(\"should capture all values in a table\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\t\t\tspy.value(1, 2)\n\n\t\t\tlocal captured = spy:captureValues(\"a\", \"b\")\n\t\t\texpect(captured.a).to.equal(1)\n\t\t\texpect(captured.b).to.equal(2)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createSpy",
                        "ClassName": "ModuleScript",
                        "Source": "--!strict\n--[[\n\tA utility used to create a function spy that can be used to robustly test\n\tthat functions are invoked the correct number of times and with the correct\n\tnumber of arguments.\n\n\tThis should only be used in tests.\n]]\n\nlocal assertDeepEqual = require(script.Parent.assertDeepEqual)\n\nlocal function createSpy(inner)\n\tlocal self = {}\n\tself.callCount = 0\n\tself.values = {}\n\tself.valuesLength = 0\n\tself.value = function(...)\n\t\tself.callCount = self.callCount + 1\n\t\tself.values = { ... }\n\t\tself.valuesLength = select(\"#\", ...)\n\n\t\tif inner ~= nil then\n\t\t\treturn inner(...)\n\t\tend\n\t\treturn nil\n\tend\n\n\tself.assertCalledWith = function(_, ...)\n\t\tlocal len = select(\"#\", ...)\n\n\t\tif self.valuesLength ~= len then\n\t\t\terror((\"Expected %d arguments, but was called with %d arguments\"):format(self.valuesLength, len), 2)\n\t\tend\n\n\t\tfor i = 1, len do\n\t\t\tlocal expected = select(i, ...)\n\n\t\t\tassert(self.values[i] == expected, \"value differs\")\n\t\tend\n\tend\n\n\tself.assertCalledWithDeepEqual = function(_, ...)\n\t\tlocal len = select(\"#\", ...)\n\n\t\tif self.valuesLength ~= len then\n\t\t\terror((\"Expected %d arguments, but was called with %d arguments\"):format(self.valuesLength, len), 2)\n\t\tend\n\n\t\tfor i = 1, len do\n\t\t\tlocal expected = select(i, ...)\n\n\t\t\tassertDeepEqual(self.values[i], expected)\n\t\tend\n\tend\n\n\tself.captureValues = function(_, ...)\n\t\tlocal len = select(\"#\", ...)\n\t\tlocal result = {}\n\n\t\tassert(self.valuesLength == len, \"length of expected values differs from stored values\")\n\n\t\tfor i = 1, len do\n\t\t\tlocal key = select(i, ...)\n\t\t\tresult[key] = self.values[i]\n\t\tend\n\n\t\treturn result\n\tend\n\n\tsetmetatable(self, {\n\t\t__index = function(_, key)\n\t\t\terror((\"%q is not a valid member of spy\"):format(key))\n\t\tend,\n\t})\n\n\treturn self\nend\n\nreturn createSpy\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createSignal.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal createSignal = require(script.Parent.createSignal)\n\n\tlocal createSpy = require(script.Parent.createSpy)\n\n\tit(\"should fire subscribers and disconnect them\", function()\n\t\tlocal signal = createSignal()\n\n\t\tlocal spy = createSpy()\n\t\tlocal disconnect = signal:subscribe(spy.value)\n\n\t\texpect(spy.callCount).to.equal(0)\n\n\t\tlocal a = 1\n\t\tlocal b = {}\n\t\tlocal c = \"hello\"\n\t\tsignal:fire(a, b, c)\n\n\t\texpect(spy.callCount).to.equal(1)\n\t\tspy:assertCalledWith(a, b, c)\n\n\t\tdisconnect()\n\n\t\tsignal:fire()\n\n\t\texpect(spy.callCount).to.equal(1)\n\tend)\n\n\tit(\"should handle multiple subscribers\", function()\n\t\tlocal signal = createSignal()\n\n\t\tlocal spyA = createSpy()\n\t\tlocal spyB = createSpy()\n\n\t\tlocal disconnectA = signal:subscribe(spyA.value)\n\t\tlocal disconnectB = signal:subscribe(spyB.value)\n\n\t\texpect(spyA.callCount).to.equal(0)\n\t\texpect(spyB.callCount).to.equal(0)\n\n\t\tlocal a = {}\n\t\tlocal b = 67\n\t\tsignal:fire(a, b)\n\n\t\texpect(spyA.callCount).to.equal(1)\n\t\tspyA:assertCalledWith(a, b)\n\n\t\texpect(spyB.callCount).to.equal(1)\n\t\tspyB:assertCalledWith(a, b)\n\n\t\tdisconnectA()\n\n\t\tsignal:fire(b, a)\n\n\t\texpect(spyA.callCount).to.equal(1)\n\n\t\texpect(spyB.callCount).to.equal(2)\n\t\tspyB:assertCalledWith(b, a)\n\n\t\tdisconnectB()\n\tend)\n\n\tit(\"should stop firing a connection if disconnected mid-fire\", function()\n\t\tlocal signal = createSignal()\n\n\t\t-- In this test, we'll connect two listeners that each try to disconnect\n\t\t-- the other. Because the order of listeners firing isn't defined, we\n\t\t-- have to be careful to handle either case.\n\n\t\tlocal disconnectA\n\t\tlocal disconnectB\n\n\t\tlocal spyA = createSpy(function()\n\t\t\tdisconnectB()\n\t\tend)\n\n\t\tlocal spyB = createSpy(function()\n\t\t\tdisconnectA()\n\t\tend)\n\n\t\tdisconnectA = signal:subscribe(spyA.value)\n\t\tdisconnectB = signal:subscribe(spyB.value)\n\n\t\tsignal:fire()\n\n\t\t-- Exactly once listener should have been called.\n\t\texpect(spyA.callCount + spyB.callCount).to.equal(1)\n\tend)\n\n\tit(\"should allow adding listener in the middle of firing\", function()\n\t\tlocal signal = createSignal()\n\n\t\tlocal disconnectA\n\t\tlocal spyA = createSpy()\n\t\tlocal listener = function(_a, _b)\n\t\t\tdisconnectA = signal:subscribe(spyA.value)\n\t\tend\n\n\t\tlocal disconnectListener = signal:subscribe(listener)\n\n\t\texpect(spyA.callCount).to.equal(0)\n\n\t\tlocal a = {}\n\t\tlocal b = 67\n\t\tsignal:fire(a, b)\n\n\t\texpect(spyA.callCount).to.equal(0)\n\n\t\t-- The new listener should be picked up in next fire.\n\t\tsignal:fire(b, a)\n\t\texpect(spyA.callCount).to.equal(1)\n\t\tspyA:assertCalledWith(b, a)\n\n\t\tdisconnectA()\n\t\tdisconnectListener()\n\n\t\tsignal:fire(a)\n\n\t\texpect(spyA.callCount).to.equal(1)\n\tend)\n\n\tit(\"should have one connection instance when add the same listener multiple times\", function()\n\t\tlocal signal = createSignal()\n\n\t\tlocal spyA = createSpy()\n\t\tlocal disconnect1 = signal:subscribe(spyA.value)\n\n\t\texpect(spyA.callCount).to.equal(0)\n\n\t\tlocal a = {}\n\t\tlocal b = 67\n\t\tsignal:fire(a, b)\n\n\t\texpect(spyA.callCount).to.equal(1)\n\t\tspyA:assertCalledWith(a, b)\n\n\t\tlocal disconnect2 = signal:subscribe(spyA.value)\n\n\t\tsignal:fire(b, a)\n\t\texpect(spyA.callCount).to.equal(2)\n\t\tspyA:assertCalledWith(b, a)\n\n\t\tdisconnect2()\n\n\t\tsignal:fire(a)\n\n\t\texpect(spyA.callCount).to.equal(2)\n\n\t\t-- should have no effect.\n\t\tdisconnect1()\n\t\tsignal:fire(a)\n\t\texpect(spyA.callCount).to.equal(2)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createSignal",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tThis is a simple signal implementation that has a dead-simple API.\n\n\t\tlocal signal = createSignal()\n\n\t\tlocal disconnect = signal:subscribe(function(foo)\n\t\t\tprint(\"Cool foo:\", foo)\n\t\tend)\n\n\t\tsignal:fire(\"something\")\n\n\t\tdisconnect()\n]]\n\nlocal function createSignal()\n\tlocal connections = {}\n\tlocal suspendedConnections = {}\n\tlocal firing = false\n\n\tlocal function subscribe(_self, callback)\n\t\tassert(typeof(callback) == \"function\", \"Can only subscribe to signals with a function.\")\n\n\t\tlocal connection = {\n\t\t\tcallback = callback,\n\t\t\tdisconnected = false,\n\t\t}\n\n\t\t-- If the callback is already registered, don't add to the suspendedConnection. Otherwise, this will disable\n\t\t-- the existing one.\n\t\tif firing and not connections[callback] then\n\t\t\tsuspendedConnections[callback] = connection\n\t\tend\n\n\t\tconnections[callback] = connection\n\n\t\tlocal function disconnect()\n\t\t\tassert(not connection.disconnected, \"Listeners can only be disconnected once.\")\n\n\t\t\tconnection.disconnected = true\n\t\t\tconnections[callback] = nil\n\t\t\tsuspendedConnections[callback] = nil\n\t\tend\n\n\t\treturn disconnect\n\tend\n\n\tlocal function fire(_self, ...)\n\t\tfiring = true\n\t\tfor callback, connection in pairs(connections) do\n\t\t\tif not connection.disconnected and not suspendedConnections[callback] then\n\t\t\t\tcallback(...)\n\t\t\tend\n\t\tend\n\n\t\tfiring = false\n\n\t\tfor callback, _ in pairs(suspendedConnections) do\n\t\t\tsuspendedConnections[callback] = nil\n\t\tend\n\tend\n\n\treturn {\n\t\tsubscribe = subscribe,\n\t\tfire = fire,\n\t}\nend\n\nreturn createSignal\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createRef.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal Binding = require(script.Parent.Binding)\n\tlocal Type = require(script.Parent.Type)\n\n\tlocal createRef = require(script.Parent.createRef)\n\n\tit(\"should create refs, which are specialized bindings\", function()\n\t\tlocal ref = createRef()\n\n\t\texpect(Type.of(ref)).to.equal(Type.Binding)\n\t\texpect(ref.current).to.equal(nil)\n\tend)\n\n\tit(\"should have a 'current' field that is the same as the internal binding's value\", function()\n\t\tlocal ref = createRef()\n\n\t\texpect(ref.current).to.equal(nil)\n\n\t\tBinding.update(ref, 10)\n\t\texpect(ref.current).to.equal(10)\n\tend)\n\n\tit(\"should support tostring on refs\", function()\n\t\tlocal ref = createRef()\n\n\t\texpect(ref.current).to.equal(nil)\n\t\texpect(tostring(ref)).to.equal(\"RoactRef(nil)\")\n\n\t\tBinding.update(ref, 10)\n\t\texpect(tostring(ref)).to.equal(\"RoactRef(10)\")\n\tend)\n\n\tit(\"should not allow assignments to the 'current' field\", function()\n\t\tlocal ref = createRef()\n\n\t\texpect(ref.current).to.equal(nil)\n\n\t\tBinding.update(ref, 99)\n\t\texpect(ref.current).to.equal(99)\n\n\t\texpect(function()\n\t\t\tref.current = 77\n\t\tend).to.throw()\n\n\t\texpect(ref.current).to.equal(99)\n\tend)\n\n\tit(\"should return the same thing from getValue as its current field\", function()\n\t\tlocal ref = createRef()\n\t\tBinding.update(ref, 10)\n\n\t\texpect(ref:getValue()).to.equal(10)\n\t\texpect(ref:getValue()).to.equal(ref.current)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createRef",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tA ref is nothing more than a binding with a special field 'current'\n\tthat maps to the getValue method of the binding\n]]\nlocal Binding = require(script.Parent.Binding)\n\nlocal function createRef()\n\tlocal binding, _ = Binding.create(nil)\n\n\tlocal ref = {}\n\n\t--[[\n\t\tA ref is just redirected to a binding via its metatable\n\t]]\n\tsetmetatable(ref, {\n\t\t__index = function(_self, key)\n\t\t\tif key == \"current\" then\n\t\t\t\treturn binding:getValue()\n\t\t\telse\n\t\t\t\treturn binding[key]\n\t\t\tend\n\t\tend,\n\t\t__newindex = function(_self, key, value)\n\t\t\tif key == \"current\" then\n\t\t\t\terror(\"Cannot assign to the 'current' property of refs\", 2)\n\t\t\tend\n\n\t\t\tbinding[key] = value\n\t\tend,\n\t\t__tostring = function(_self)\n\t\t\treturn (\"RoactRef(%s)\"):format(tostring(binding:getValue()))\n\t\tend,\n\t})\n\n\treturn ref\nend\n\nreturn createRef\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createReconcilerCompat.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal createElement = require(script.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.createReconciler)\n\tlocal Logging = require(script.Parent.Logging)\n\tlocal NoopRenderer = require(script.Parent.NoopRenderer)\n\n\tlocal createReconcilerCompat = require(script.Parent.createReconcilerCompat)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\tlocal compatReconciler = createReconcilerCompat(noopReconciler)\n\n\tit(\"reify should only warn once per call site\", function()\n\t\tlocal logInfo = Logging.capture(function()\n\t\t\t-- We're using a loop so that we get the same stack trace and only one\n\t\t\t-- warning hopefully.\n\t\t\tfor _ = 1, 2 do\n\t\t\t\tlocal handle = compatReconciler.reify(createElement(\"StringValue\"))\n\t\t\t\tnoopReconciler.unmountVirtualTree(handle)\n\t\t\tend\n\t\tend)\n\n\t\texpect(#logInfo.warnings).to.equal(1)\n\t\texpect(logInfo.warnings[1]:find(\"reify\")).to.be.ok()\n\n\t\tlogInfo = Logging.capture(function()\n\t\t\t-- This is a different call site, which should trigger another warning.\n\t\t\tlocal handle = compatReconciler.reify(createElement(\"StringValue\"))\n\t\t\tnoopReconciler.unmountVirtualTree(handle)\n\t\tend)\n\n\t\texpect(#logInfo.warnings).to.equal(1)\n\t\texpect(logInfo.warnings[1]:find(\"reify\")).to.be.ok()\n\tend)\n\n\tit(\"teardown should only warn once per call site\", function()\n\t\tlocal logInfo = Logging.capture(function()\n\t\t\t-- We're using a loop so that we get the same stack trace and only one\n\t\t\t-- warning hopefully.\n\t\t\tfor _ = 1, 2 do\n\t\t\t\tlocal handle = noopReconciler.mountVirtualTree(createElement(\"StringValue\"))\n\t\t\t\tcompatReconciler.teardown(handle)\n\t\t\tend\n\t\tend)\n\n\t\texpect(#logInfo.warnings).to.equal(1)\n\t\texpect(logInfo.warnings[1]:find(\"teardown\")).to.be.ok()\n\n\t\tlogInfo = Logging.capture(function()\n\t\t\t-- This is a different call site, which should trigger another warning.\n\t\t\tlocal handle = noopReconciler.mountVirtualTree(createElement(\"StringValue\"))\n\t\t\tcompatReconciler.teardown(handle)\n\t\tend)\n\n\t\texpect(#logInfo.warnings).to.equal(1)\n\t\texpect(logInfo.warnings[1]:find(\"teardown\")).to.be.ok()\n\tend)\n\n\tit(\"update should only warn once per call site\", function()\n\t\tlocal logInfo = Logging.capture(function()\n\t\t\t-- We're using a loop so that we get the same stack trace and only one\n\t\t\t-- warning hopefully.\n\t\t\tfor _ = 1, 2 do\n\t\t\t\tlocal handle = noopReconciler.mountVirtualTree(createElement(\"StringValue\"))\n\t\t\t\tcompatReconciler.reconcile(handle, createElement(\"StringValue\"))\n\t\t\t\tnoopReconciler.unmountVirtualTree(handle)\n\t\t\tend\n\t\tend)\n\n\t\texpect(#logInfo.warnings).to.equal(1)\n\t\texpect(logInfo.warnings[1]:find(\"reconcile\")).to.be.ok()\n\n\t\tlogInfo = Logging.capture(function()\n\t\t\t-- This is a different call site, which should trigger another warning.\n\t\t\tlocal handle = noopReconciler.mountVirtualTree(createElement(\"StringValue\"))\n\t\t\tcompatReconciler.reconcile(handle, createElement(\"StringValue\"))\n\t\t\tnoopReconciler.unmountVirtualTree(handle)\n\t\tend)\n\n\t\texpect(#logInfo.warnings).to.equal(1)\n\t\texpect(logInfo.warnings[1]:find(\"reconcile\")).to.be.ok()\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createReconcilerCompat",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tContains deprecated methods from Reconciler. Broken out so that removing\n\tthis shim is easy -- just delete this file and remove it from init.\n]]\n\nlocal Logging = require(script.Parent.Logging)\n\nlocal reifyMessage = [[\nRoact.reify has been renamed to Roact.mount and will be removed in a future release.\nCheck the call to Roact.reify at:\n]]\n\nlocal teardownMessage = [[\nRoact.teardown has been renamed to Roact.unmount and will be removed in a future release.\nCheck the call to Roact.teardown at:\n]]\n\nlocal reconcileMessage = [[\nRoact.reconcile has been renamed to Roact.update and will be removed in a future release.\nCheck the call to Roact.reconcile at:\n]]\n\nlocal function createReconcilerCompat(reconciler)\n\tlocal compat = {}\n\n\tfunction compat.reify(...)\n\t\tLogging.warnOnce(reifyMessage)\n\n\t\treturn reconciler.mountVirtualTree(...)\n\tend\n\n\tfunction compat.teardown(...)\n\t\tLogging.warnOnce(teardownMessage)\n\n\t\treturn reconciler.unmountVirtualTree(...)\n\tend\n\n\tfunction compat.reconcile(...)\n\t\tLogging.warnOnce(reconcileMessage)\n\n\t\treturn reconciler.updateVirtualTree(...)\n\tend\n\n\treturn compat\nend\n\nreturn createReconcilerCompat\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createReconciler.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal assign = require(script.Parent.assign)\n\tlocal createElement = require(script.Parent.createElement)\n\tlocal createFragment = require(script.Parent.createFragment)\n\tlocal createSpy = require(script.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Type)\n\tlocal ElementKind = require(script.Parent.ElementKind)\n\n\tlocal createReconciler = require(script.Parent.createReconciler)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tdescribe(\"tree operations\", function()\n\t\tit(\"should mount and unmount\", function()\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(createElement(\"StringValue\"))\n\n\t\t\texpect(tree).to.be.ok()\n\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\t\tend)\n\n\t\tit(\"should mount, update, and unmount\", function()\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(createElement(\"StringValue\"))\n\n\t\t\texpect(tree).to.be.ok()\n\n\t\t\tnoopReconciler.updateVirtualTree(tree, createElement(\"StringValue\"))\n\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\t\tend)\n\tend)\n\n\tdescribe(\"booleans\", function()\n\t\tit(\"should mount booleans as nil\", function()\n\t\t\tlocal node = noopReconciler.mountVirtualNode(false, nil, \"test\")\n\t\t\texpect(node).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should unmount nodes if they are updated to a boolean value\", function()\n\t\t\tlocal node = noopReconciler.mountVirtualNode(createElement(\"StringValue\"), nil, \"test\")\n\n\t\t\texpect(node).to.be.ok()\n\n\t\t\tnode = noopReconciler.updateVirtualNode(node, true)\n\n\t\t\texpect(node).to.equal(nil)\n\t\tend)\n\tend)\n\n\tdescribe(\"invalid elements\", function()\n\t\tit(\"should throw errors when attempting to mount invalid elements\", function()\n\t\t\t-- These function components return values with incorrect types\n\t\t\tlocal returnsString = function()\n\t\t\t\treturn \"Hello\"\n\t\t\tend\n\t\t\tlocal returnsNumber = function()\n\t\t\t\treturn 1\n\t\t\tend\n\t\t\tlocal returnsFunction = function()\n\t\t\t\treturn function() end\n\t\t\tend\n\t\t\tlocal returnsTable = function()\n\t\t\t\treturn {}\n\t\t\tend\n\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\texpect(function()\n\t\t\t\tnoopReconciler.mountVirtualNode(createElement(returnsString), hostParent, key)\n\t\t\tend).to.throw()\n\n\t\t\texpect(function()\n\t\t\t\tnoopReconciler.mountVirtualNode(createElement(returnsNumber), hostParent, key)\n\t\t\tend).to.throw()\n\n\t\t\texpect(function()\n\t\t\t\tnoopReconciler.mountVirtualNode(createElement(returnsFunction), hostParent, key)\n\t\t\tend).to.throw()\n\n\t\t\texpect(function()\n\t\t\t\tnoopReconciler.mountVirtualNode(createElement(returnsTable), hostParent, key)\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tdescribe(\"Host components\", function()\n\t\tit(\"should invoke the renderer to mount host nodes\", function()\n\t\t\tlocal mountHostNode = createSpy(NoopRenderer.mountHostNode)\n\n\t\t\tlocal renderer = assign({}, NoopRenderer, {\n\t\t\t\tmountHostNode = mountHostNode.value,\n\t\t\t})\n\n\t\t\tlocal reconciler = createReconciler(renderer)\n\n\t\t\tlocal element = createElement(\"StringValue\")\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Some Key\"\n\t\t\tlocal node = reconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(Type.of(node)).to.equal(Type.VirtualNode)\n\n\t\t\texpect(mountHostNode.callCount).to.equal(1)\n\n\t\t\tlocal values = mountHostNode:captureValues(\"reconciler\", \"node\")\n\n\t\t\texpect(values.reconciler).to.equal(reconciler)\n\t\t\texpect(values.node).to.equal(node)\n\t\tend)\n\n\t\tit(\"should invoke the renderer to update host nodes\", function()\n\t\t\tlocal updateHostNode = createSpy(NoopRenderer.updateHostNode)\n\n\t\t\tlocal renderer = assign({}, NoopRenderer, {\n\t\t\t\tmountHostNode = NoopRenderer.mountHostNode,\n\t\t\t\tupdateHostNode = updateHostNode.value,\n\t\t\t})\n\n\t\t\tlocal reconciler = createReconciler(renderer)\n\n\t\t\tlocal element = createElement(\"StringValue\")\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Key\"\n\t\t\tlocal node = reconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(Type.of(node)).to.equal(Type.VirtualNode)\n\n\t\t\tlocal newElement = createElement(\"StringValue\")\n\t\t\tlocal newNode = reconciler.updateVirtualNode(node, newElement)\n\n\t\t\texpect(newNode).to.equal(node)\n\n\t\t\texpect(updateHostNode.callCount).to.equal(1)\n\n\t\t\tlocal values = updateHostNode:captureValues(\"reconciler\", \"node\", \"newElement\")\n\n\t\t\texpect(values.reconciler).to.equal(reconciler)\n\t\t\texpect(values.node).to.equal(node)\n\t\t\texpect(values.newElement).to.equal(newElement)\n\t\tend)\n\n\t\tit(\"should invoke the renderer to unmount host nodes\", function()\n\t\t\tlocal unmountHostNode = createSpy(NoopRenderer.unmountHostNode)\n\n\t\t\tlocal renderer = assign({}, NoopRenderer, {\n\t\t\t\tmountHostNode = NoopRenderer.mountHostNode,\n\t\t\t\tunmountHostNode = unmountHostNode.value,\n\t\t\t})\n\n\t\t\tlocal reconciler = createReconciler(renderer)\n\n\t\t\tlocal element = createElement(\"StringValue\")\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Key\"\n\t\t\tlocal node = reconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(Type.of(node)).to.equal(Type.VirtualNode)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(unmountHostNode.callCount).to.equal(1)\n\n\t\t\tlocal values = unmountHostNode:captureValues(\"reconciler\", \"node\")\n\n\t\t\texpect(values.reconciler).to.equal(reconciler)\n\t\t\texpect(values.node).to.equal(node)\n\t\tend)\n\tend)\n\n\tdescribe(\"Function components\", function()\n\t\tit(\"should mount and unmount function components\", function()\n\t\t\tlocal componentSpy = createSpy(function(_props)\n\t\t\t\treturn nil\n\t\t\tend)\n\n\t\t\tlocal element = createElement(componentSpy.value, {\n\t\t\t\tsomeValue = 5,\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"A Key\"\n\t\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(Type.of(node)).to.equal(Type.VirtualNode)\n\n\t\t\texpect(componentSpy.callCount).to.equal(1)\n\n\t\t\tlocal calledWith = componentSpy:captureValues(\"props\")\n\n\t\t\texpect(calledWith.props).to.be.a(\"table\")\n\t\t\texpect(calledWith.props.someValue).to.equal(5)\n\n\t\t\tnoopReconciler.unmountVirtualNode(node)\n\n\t\t\texpect(componentSpy.callCount).to.equal(1)\n\t\tend)\n\n\t\tit(\"should mount single children of function components\", function()\n\t\t\tlocal childComponentSpy = createSpy(function(_props)\n\t\t\t\treturn nil\n\t\t\tend)\n\n\t\t\tlocal parentComponentSpy = createSpy(function(props)\n\t\t\t\treturn createElement(childComponentSpy.value, {\n\t\t\t\t\tvalue = props.value + 1,\n\t\t\t\t})\n\t\t\tend)\n\n\t\t\tlocal element = createElement(parentComponentSpy.value, {\n\t\t\t\tvalue = 13,\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"A Key\"\n\t\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(Type.of(node)).to.equal(Type.VirtualNode)\n\n\t\t\texpect(parentComponentSpy.callCount).to.equal(1)\n\t\t\texpect(childComponentSpy.callCount).to.equal(1)\n\n\t\t\tlocal parentCalledWith = parentComponentSpy:captureValues(\"props\")\n\t\t\tlocal childCalledWith = childComponentSpy:captureValues(\"props\")\n\n\t\t\texpect(parentCalledWith.props).to.be.a(\"table\")\n\t\t\texpect(parentCalledWith.props.value).to.equal(13)\n\n\t\t\texpect(childCalledWith.props).to.be.a(\"table\")\n\t\t\texpect(childCalledWith.props.value).to.equal(14)\n\n\t\t\tnoopReconciler.unmountVirtualNode(node)\n\n\t\t\texpect(parentComponentSpy.callCount).to.equal(1)\n\t\t\texpect(childComponentSpy.callCount).to.equal(1)\n\t\tend)\n\n\t\tit(\"should mount fragments returned by function components\", function()\n\t\t\tlocal childAComponentSpy = createSpy(function(_props)\n\t\t\t\treturn nil\n\t\t\tend)\n\n\t\t\tlocal childBComponentSpy = createSpy(function(_props)\n\t\t\t\treturn nil\n\t\t\tend)\n\n\t\t\tlocal parentComponentSpy = createSpy(function(props)\n\t\t\t\treturn createFragment({\n\t\t\t\t\tA = createElement(childAComponentSpy.value, {\n\t\t\t\t\t\tvalue = props.value + 1,\n\t\t\t\t\t}),\n\t\t\t\t\tB = createElement(childBComponentSpy.value, {\n\t\t\t\t\t\tvalue = props.value + 5,\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\tend)\n\n\t\t\tlocal element = createElement(parentComponentSpy.value, {\n\t\t\t\tvalue = 17,\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"A Key\"\n\t\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(Type.of(node)).to.equal(Type.VirtualNode)\n\n\t\t\texpect(parentComponentSpy.callCount).to.equal(1)\n\t\t\texpect(childAComponentSpy.callCount).to.equal(1)\n\t\t\texpect(childBComponentSpy.callCount).to.equal(1)\n\n\t\t\tlocal parentCalledWith = parentComponentSpy:captureValues(\"props\")\n\t\t\tlocal childACalledWith = childAComponentSpy:captureValues(\"props\")\n\t\t\tlocal childBCalledWith = childBComponentSpy:captureValues(\"props\")\n\n\t\t\texpect(parentCalledWith.props).to.be.a(\"table\")\n\t\t\texpect(parentCalledWith.props.value).to.equal(17)\n\n\t\t\texpect(childACalledWith.props).to.be.a(\"table\")\n\t\t\texpect(childACalledWith.props.value).to.equal(18)\n\n\t\t\texpect(childBCalledWith.props).to.be.a(\"table\")\n\t\t\texpect(childBCalledWith.props.value).to.equal(22)\n\n\t\t\tnoopReconciler.unmountVirtualNode(node)\n\n\t\t\texpect(parentComponentSpy.callCount).to.equal(1)\n\t\t\texpect(childAComponentSpy.callCount).to.equal(1)\n\t\t\texpect(childBComponentSpy.callCount).to.equal(1)\n\t\tend)\n\tend)\n\n\tdescribe(\"Fragments\", function()\n\t\tit(\"should mount fragments\", function()\n\t\t\tlocal fragment = createFragment({})\n\t\t\tlocal node = noopReconciler.mountVirtualNode(fragment, nil, \"test\")\n\n\t\t\texpect(node).to.be.ok()\n\t\t\texpect(ElementKind.of(node.currentElement)).to.equal(ElementKind.Fragment)\n\t\tend)\n\n\t\tit(\"should mount an empty fragment\", function()\n\t\t\tlocal emptyFragment = createFragment({})\n\t\t\tlocal node = noopReconciler.mountVirtualNode(emptyFragment, nil, \"test\")\n\n\t\t\texpect(node).to.be.ok()\n\t\t\texpect(next(node.children)).to.never.be.ok()\n\t\tend)\n\n\t\tit(\"should mount all fragment's children\", function()\n\t\t\tlocal childComponentSpy = createSpy(function(_props)\n\t\t\t\treturn nil\n\t\t\tend)\n\t\t\tlocal elements = {}\n\t\t\tlocal totalElements = 5\n\n\t\t\tfor i = 1, totalElements do\n\t\t\t\telements[\"key\" .. tostring(i)] = createElement(childComponentSpy.value, {})\n\t\t\tend\n\n\t\t\tlocal fragments = createFragment(elements)\n\t\t\tlocal node = noopReconciler.mountVirtualNode(fragments, nil, \"test\")\n\n\t\t\texpect(node).to.be.ok()\n\t\t\texpect(childComponentSpy.callCount).to.equal(totalElements)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createReconciler",
                        "ClassName": "ModuleScript",
                        "Source": "--!nonstrict\nlocal Type = require(script.Parent.Type)\nlocal ElementKind = require(script.Parent.ElementKind)\nlocal ElementUtils = require(script.Parent.ElementUtils)\nlocal Children = require(script.Parent.PropMarkers.Children)\nlocal Symbol = require(script.Parent.Symbol)\nlocal internalAssert = require(script.Parent.internalAssert)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal InternalData = Symbol.named(\"InternalData\")\n\n--[[\n\tThe reconciler is the mechanism in Roact that constructs the virtual tree\n\tthat later gets turned into concrete objects by the renderer.\n\n\tRoact's reconciler is constructed with the renderer as an argument, which\n\tenables switching to different renderers for different platforms or\n\tscenarios.\n\n\tWhen testing the reconciler itself, it's common to use `NoopRenderer` with\n\tspies replacing some methods. The default (and only) reconciler interface\n\texposed by Roact right now uses `RobloxRenderer`.\n]]\nlocal function createReconciler(renderer)\n\tlocal reconciler\n\tlocal mountVirtualNode\n\tlocal updateVirtualNode\n\tlocal unmountVirtualNode\n\n\t--[[\n\t\tUnmount the given virtualNode, replacing it with a new node described by\n\t\tthe given element.\n\n\t\tPreserves host properties, depth, and legacyContext from parent.\n\t]]\n\tlocal function replaceVirtualNode(virtualNode, newElement)\n\t\tlocal hostParent = virtualNode.hostParent\n\t\tlocal hostKey = virtualNode.hostKey\n\t\tlocal depth = virtualNode.depth\n\t\tlocal parent = virtualNode.parent\n\n\t\t-- If the node that is being replaced has modified context, we need to\n\t\t-- use the original *unmodified* context for the new node\n\t\t-- The `originalContext` field will be nil if the context was unchanged\n\t\tlocal context = virtualNode.originalContext or virtualNode.context\n\t\tlocal parentLegacyContext = virtualNode.parentLegacyContext\n\n\t\t-- If updating this node has caused a component higher up the tree to re-render\n\t\t-- and updateChildren to be re-entered then this node could already have been\n\t\t-- unmounted in the previous updateChildren pass.\n\t\tif not virtualNode.wasUnmounted then\n\t\t\tunmountVirtualNode(virtualNode)\n\t\tend\n\t\tlocal newNode = mountVirtualNode(newElement, hostParent, hostKey, context, parentLegacyContext)\n\n\t\t-- mountVirtualNode can return nil if the element is a boolean\n\t\tif newNode ~= nil then\n\t\t\tnewNode.depth = depth\n\t\t\tnewNode.parent = parent\n\t\tend\n\n\t\treturn newNode\n\tend\n\n\t--[[\n\t\tUtility to update the children of a virtual node based on zero or more\n\t\tupdated children given as elements.\n\t]]\n\tlocal function updateChildren(virtualNode, hostParent, newChildElements)\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #1 to be of type VirtualNode\")\n\t\tend\n\n\t\tvirtualNode.updateChildrenCount = virtualNode.updateChildrenCount + 1\n\n\t\tlocal currentUpdateChildrenCount = virtualNode.updateChildrenCount\n\n\t\tlocal removeKeys = {}\n\n\t\t-- Changed or removed children\n\t\tfor childKey, childNode in pairs(virtualNode.children) do\n\t\t\tlocal newElement = ElementUtils.getElementByKey(newChildElements, childKey)\n\t\t\tlocal newNode = updateVirtualNode(childNode, newElement)\n\n\t\t\t-- If updating this node has caused a component higher up the tree to re-render\n\t\t\t-- and updateChildren to be re-entered for this virtualNode then\n\t\t\t-- this result is invalid and needs to be disgarded.\n\t\t\tif virtualNode.updateChildrenCount ~= currentUpdateChildrenCount then\n\t\t\t\tif newNode and newNode ~= virtualNode.children[childKey] then\n\t\t\t\t\tunmountVirtualNode(newNode)\n\t\t\t\tend\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\tif newNode ~= nil then\n\t\t\t\tvirtualNode.children[childKey] = newNode\n\t\t\telse\n\t\t\t\tremoveKeys[childKey] = true\n\t\t\tend\n\t\tend\n\n\t\tfor childKey in pairs(removeKeys) do\n\t\t\tvirtualNode.children[childKey] = nil\n\t\tend\n\n\t\t-- Added children\n\t\tfor childKey, newElement in ElementUtils.iterateElements(newChildElements) do\n\t\t\tlocal concreteKey = childKey\n\t\t\tif childKey == ElementUtils.UseParentKey then\n\t\t\t\tconcreteKey = virtualNode.hostKey\n\t\t\tend\n\n\t\t\tif virtualNode.children[childKey] == nil then\n\t\t\t\tlocal childNode = mountVirtualNode(\n\t\t\t\t\tnewElement,\n\t\t\t\t\thostParent,\n\t\t\t\t\tconcreteKey,\n\t\t\t\t\tvirtualNode.context,\n\t\t\t\t\tvirtualNode.legacyContext\n\t\t\t\t)\n\n\t\t\t\t-- If updating this node has caused a component higher up the tree to re-render\n\t\t\t\t-- and updateChildren to be re-entered for this virtualNode then\n\t\t\t\t-- this result is invalid and needs to be discarded.\n\t\t\t\tif virtualNode.updateChildrenCount ~= currentUpdateChildrenCount then\n\t\t\t\t\tif childNode then\n\t\t\t\t\t\tunmountVirtualNode(childNode)\n\t\t\t\t\tend\n\t\t\t\t\treturn\n\t\t\t\tend\n\n\t\t\t\t-- mountVirtualNode can return nil if the element is a boolean\n\t\t\t\tif childNode ~= nil then\n\t\t\t\t\tchildNode.depth = virtualNode.depth + 1\n\t\t\t\t\tchildNode.parent = virtualNode\n\t\t\t\t\tvirtualNode.children[childKey] = childNode\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal function updateVirtualNodeWithChildren(virtualNode, hostParent, newChildElements)\n\t\tupdateChildren(virtualNode, hostParent, newChildElements)\n\tend\n\n\tlocal function updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)\n\t\tif Type.of(renderResult) == Type.Element or renderResult == nil or typeof(renderResult) == \"boolean\" then\n\t\t\tupdateChildren(virtualNode, hostParent, renderResult)\n\t\telse\n\t\t\terror(\n\t\t\t\t(\"%s\\n%s\"):format(\n\t\t\t\t\t\"Component returned invalid children:\",\n\t\t\t\t\tvirtualNode.currentElement.source or \"<enable element tracebacks>\"\n\t\t\t\t),\n\t\t\t\t0\n\t\t\t)\n\t\tend\n\tend\n\n\t--[[\n\t\tUnmounts the given virtual node and releases any held resources.\n\t]]\n\tfunction unmountVirtualNode(virtualNode)\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #1 to be of type VirtualNode\")\n\t\tend\n\n\t\tvirtualNode.wasUnmounted = true\n\n\t\tlocal kind = ElementKind.of(virtualNode.currentElement)\n\n\t\t-- selene: allow(if_same_then_else)\n\t\tif kind == ElementKind.Host then\n\t\t\trenderer.unmountHostNode(reconciler, virtualNode)\n\t\telseif kind == ElementKind.Function then\n\t\t\tfor _, childNode in pairs(virtualNode.children) do\n\t\t\t\tunmountVirtualNode(childNode)\n\t\t\tend\n\t\telseif kind == ElementKind.Stateful then\n\t\t\tvirtualNode.instance:__unmount()\n\t\telseif kind == ElementKind.Portal then\n\t\t\tfor _, childNode in pairs(virtualNode.children) do\n\t\t\t\tunmountVirtualNode(childNode)\n\t\t\tend\n\t\telseif kind == ElementKind.Fragment then\n\t\t\tfor _, childNode in pairs(virtualNode.children) do\n\t\t\t\tunmountVirtualNode(childNode)\n\t\t\tend\n\t\telse\n\t\t\terror((\"Unknown ElementKind %q\"):format(tostring(kind)), 2)\n\t\tend\n\tend\n\n\tlocal function updateFunctionVirtualNode(virtualNode, newElement)\n\t\tlocal children = newElement.component(newElement.props)\n\n\t\tupdateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)\n\n\t\treturn virtualNode\n\tend\n\n\tlocal function updatePortalVirtualNode(virtualNode, newElement)\n\t\tlocal oldElement = virtualNode.currentElement\n\t\tlocal oldTargetHostParent = oldElement.props.target\n\n\t\tlocal targetHostParent = newElement.props.target\n\n\t\tassert(renderer.isHostObject(targetHostParent), \"Expected target to be host object\")\n\n\t\tif targetHostParent ~= oldTargetHostParent then\n\t\t\treturn replaceVirtualNode(virtualNode, newElement)\n\t\tend\n\n\t\tlocal children = newElement.props[Children]\n\n\t\tupdateVirtualNodeWithChildren(virtualNode, targetHostParent, children)\n\n\t\treturn virtualNode\n\tend\n\n\tlocal function updateFragmentVirtualNode(virtualNode, newElement)\n\t\tupdateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, newElement.elements)\n\n\t\treturn virtualNode\n\tend\n\n\t--[[\n\t\tUpdate the given virtual node using a new element describing what it\n\t\tshould transform into.\n\n\t\t`updateVirtualNode` will return a new virtual node that should replace\n\t\tthe passed in virtual node. This is because a virtual node can be\n\t\tupdated with an element referencing a different component!\n\n\t\tIn that case, `updateVirtualNode` will unmount the input virtual node,\n\t\tmount a new virtual node, and return it in this case, while also issuing\n\t\ta warning to the user.\n\t]]\n\tfunction updateVirtualNode(virtualNode, newElement, newState)\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #1 to be of type VirtualNode\")\n\t\tend\n\t\tif config.typeChecks then\n\t\t\tassert(\n\t\t\t\tType.of(newElement) == Type.Element or typeof(newElement) == \"boolean\" or newElement == nil,\n\t\t\t\t\"Expected arg #2 to be of type Element, boolean, or nil\"\n\t\t\t)\n\t\tend\n\n\t\t-- If nothing changed, we can skip this update\n\t\tif virtualNode.currentElement == newElement and newState == nil then\n\t\t\treturn virtualNode\n\t\tend\n\n\t\tif typeof(newElement) == \"boolean\" or newElement == nil then\n\t\t\tunmountVirtualNode(virtualNode)\n\t\t\treturn nil\n\t\tend\n\n\t\tif virtualNode.currentElement.component ~= newElement.component then\n\t\t\treturn replaceVirtualNode(virtualNode, newElement)\n\t\tend\n\n\t\tlocal kind = ElementKind.of(newElement)\n\n\t\tlocal shouldContinueUpdate = true\n\n\t\tif kind == ElementKind.Host then\n\t\t\tvirtualNode = renderer.updateHostNode(reconciler, virtualNode, newElement)\n\t\telseif kind == ElementKind.Function then\n\t\t\tvirtualNode = updateFunctionVirtualNode(virtualNode, newElement)\n\t\telseif kind == ElementKind.Stateful then\n\t\t\tshouldContinueUpdate = virtualNode.instance:__update(newElement, newState)\n\t\telseif kind == ElementKind.Portal then\n\t\t\tvirtualNode = updatePortalVirtualNode(virtualNode, newElement)\n\t\telseif kind == ElementKind.Fragment then\n\t\t\tvirtualNode = updateFragmentVirtualNode(virtualNode, newElement)\n\t\telse\n\t\t\terror((\"Unknown ElementKind %q\"):format(tostring(kind)), 2)\n\t\tend\n\n\t\t-- Stateful components can abort updates via shouldUpdate. If that\n\t\t-- happens, we should stop doing stuff at this point.\n\t\tif not shouldContinueUpdate then\n\t\t\treturn virtualNode\n\t\tend\n\n\t\tvirtualNode.currentElement = newElement\n\n\t\treturn virtualNode\n\tend\n\n\t--[[\n\t\tConstructs a new virtual node but not does mount it.\n\t]]\n\tlocal function createVirtualNode(element, hostParent, hostKey, context, legacyContext)\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(\n\t\t\t\trenderer.isHostObject(hostParent) or hostParent == nil,\n\t\t\t\t\"Expected arg #2 to be a host object\"\n\t\t\t)\n\t\t\tinternalAssert(typeof(context) == \"table\" or context == nil, \"Expected arg #4 to be of type table or nil\")\n\t\t\tinternalAssert(\n\t\t\t\ttypeof(legacyContext) == \"table\" or legacyContext == nil,\n\t\t\t\t\"Expected arg #5 to be of type table or nil\"\n\t\t\t)\n\t\tend\n\t\tif config.typeChecks then\n\t\t\tassert(hostKey ~= nil, \"Expected arg #3 to be non-nil\")\n\t\t\tassert(\n\t\t\t\tType.of(element) == Type.Element or typeof(element) == \"boolean\",\n\t\t\t\t\"Expected arg #1 to be of type Element or boolean\"\n\t\t\t)\n\t\tend\n\n\t\treturn {\n\t\t\t[Type] = Type.VirtualNode,\n\t\t\tcurrentElement = element,\n\t\t\tdepth = 1,\n\t\t\tparent = nil,\n\t\t\tchildren = {},\n\t\t\thostParent = hostParent,\n\t\t\thostKey = hostKey,\n\t\t\tupdateChildrenCount = 0,\n\t\t\twasUnmounted = false,\n\n\t\t\t-- Legacy Context API\n\t\t\t-- A table of context values inherited from the parent node\n\t\t\tlegacyContext = legacyContext,\n\n\t\t\t-- A saved copy of the parent context, used when replacing a node\n\t\t\tparentLegacyContext = legacyContext,\n\n\t\t\t-- Context API\n\t\t\t-- A table of context values inherited from the parent node\n\t\t\tcontext = context or {},\n\n\t\t\t-- A saved copy of the unmodified context; this will be updated when\n\t\t\t-- a component adds new context and used when a node is replaced\n\t\t\toriginalContext = nil,\n\t\t}\n\tend\n\n\tlocal function mountFunctionVirtualNode(virtualNode)\n\t\tlocal element = virtualNode.currentElement\n\n\t\tlocal children = element.component(element.props)\n\n\t\tupdateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)\n\tend\n\n\tlocal function mountPortalVirtualNode(virtualNode)\n\t\tlocal element = virtualNode.currentElement\n\n\t\tlocal targetHostParent = element.props.target\n\t\tlocal children = element.props[Children]\n\n\t\tassert(renderer.isHostObject(targetHostParent), \"Expected target to be host object\")\n\n\t\tupdateVirtualNodeWithChildren(virtualNode, targetHostParent, children)\n\tend\n\n\tlocal function mountFragmentVirtualNode(virtualNode)\n\t\tlocal element = virtualNode.currentElement\n\t\tlocal children = element.elements\n\n\t\tupdateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, children)\n\tend\n\n\t--[[\n\t\tConstructs a new virtual node and mounts it, but does not place it into\n\t\tthe tree.\n\t]]\n\tfunction mountVirtualNode(element, hostParent, hostKey, context, legacyContext)\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(\n\t\t\t\trenderer.isHostObject(hostParent) or hostParent == nil,\n\t\t\t\t\"Expected arg #2 to be a host object\"\n\t\t\t)\n\t\t\tinternalAssert(\n\t\t\t\ttypeof(legacyContext) == \"table\" or legacyContext == nil,\n\t\t\t\t\"Expected arg #5 to be of type table or nil\"\n\t\t\t)\n\t\tend\n\t\tif config.typeChecks then\n\t\t\tassert(hostKey ~= nil, \"Expected arg #3 to be non-nil\")\n\t\t\tassert(\n\t\t\t\tType.of(element) == Type.Element or typeof(element) == \"boolean\",\n\t\t\t\t\"Expected arg #1 to be of type Element or boolean\"\n\t\t\t)\n\t\tend\n\n\t\t-- Boolean values render as nil to enable terse conditional rendering.\n\t\tif typeof(element) == \"boolean\" then\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal kind = ElementKind.of(element)\n\n\t\tlocal virtualNode = createVirtualNode(element, hostParent, hostKey, context, legacyContext)\n\n\t\tif kind == ElementKind.Host then\n\t\t\trenderer.mountHostNode(reconciler, virtualNode)\n\t\telseif kind == ElementKind.Function then\n\t\t\tmountFunctionVirtualNode(virtualNode)\n\t\telseif kind == ElementKind.Stateful then\n\t\t\telement.component:__mount(reconciler, virtualNode)\n\t\telseif kind == ElementKind.Portal then\n\t\t\tmountPortalVirtualNode(virtualNode)\n\t\telseif kind == ElementKind.Fragment then\n\t\t\tmountFragmentVirtualNode(virtualNode)\n\t\telse\n\t\t\terror((\"Unknown ElementKind %q\"):format(tostring(kind)), 2)\n\t\tend\n\n\t\treturn virtualNode\n\tend\n\n\t--[[\n\t\tConstructs a new Roact virtual tree, constructs a root node for\n\t\tit, and mounts it.\n\t]]\n\tlocal function mountVirtualTree(element, hostParent, hostKey)\n\t\tif config.typeChecks then\n\t\t\tassert(Type.of(element) == Type.Element, \"Expected arg #1 to be of type Element\")\n\t\t\tassert(renderer.isHostObject(hostParent) or hostParent == nil, \"Expected arg #2 to be a host object\")\n\t\tend\n\n\t\tif hostKey == nil then\n\t\t\thostKey = \"RoactTree\"\n\t\tend\n\n\t\tlocal tree = {\n\t\t\t[Type] = Type.VirtualTree,\n\t\t\t[InternalData] = {\n\t\t\t\t-- The root node of the tree, which starts into the hierarchy of\n\t\t\t\t-- Roact component instances.\n\t\t\t\trootNode = nil,\n\t\t\t\tmounted = true,\n\t\t\t},\n\t\t}\n\n\t\ttree[InternalData].rootNode = mountVirtualNode(element, hostParent, hostKey)\n\n\t\treturn tree\n\tend\n\n\t--[[\n\t\tUnmounts the virtual tree, freeing all of its resources.\n\n\t\tNo further operations should be done on the tree after it's been\n\t\tunmounted, as indicated by its the `mounted` field.\n\t]]\n\tlocal function unmountVirtualTree(tree)\n\t\tlocal internalData = tree[InternalData]\n\t\tif config.typeChecks then\n\t\t\tassert(Type.of(tree) == Type.VirtualTree, \"Expected arg #1 to be a Roact handle\")\n\t\t\tassert(internalData.mounted, \"Cannot unmounted a Roact tree that has already been unmounted\")\n\t\tend\n\n\t\tinternalData.mounted = false\n\n\t\tif internalData.rootNode ~= nil then\n\t\t\tunmountVirtualNode(internalData.rootNode)\n\t\tend\n\tend\n\n\t--[[\n\t\tUtility method for updating the root node of a virtual tree given a new\n\t\telement.\n\t]]\n\tlocal function updateVirtualTree(tree, newElement)\n\t\tlocal internalData = tree[InternalData]\n\t\tif config.typeChecks then\n\t\t\tassert(Type.of(tree) == Type.VirtualTree, \"Expected arg #1 to be a Roact handle\")\n\t\t\tassert(Type.of(newElement) == Type.Element, \"Expected arg #2 to be a Roact Element\")\n\t\tend\n\n\t\tinternalData.rootNode = updateVirtualNode(internalData.rootNode, newElement)\n\n\t\treturn tree\n\tend\n\n\treconciler = {\n\t\tmountVirtualTree = mountVirtualTree,\n\t\tunmountVirtualTree = unmountVirtualTree,\n\t\tupdateVirtualTree = updateVirtualTree,\n\n\t\tcreateVirtualNode = createVirtualNode,\n\t\tmountVirtualNode = mountVirtualNode,\n\t\tunmountVirtualNode = unmountVirtualNode,\n\t\tupdateVirtualNode = updateVirtualNode,\n\t\tupdateVirtualNodeWithChildren = updateVirtualNodeWithChildren,\n\t\tupdateVirtualNodeWithRenderResult = updateVirtualNodeWithRenderResult,\n\t}\n\n\treturn reconciler\nend\n\nreturn createReconciler\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createFragment.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal ElementKind = require(script.Parent.ElementKind)\n\tlocal Type = require(script.Parent.Type)\n\n\tlocal createFragment = require(script.Parent.createFragment)\n\n\tit(\"should create new primitive elements\", function()\n\t\tlocal fragment = createFragment({})\n\n\t\texpect(fragment).to.be.ok()\n\t\texpect(Type.of(fragment)).to.equal(Type.Element)\n\t\texpect(ElementKind.of(fragment)).to.equal(ElementKind.Fragment)\n\tend)\n\n\tit(\"should accept children\", function()\n\t\tlocal subFragment = createFragment({})\n\t\tlocal fragment = createFragment({ key = subFragment })\n\n\t\texpect(fragment.elements.key).to.equal(subFragment)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createFragment",
                        "ClassName": "ModuleScript",
                        "Source": "local ElementKind = require(script.Parent.ElementKind)\nlocal Type = require(script.Parent.Type)\n\nlocal function createFragment(elements)\n\treturn {\n\t\t[Type] = Type.Element,\n\t\t[ElementKind] = ElementKind.Fragment,\n\t\telements = elements,\n\t}\nend\n\nreturn createFragment\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createElement.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal Component = require(script.Parent.Component)\n\tlocal ElementKind = require(script.Parent.ElementKind)\n\tlocal GlobalConfig = require(script.Parent.GlobalConfig)\n\tlocal Logging = require(script.Parent.Logging)\n\tlocal Type = require(script.Parent.Type)\n\tlocal Portal = require(script.Parent.Portal)\n\tlocal Children = require(script.Parent.PropMarkers.Children)\n\n\tlocal createElement = require(script.Parent.createElement)\n\n\tit(\"should create new primitive elements\", function()\n\t\tlocal element = createElement(\"Frame\")\n\n\t\texpect(element).to.be.ok()\n\t\texpect(Type.of(element)).to.equal(Type.Element)\n\t\texpect(ElementKind.of(element)).to.equal(ElementKind.Host)\n\tend)\n\n\tit(\"should create new functional elements\", function()\n\t\tlocal element = createElement(function() end)\n\n\t\texpect(element).to.be.ok()\n\t\texpect(Type.of(element)).to.equal(Type.Element)\n\t\texpect(ElementKind.of(element)).to.equal(ElementKind.Function)\n\tend)\n\n\tit(\"should create new stateful components\", function()\n\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\tlocal element = createElement(Foo)\n\n\t\texpect(element).to.be.ok()\n\t\texpect(Type.of(element)).to.equal(Type.Element)\n\t\texpect(ElementKind.of(element)).to.equal(ElementKind.Stateful)\n\tend)\n\n\tit(\"should create new portal elements\", function()\n\t\tlocal element = createElement(Portal)\n\n\t\texpect(element).to.be.ok()\n\t\texpect(Type.of(element)).to.equal(Type.Element)\n\t\texpect(ElementKind.of(element)).to.equal(ElementKind.Portal)\n\tend)\n\n\tit(\"should accept props\", function()\n\t\tlocal element = createElement(\"StringValue\", {\n\t\t\tValue = \"Foo\",\n\t\t})\n\n\t\texpect(element).to.be.ok()\n\t\texpect(element.props.Value).to.equal(\"Foo\")\n\tend)\n\n\tit(\"should accept props and children\", function()\n\t\tlocal child = createElement(\"IntValue\")\n\n\t\tlocal element = createElement(\"StringValue\", {\n\t\t\tValue = \"Foo\",\n\t\t}, {\n\t\t\tChild = child,\n\t\t})\n\n\t\texpect(element).to.be.ok()\n\t\texpect(element.props.Value).to.equal(\"Foo\")\n\t\texpect(element.props[Children]).to.be.ok()\n\t\texpect(element.props[Children].Child).to.equal(child)\n\tend)\n\n\tit(\"should accept children with without props\", function()\n\t\tlocal child = createElement(\"IntValue\")\n\n\t\tlocal element = createElement(\"StringValue\", nil, {\n\t\t\tChild = child,\n\t\t})\n\n\t\texpect(element).to.be.ok()\n\t\texpect(element.props[Children]).to.be.ok()\n\t\texpect(element.props[Children].Child).to.equal(child)\n\tend)\n\n\tit(\"should warn once if children is specified in two different ways\", function()\n\t\tlocal logInfo = Logging.capture(function()\n\t\t\t-- Using a loop here to ensure that multiple occurences of the same\n\t\t\t-- warning only cause output once.\n\t\t\tfor _ = 1, 2 do\n\t\t\t\tcreateElement(\"Frame\", {\n\t\t\t\t\t[Children] = {},\n\t\t\t\t}, {})\n\t\t\tend\n\t\tend)\n\n\t\texpect(#logInfo.warnings).to.equal(1)\n\t\texpect(logInfo.warnings[1]:find(\"createElement\")).to.be.ok()\n\t\texpect(logInfo.warnings[1]:find(\"Children\")).to.be.ok()\n\tend)\n\n\tit(\"should have a `source` member if elementTracing is set\", function()\n\t\tlocal config = {\n\t\t\telementTracing = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal element = createElement(\"StringValue\")\n\n\t\t\texpect(element.source).to.be.a(\"string\")\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createElement",
                        "ClassName": "ModuleScript",
                        "Source": "local Children = require(script.Parent.PropMarkers.Children)\nlocal ElementKind = require(script.Parent.ElementKind)\nlocal Logging = require(script.Parent.Logging)\nlocal Type = require(script.Parent.Type)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal multipleChildrenMessage = [[\nThe prop `Roact.Children` was defined but was overriden by the third parameter to createElement!\nThis can happen when a component passes props through to a child element but also uses the `children` argument:\n\n\tRoact.createElement(\"Frame\", passedProps, {\n\t\tchild = ...\n\t})\n\nInstead, consider using a utility function to merge tables of children together:\n\n\tlocal children = mergeTables(passedProps[Roact.Children], {\n\t\tchild = ...\n\t})\n\n\tlocal fullProps = mergeTables(passedProps, {\n\t\t[Roact.Children] = children\n\t})\n\n\tRoact.createElement(\"Frame\", fullProps)]]\n\n--[[\n\tCreates a new element representing the given component.\n\n\tElements are lightweight representations of what a component instance should\n\tlook like.\n\n\tChildren is a shorthand for specifying `Roact.Children` as a key inside\n\tprops. If specified, the passed `props` table is mutated!\n]]\nlocal function createElement(component, props, children)\n\tif config.typeChecks then\n\t\tassert(component ~= nil, \"`component` is required\")\n\t\tassert(typeof(props) == \"table\" or props == nil, \"`props` must be a table or nil\")\n\t\tassert(typeof(children) == \"table\" or children == nil, \"`children` must be a table or nil\")\n\tend\n\n\tif props == nil then\n\t\tprops = {}\n\tend\n\n\tif children ~= nil then\n\t\tif props[Children] ~= nil then\n\t\t\tLogging.warnOnce(multipleChildrenMessage)\n\t\tend\n\n\t\tprops[Children] = children\n\tend\n\n\tlocal elementKind = ElementKind.fromComponent(component)\n\n\tlocal element = {\n\t\t[Type] = Type.Element,\n\t\t[ElementKind] = elementKind,\n\t\tcomponent = component,\n\t\tprops = props,\n\t}\n\n\tif config.elementTracing then\n\t\t-- We trim out the leading newline since there's no way to specify the\n\t\t-- trace level without also specifying a message.\n\t\telement.source = debug.traceback(\"\", 2):sub(2)\n\tend\n\n\treturn element\nend\n\nreturn createElement\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createContext.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n\tlocal Component = require(script.Parent.Component)\n\tlocal NoopRenderer = require(script.Parent.NoopRenderer)\n\tlocal Children = require(script.Parent.PropMarkers.Children)\n\tlocal createContext = require(script.Parent.createContext)\n\tlocal createElement = require(script.Parent.createElement)\n\tlocal createFragment = require(script.Parent.createFragment)\n\tlocal createReconciler = require(script.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.createSpy)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tlocal RobloxRenderer = require(script.Parent.RobloxRenderer)\n\tlocal robloxReconciler = createReconciler(RobloxRenderer)\n\n\tit(\"should return a table\", function()\n\t\tlocal context = createContext(\"Test\")\n\t\texpect(context).to.be.ok()\n\t\texpect(type(context)).to.equal(\"table\")\n\tend)\n\n\tit(\"should contain a Provider and a Consumer\", function()\n\t\tlocal context = createContext(\"Test\")\n\t\texpect(context.Provider).to.be.ok()\n\t\texpect(context.Consumer).to.be.ok()\n\tend)\n\n\tdescribe(\"Provider\", function()\n\t\tit(\"should render its children\", function()\n\t\t\tlocal context = createContext(\"Test\")\n\n\t\t\tlocal Listener = createSpy(function()\n\t\t\t\treturn nil\n\t\t\tend)\n\n\t\t\tlocal element = createElement(context.Provider, {\n\t\t\t\tvalue = \"Test\",\n\t\t\t}, {\n\t\t\t\tListener = createElement(Listener.value),\n\t\t\t})\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(element, nil, \"Provide Tree\")\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\n\t\t\texpect(Listener.callCount).to.equal(1)\n\t\tend)\n\tend)\n\n\tdescribe(\"Consumer\", function()\n\t\tit(\"should expect a render function\", function()\n\t\t\tlocal context = createContext(\"Test\")\n\t\t\tlocal element = createElement(context.Consumer)\n\n\t\t\texpect(function()\n\t\t\t\tnoopReconciler.mountVirtualTree(element, nil, \"Provide Tree\")\n\t\t\tend).to.throw()\n\t\tend)\n\n\t\tit(\"should return the default value if there is no Provider\", function()\n\t\t\tlocal valueSpy = createSpy()\n\t\t\tlocal context = createContext(\"Test\")\n\n\t\t\tlocal element = createElement(context.Consumer, {\n\t\t\t\trender = valueSpy.value,\n\t\t\t})\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(element, nil, \"Provide Tree\")\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\n\t\t\tvalueSpy:assertCalledWith(\"Test\")\n\t\tend)\n\n\t\tit(\"should pass the value to the render function\", function()\n\t\t\tlocal valueSpy = createSpy()\n\t\t\tlocal context = createContext(\"Test\")\n\n\t\t\tlocal function Listener()\n\t\t\t\treturn createElement(context.Consumer, {\n\t\t\t\t\trender = valueSpy.value,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(context.Provider, {\n\t\t\t\tvalue = \"NewTest\",\n\t\t\t}, {\n\t\t\t\tListener = createElement(Listener),\n\t\t\t})\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(element, nil, \"Provide Tree\")\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\n\t\t\tvalueSpy:assertCalledWith(\"NewTest\")\n\t\tend)\n\n\t\tit(\"should update when the value updates\", function()\n\t\t\tlocal valueSpy = createSpy()\n\t\t\tlocal context = createContext(\"Test\")\n\n\t\t\tlocal function Listener()\n\t\t\t\treturn createElement(context.Consumer, {\n\t\t\t\t\trender = valueSpy.value,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(context.Provider, {\n\t\t\t\tvalue = \"NewTest\",\n\t\t\t}, {\n\t\t\t\tListener = createElement(Listener),\n\t\t\t})\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(element, nil, \"Provide Tree\")\n\n\t\t\texpect(valueSpy.callCount).to.equal(1)\n\t\t\tvalueSpy:assertCalledWith(\"NewTest\")\n\n\t\t\tnoopReconciler.updateVirtualTree(\n\t\t\t\ttree,\n\t\t\t\tcreateElement(context.Provider, {\n\t\t\t\t\tvalue = \"ThirdTest\",\n\t\t\t\t}, {\n\t\t\t\t\tListener = createElement(Listener),\n\t\t\t\t})\n\t\t\t)\n\n\t\t\texpect(valueSpy.callCount).to.equal(2)\n\t\t\tvalueSpy:assertCalledWith(\"ThirdTest\")\n\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\t\tend)\n\n\t\t--[[\n\t\t\tThis test is the same as the one above, but with a component that\n\t\t\talways blocks updates in the middle. We expect behavior to be the\n\t\t\tsame.\n\t\t]]\n\t\tit(\"should update when the value updates through an update blocking component\", function()\n\t\t\tlocal valueSpy = createSpy()\n\t\t\tlocal context = createContext(\"Test\")\n\n\t\t\tlocal UpdateBlocker = Component:extend(\"UpdateBlocker\")\n\n\t\t\tfunction UpdateBlocker:render()\n\t\t\t\treturn createFragment(self.props[Children])\n\t\t\tend\n\n\t\t\tfunction UpdateBlocker:shouldUpdate()\n\t\t\t\treturn false\n\t\t\tend\n\n\t\t\tlocal function Listener()\n\t\t\t\treturn createElement(context.Consumer, {\n\t\t\t\t\trender = valueSpy.value,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(context.Provider, {\n\t\t\t\tvalue = \"NewTest\",\n\t\t\t}, {\n\t\t\t\tBlocker = createElement(UpdateBlocker, nil, {\n\t\t\t\t\tListener = createElement(Listener),\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(element, nil, \"Provide Tree\")\n\n\t\t\texpect(valueSpy.callCount).to.equal(1)\n\t\t\tvalueSpy:assertCalledWith(\"NewTest\")\n\n\t\t\tnoopReconciler.updateVirtualTree(\n\t\t\t\ttree,\n\t\t\t\tcreateElement(context.Provider, {\n\t\t\t\t\tvalue = \"ThirdTest\",\n\t\t\t\t}, {\n\t\t\t\t\tBlocker = createElement(UpdateBlocker, nil, {\n\t\t\t\t\t\tListener = createElement(Listener),\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\t)\n\n\t\t\texpect(valueSpy.callCount).to.equal(2)\n\t\t\tvalueSpy:assertCalledWith(\"ThirdTest\")\n\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\t\tend)\n\n\t\tit(\"should behave correctly when the default value is nil\", function()\n\t\t\tlocal context = createContext(nil)\n\n\t\t\tlocal valueSpy = createSpy()\n\t\t\tlocal function Listener()\n\t\t\t\treturn createElement(context.Consumer, {\n\t\t\t\t\trender = valueSpy.value,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(createElement(Listener), nil, \"Provide Tree\")\n\t\t\texpect(valueSpy.callCount).to.equal(1)\n\t\t\tvalueSpy:assertCalledWith(nil)\n\n\t\t\ttree = noopReconciler.updateVirtualTree(tree, createElement(Listener))\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\n\t\t\texpect(valueSpy.callCount).to.equal(2)\n\t\t\tvalueSpy:assertCalledWith(nil)\n\t\tend)\n\tend)\n\n\tdescribe(\"Update order\", function()\n\t\t--[[\n\t\t\tThis test ensures that there is no scenario where we can observe\n\t\t\t'update tearing' when props and context are updated at the same\n\t\t\ttime.\n\n\t\t\tUpdate tearing is scenario where a single update is partially\n\t\t\tapplied in multiple steps instead of atomically. This is observable\n\t\t\tby components and can lead to strange bugs or errors.\n\n\t\t\tThis instance of update tearing happens when updating a prop and a\n\t\t\tcontext value in the same update. Image we represent our tree's\n\t\t\tstate as the current prop and context versions. Our initial state\n\t\t\tis:\n\n\t\t\t(prop_1, context_1)\n\n\t\t\tThe next state we would like to update to is:\n\n\t\t\t(prop_2, context_2)\n\n\t\t\tUnder the bug reported in issue 259, Roact reaches three different\n\t\t\tstates in sequence:\n\n\t\t\t1: (prop_1, context_1) - the initial state\n\t\t\t2: (prop_2, context_1) - woops!\n\t\t\t3: (prop_2, context_2) - correct end state\n\n\t\t\tIn state 2, a user component was added that tried to access the\n\t\t\tcurrent context value, which was not set at the time. This raised an\n\t\t\terror, because this state is not valid!\n\n\t\t\tThe first proposed solution was to move the context update to happen\n\t\t\tbefore the props update. It is easy to show that this will still\n\t\t\tresult in update tearing:\n\n\t\t\t1: (prop_1, context_1)\n\t\t\t2: (prop_1, context_2)\n\t\t\t3: (prop_2, context_2)\n\n\t\t\tAlthough the initial concern about newly added components observing\n\t\t\told context values is fixed, there is still a state\n\t\t\tdesynchronization between props and state.\n\n\t\t\tWe would instead like the following update sequence:\n\n\t\t\t1: (prop_1, context_1)\n\t\t\t2: (prop_2, context_2)\n\n\t\t\tThis test tries to ensure that is the case.\n\n\t\t\tThe initial bug report is here:\n\t\t\thttps://github.com/Roblox/roact/issues/259\n\t\t]]\n\t\tit(\"should update context at the same time as props\", function()\n\t\t\t-- These values are used to make sure we reach both the first and\n\t\t\t-- second state combinations we want to visit.\n\t\t\tlocal observedA = false\n\t\t\tlocal observedB = false\n\t\t\tlocal updateCount = 0\n\n\t\t\tlocal context = createContext(\"default\")\n\n\t\t\tlocal function Listener(props)\n\t\t\t\treturn createElement(context.Consumer, {\n\t\t\t\t\trender = function(value)\n\t\t\t\t\t\tupdateCount = updateCount + 1\n\n\t\t\t\t\t\tif value == \"context_1\" then\n\t\t\t\t\t\t\texpect(props.someProp).to.equal(\"prop_1\")\n\t\t\t\t\t\t\tobservedA = true\n\t\t\t\t\t\telseif value == \"context_2\" then\n\t\t\t\t\t\t\texpect(props.someProp).to.equal(\"prop_2\")\n\t\t\t\t\t\t\tobservedB = true\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\terror(\"Unexpected context value\")\n\t\t\t\t\t\tend\n\t\t\t\t\tend,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element1 = createElement(context.Provider, {\n\t\t\t\tvalue = \"context_1\",\n\t\t\t}, {\n\t\t\t\tChild = createElement(Listener, {\n\t\t\t\t\tsomeProp = \"prop_1\",\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal element2 = createElement(context.Provider, {\n\t\t\t\tvalue = \"context_2\",\n\t\t\t}, {\n\t\t\t\tChild = createElement(Listener, {\n\t\t\t\t\tsomeProp = \"prop_2\",\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(element1, nil, \"UpdateObservationIsFun\")\n\t\t\tnoopReconciler.updateVirtualTree(tree, element2)\n\n\t\t\texpect(updateCount).to.equal(2)\n\t\t\texpect(observedA).to.equal(true)\n\t\t\texpect(observedB).to.equal(true)\n\t\tend)\n\tend)\n\n\t-- issue https://github.com/Roblox/roact/issues/319\n\tit(\"does not throw if willUnmount is called twice on a context consumer\", function()\n\t\tlocal context = createContext({})\n\n\t\tlocal LowestComponent = Component:extend(\"LowestComponent\")\n\t\tfunction LowestComponent:init() end\n\n\t\tfunction LowestComponent:render()\n\t\t\treturn createElement(\"Frame\")\n\t\tend\n\n\t\tfunction LowestComponent:didMount()\n\t\t\tself.props.onDidMountCallback()\n\t\tend\n\n\t\tlocal FirstComponent = Component:extend(\"FirstComponent\")\n\t\tfunction FirstComponent:init() end\n\n\t\tfunction FirstComponent:render()\n\t\t\treturn createElement(context.Consumer, {\n\t\t\t\trender = function()\n\t\t\t\t\treturn createElement(\"TextLabel\")\n\t\t\t\tend,\n\t\t\t})\n\t\tend\n\n\t\tlocal ChildComponent = Component:extend(\"ChildComponent\")\n\n\t\tfunction ChildComponent:init()\n\t\t\tself:setState({ firstTime = true })\n\t\tend\n\n\t\tlocal childCallback\n\n\t\tfunction ChildComponent:render()\n\t\t\tif self.state.firstTime then\n\t\t\t\treturn createElement(FirstComponent)\n\t\t\tend\n\n\t\t\treturn createElement(LowestComponent, {\n\t\t\t\tonDidMountCallback = self.props.onDidMountCallback,\n\t\t\t})\n\t\tend\n\n\t\tfunction ChildComponent:didMount()\n\t\t\tchildCallback = function()\n\t\t\t\tself:setState({ firstTime = false })\n\t\t\tend\n\t\tend\n\n\t\tlocal ParentComponent = Component:extend(\"ParentComponent\")\n\n\t\tlocal didMountCallbackCalled = 0\n\n\t\tfunction ParentComponent:init()\n\t\t\tself:setState({ count = 1 })\n\n\t\t\tself.onDidMountCallback = function()\n\t\t\t\tdidMountCallbackCalled = didMountCallbackCalled + 1\n\t\t\t\tif self.state.count < 5 then\n\t\t\t\t\tself:setState({ count = self.state.count + 1 })\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tfunction ParentComponent:render()\n\t\t\treturn createElement(\"Frame\", {}, {\n\t\t\t\tProvider = createElement(context.Provider, {\n\t\t\t\t\tvalue = {},\n\t\t\t\t}, {\n\t\t\t\t\tChildComponent = createElement(ChildComponent, {\n\t\t\t\t\t\tcount = self.state.count,\n\t\t\t\t\t\tonDidMountCallback = self.onDidMountCallback,\n\t\t\t\t\t}),\n\t\t\t\t}),\n\t\t\t})\n\t\tend\n\n\t\tlocal parent = Instance.new(\"ScreenGui\")\n\t\tparent.Parent = ReplicatedStorage\n\n\t\tlocal hostKey = \"Some Key\"\n\t\trobloxReconciler.mountVirtualNode(createElement(ParentComponent), parent, hostKey)\n\n\t\texpect(function()\n\t\t\t-- calling setState on ChildComponent will trigger `willUnmount` multiple times\n\t\t\tchildCallback()\n\t\tend).never.to.throw()\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createContext",
                        "ClassName": "ModuleScript",
                        "Source": "local Symbol = require(script.Parent.Symbol)\nlocal createFragment = require(script.Parent.createFragment)\nlocal createSignal = require(script.Parent.createSignal)\nlocal Children = require(script.Parent.PropMarkers.Children)\nlocal Component = require(script.Parent.Component)\n\n--[[\n\tConstruct the value that is assigned to Roact's context storage.\n]]\nlocal function createContextEntry(currentValue)\n\treturn {\n\t\tvalue = currentValue,\n\t\tonUpdate = createSignal(),\n\t}\nend\n\nlocal function createProvider(context)\n\tlocal Provider = Component:extend(\"Provider\")\n\n\tfunction Provider:init(props)\n\t\tself.contextEntry = createContextEntry(props.value)\n\t\tself:__addContext(context.key, self.contextEntry)\n\tend\n\n\tfunction Provider:willUpdate(nextProps)\n\t\t-- If the provided value changed, immediately update the context entry.\n\t\t--\n\t\t-- During this update, any components that are reachable will receive\n\t\t-- this updated value at the same time as any props and state updates\n\t\t-- that are being applied.\n\t\tif nextProps.value ~= self.props.value then\n\t\t\tself.contextEntry.value = nextProps.value\n\t\tend\n\tend\n\n\tfunction Provider:didUpdate(prevProps)\n\t\t-- If the provided value changed, after we've updated every reachable\n\t\t-- component, fire a signal to update the rest.\n\t\t--\n\t\t-- This signal will notify all context consumers. It's expected that\n\t\t-- they will compare the last context value they updated with and only\n\t\t-- trigger an update on themselves if this value is different.\n\t\t--\n\t\t-- This codepath will generally only update consumer components that has\n\t\t-- a component implementing shouldUpdate between them and the provider.\n\t\tif prevProps.value ~= self.props.value then\n\t\t\tself.contextEntry.onUpdate:fire(self.props.value)\n\t\tend\n\tend\n\n\tfunction Provider:render()\n\t\treturn createFragment(self.props[Children])\n\tend\n\n\treturn Provider\nend\n\nlocal function createConsumer(context)\n\tlocal Consumer = Component:extend(\"Consumer\")\n\n\tfunction Consumer.validateProps(props)\n\t\tif type(props.render) ~= \"function\" then\n\t\t\treturn false, \"Consumer expects a `render` function\"\n\t\telse\n\t\t\treturn true\n\t\tend\n\tend\n\n\tfunction Consumer:init(_props)\n\t\t-- This value may be nil, which indicates that our consumer is not a\n\t\t-- descendant of a provider for this context item.\n\t\tself.contextEntry = self:__getContext(context.key)\n\tend\n\n\tfunction Consumer:render()\n\t\t-- Render using the latest available for this context item.\n\t\t--\n\t\t-- We don't store this value in state in order to have more fine-grained\n\t\t-- control over our update behavior.\n\t\tlocal value\n\t\tif self.contextEntry ~= nil then\n\t\t\tvalue = self.contextEntry.value\n\t\telse\n\t\t\tvalue = context.defaultValue\n\t\tend\n\n\t\treturn self.props.render(value)\n\tend\n\n\tfunction Consumer:didUpdate()\n\t\t-- Store the value that we most recently updated with.\n\t\t--\n\t\t-- This value is compared in the contextEntry onUpdate hook below.\n\t\tif self.contextEntry ~= nil then\n\t\t\tself.lastValue = self.contextEntry.value\n\t\tend\n\tend\n\n\tfunction Consumer:didMount()\n\t\tif self.contextEntry ~= nil then\n\t\t\t-- When onUpdate is fired, a new value has been made available in\n\t\t\t-- this context entry, but we may have already updated in the same\n\t\t\t-- update cycle.\n\t\t\t--\n\t\t\t-- To avoid sending a redundant update, we compare the new value\n\t\t\t-- with the last value that we updated with (set in didUpdate) and\n\t\t\t-- only update if they differ. This may happen when an update from a\n\t\t\t-- provider was blocked by an intermediate component that returned\n\t\t\t-- false from shouldUpdate.\n\t\t\tself.disconnect = self.contextEntry.onUpdate:subscribe(function(newValue)\n\t\t\t\tif newValue ~= self.lastValue then\n\t\t\t\t\t-- Trigger a dummy state update.\n\t\t\t\t\tself:setState({})\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\tend\n\n\tfunction Consumer:willUnmount()\n\t\tif self.disconnect ~= nil then\n\t\t\tself.disconnect()\n\t\t\tself.disconnect = nil\n\t\tend\n\tend\n\n\treturn Consumer\nend\n\nlocal Context = {}\nContext.__index = Context\n\nfunction Context.new(defaultValue)\n\treturn setmetatable({\n\t\tdefaultValue = defaultValue,\n\t\tkey = Symbol.named(\"ContextKey\"),\n\t}, Context)\nend\n\nfunction Context:__tostring()\n\treturn \"RoactContext\"\nend\n\nlocal function createContext(defaultValue)\n\tlocal context = Context.new(defaultValue)\n\n\treturn {\n\t\tProvider = createProvider(context),\n\t\tConsumer = createConsumer(context),\n\t}\nend\n\nreturn createContext\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "assign.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal None = require(script.Parent.None)\n\n\tlocal assign = require(script.Parent.assign)\n\n\tit(\"should accept zero additional tables\", function()\n\t\tlocal input = {}\n\t\tlocal result = assign(input)\n\n\t\texpect(input).to.equal(result)\n\tend)\n\n\tit(\"should merge multiple tables onto the given target table\", function()\n\t\tlocal target = {\n\t\t\ta = 5,\n\t\t\tb = 6,\n\t\t}\n\n\t\tlocal source1 = {\n\t\t\tb = 7,\n\t\t\tc = 8,\n\t\t}\n\n\t\tlocal source2 = {\n\t\t\tb = 8,\n\t\t}\n\n\t\tassign(target, source1, source2)\n\n\t\texpect(target.a).to.equal(5)\n\t\texpect(target.b).to.equal(source2.b)\n\t\texpect(target.c).to.equal(source1.c)\n\tend)\n\n\tit(\"should remove keys if specified as None\", function()\n\t\tlocal target = {\n\t\t\tfoo = 2,\n\t\t\tbar = 3,\n\t\t}\n\n\t\tlocal source = {\n\t\t\tfoo = None,\n\t\t}\n\n\t\tassign(target, source)\n\n\t\texpect(target.foo).to.equal(nil)\n\t\texpect(target.bar).to.equal(3)\n\tend)\n\n\tit(\"should re-add keys if specified after None\", function()\n\t\tlocal target = {\n\t\t\tfoo = 2,\n\t\t}\n\n\t\tlocal source1 = {\n\t\t\tfoo = None,\n\t\t}\n\n\t\tlocal source2 = {\n\t\t\tfoo = 3,\n\t\t}\n\n\t\tassign(target, source1, source2)\n\n\t\texpect(target.foo).to.equal(source2.foo)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "assign",
                        "ClassName": "ModuleScript",
                        "Source": "local None = require(script.Parent.None)\n\n--[[\n\tMerges values from zero or more tables onto a target table. If a value is\n\tset to None, it will instead be removed from the table.\n\n\tThis function is identical in functionality to JavaScript's Object.assign.\n]]\nlocal function assign(target, ...)\n\tfor index = 1, select(\"#\", ...) do\n\t\tlocal source = select(index, ...)\n\n\t\tif source ~= nil then\n\t\t\tfor key, value in pairs(source) do\n\t\t\t\tif value == None then\n\t\t\t\t\ttarget[key] = nil\n\t\t\t\telse\n\t\t\t\t\ttarget[key] = value\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\treturn target\nend\n\nreturn assign\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "assertDeepEqual.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.assertDeepEqual)\n\n\tit(\"should fail with a message when args are not equal\", function()\n\t\tlocal success, message = pcall(assertDeepEqual, 1, 2)\n\n\t\texpect(success).to.equal(false)\n\t\texpect(message:find(\"first ~= second\")).to.be.ok()\n\n\t\tsuccess, message = pcall(assertDeepEqual, {\n\t\t\tfoo = 1,\n\t\t}, {\n\t\t\tfoo = 2,\n\t\t})\n\n\t\texpect(success).to.equal(false)\n\t\texpect(message:find(\"first%[foo%] ~= second%[foo%]\")).to.be.ok()\n\tend)\n\n\tit(\"should compare non-table values using standard '==' equality\", function()\n\t\tassertDeepEqual(1, 1)\n\t\tassertDeepEqual(\"hello\", \"hello\")\n\t\tassertDeepEqual(nil, nil)\n\n\t\tlocal someFunction = function() end\n\t\tlocal theSameFunction = someFunction\n\n\t\tassertDeepEqual(someFunction, theSameFunction)\n\n\t\tlocal A = {\n\t\t\tfoo = someFunction,\n\t\t}\n\t\tlocal B = {\n\t\t\tfoo = theSameFunction,\n\t\t}\n\n\t\tassertDeepEqual(A, B)\n\tend)\n\n\tit(\"should fail when types differ\", function()\n\t\tlocal success, message = pcall(assertDeepEqual, 1, \"1\")\n\n\t\texpect(success).to.equal(false)\n\t\texpect(message:find(\"first is of type number, but second is of type string\")).to.be.ok()\n\tend)\n\n\tit(\"should compare (and report about) nested tables\", function()\n\t\tlocal A = {\n\t\t\tfoo = \"bar\",\n\t\t\tnested = {\n\t\t\t\tfoo = 1,\n\t\t\t\tbar = 2,\n\t\t\t},\n\t\t}\n\t\tlocal B = {\n\t\t\tfoo = \"bar\",\n\t\t\tnested = {\n\t\t\t\tfoo = 1,\n\t\t\t\tbar = 2,\n\t\t\t},\n\t\t}\n\n\t\tassertDeepEqual(A, B)\n\n\t\tlocal C = {\n\t\t\tfoo = \"bar\",\n\t\t\tnested = {\n\t\t\t\tfoo = 1,\n\t\t\t\tbar = 3,\n\t\t\t},\n\t\t}\n\n\t\tlocal success, message = pcall(assertDeepEqual, A, C)\n\n\t\texpect(success).to.equal(false)\n\t\texpect(message:find(\"first%[nested%]%[bar%] ~= second%[nested%]%[bar%]\")).to.be.ok()\n\tend)\n\n\tit(\"should be commutative\", function()\n\t\tlocal equalArgsA = {\n\t\t\tfoo = \"bar\",\n\t\t\thello = \"world\",\n\t\t}\n\t\tlocal equalArgsB = {\n\t\t\tfoo = \"bar\",\n\t\t\thello = \"world\",\n\t\t}\n\n\t\tassertDeepEqual(equalArgsA, equalArgsB)\n\t\tassertDeepEqual(equalArgsB, equalArgsA)\n\n\t\tlocal nonEqualArgs = {\n\t\t\tfoo = \"bar\",\n\t\t}\n\n\t\texpect(function()\n\t\t\tassertDeepEqual(equalArgsA, nonEqualArgs)\n\t\tend).to.throw()\n\t\texpect(function()\n\t\t\tassertDeepEqual(nonEqualArgs, equalArgsA)\n\t\tend).to.throw()\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "assertDeepEqual",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tA utility used to assert that two objects are value-equal recursively. It\n\toutputs fairly nicely formatted messages to help diagnose why two objects\n\twould be different.\n\n\tThis should only be used in tests.\n]]\n\nlocal function deepEqual(a, b)\n\tif typeof(a) ~= typeof(b) then\n\t\tlocal message = (\"{1} is of type %s, but {2} is of type %s\"):format(typeof(a), typeof(b))\n\t\treturn false, message\n\tend\n\n\tif typeof(a) == \"table\" then\n\t\tlocal visitedKeys = {}\n\n\t\tfor key, value in pairs(a) do\n\t\t\tvisitedKeys[key] = true\n\n\t\t\tlocal success, innerMessage = deepEqual(value, b[key])\n\t\t\tif not success then\n\t\t\t\tlocal message = innerMessage\n\t\t\t\t\t:gsub(\"{1}\", (\"{1}[%s]\"):format(tostring(key)))\n\t\t\t\t\t:gsub(\"{2}\", (\"{2}[%s]\"):format(tostring(key)))\n\n\t\t\t\treturn false, message\n\t\t\tend\n\t\tend\n\n\t\tfor key, value in pairs(b) do\n\t\t\tif not visitedKeys[key] then\n\t\t\t\tlocal success, innerMessage = deepEqual(value, a[key])\n\n\t\t\t\tif not success then\n\t\t\t\t\tlocal message = innerMessage\n\t\t\t\t\t\t:gsub(\"{1}\", (\"{1}[%s]\"):format(tostring(key)))\n\t\t\t\t\t\t:gsub(\"{2}\", (\"{2}[%s]\"):format(tostring(key)))\n\n\t\t\t\t\treturn false, message\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\treturn true\n\tend\n\n\tif a == b then\n\t\treturn true\n\tend\n\n\tlocal message = \"{1} ~= {2}\"\n\treturn false, message\nend\n\nlocal function assertDeepEqual(a, b)\n\tlocal success, innerMessageTemplate = deepEqual(a, b)\n\n\tif not success then\n\t\tlocal innerMessage = innerMessageTemplate:gsub(\"{1}\", \"first\"):gsub(\"{2}\", \"second\")\n\n\t\tlocal message = (\"Values were not deep-equal.\\n%s\"):format(innerMessage)\n\n\t\terror(message, 2)\n\tend\nend\n\nreturn assertDeepEqual\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Type.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal Type = require(script.Parent.Type)\n\n\tdescribe(\"of\", function()\n\t\tit(\"should return nil if the value is not a table\", function()\n\t\t\texpect(Type.of(1)).to.equal(nil)\n\t\t\texpect(Type.of(true)).to.equal(nil)\n\t\t\texpect(Type.of(\"test\")).to.equal(nil)\n\t\t\texpect(Type.of(print)).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should return nil if the table has no type\", function()\n\t\t\texpect(Type.of({})).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should return the assigned type\", function()\n\t\t\tlocal test = {\n\t\t\t\t[Type] = Type.Element,\n\t\t\t}\n\n\t\t\texpect(Type.of(test)).to.equal(Type.Element)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Type",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tContains markers for annotating objects with types.\n\n\tTo set the type of an object, use `Type` as a key and the actual marker as\n\tthe value:\n\n\t\tlocal foo = {\n\t\t\t[Type] = Type.Foo,\n\t\t}\n]]\n\nlocal Symbol = require(script.Parent.Symbol)\nlocal strict = require(script.Parent.strict)\n\nlocal Type = newproxy(true)\n\nlocal TypeInternal = {}\n\nlocal function addType(name)\n\tTypeInternal[name] = Symbol.named(\"Roact\" .. name)\nend\n\naddType(\"Binding\")\naddType(\"Element\")\naddType(\"HostChangeEvent\")\naddType(\"HostEvent\")\naddType(\"StatefulComponentClass\")\naddType(\"StatefulComponentInstance\")\naddType(\"VirtualNode\")\naddType(\"VirtualTree\")\n\nfunction TypeInternal.of(value)\n\tif typeof(value) ~= \"table\" then\n\t\treturn nil\n\tend\n\n\treturn value[Type]\nend\n\ngetmetatable(Type).__index = TypeInternal\n\ngetmetatable(Type).__tostring = function()\n\treturn \"RoactType\"\nend\n\nstrict(TypeInternal, \"Type\")\n\nreturn Type\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Symbol.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal Symbol = require(script.Parent.Symbol)\n\n\tdescribe(\"named\", function()\n\t\tit(\"should give an opaque object\", function()\n\t\t\tlocal symbol = Symbol.named(\"foo\")\n\n\t\t\texpect(symbol).to.be.a(\"userdata\")\n\t\tend)\n\n\t\tit(\"should coerce to the given name\", function()\n\t\t\tlocal symbol = Symbol.named(\"foo\")\n\n\t\t\texpect(tostring(symbol):find(\"foo\")).to.be.ok()\n\t\tend)\n\n\t\tit(\"should be unique when constructed\", function()\n\t\t\tlocal symbolA = Symbol.named(\"abc\")\n\t\t\tlocal symbolB = Symbol.named(\"abc\")\n\n\t\t\texpect(symbolA).never.to.equal(symbolB)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Symbol",
                        "ClassName": "ModuleScript",
                        "Source": "--!nonstrict\n--[[\n\tA 'Symbol' is an opaque marker type.\n\n\tSymbols have the type 'userdata', but when printed to the console, the name\n\tof the symbol is shown.\n]]\n\nlocal Symbol = {}\n\n--[[\n\tCreates a Symbol with the given name.\n\n\tWhen printed or coerced to a string, the symbol will turn into the string\n\tgiven as its name.\n]]\nfunction Symbol.named(name)\n\tassert(type(name) == \"string\", \"Symbols must be created using a string name!\")\n\n\tlocal self = newproxy(true)\n\n\tlocal wrappedName = (\"Symbol(%s)\"):format(name)\n\n\tgetmetatable(self).__tostring = function()\n\t\treturn wrappedName\n\tend\n\n\treturn self\nend\n\nreturn Symbol\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "SingleEventManager.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.assertDeepEqual)\n\tlocal createSpy = require(script.Parent.createSpy)\n\tlocal Logging = require(script.Parent.Logging)\n\n\tlocal SingleEventManager = require(script.Parent.SingleEventManager)\n\n\tdescribe(\"new\", function()\n\t\tit(\"should create a SingleEventManager\", function()\n\t\t\tlocal manager = SingleEventManager.new()\n\n\t\t\texpect(manager).to.be.ok()\n\t\tend)\n\tend)\n\n\tdescribe(\"connectEvent\", function()\n\t\tit(\"should connect to events\", function()\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\t\t\tlocal eventSpy = createSpy()\n\n\t\t\tmanager:connectEvent(\"Event\", eventSpy.value)\n\t\t\tmanager:resume()\n\n\t\t\tinstance:Fire(\"foo\")\n\t\t\texpect(eventSpy.callCount).to.equal(1)\n\t\t\teventSpy:assertCalledWith(instance, \"foo\")\n\n\t\t\tinstance:Fire(\"bar\")\n\t\t\texpect(eventSpy.callCount).to.equal(2)\n\t\t\teventSpy:assertCalledWith(instance, \"bar\")\n\n\t\t\tmanager:connectEvent(\"Event\", nil)\n\n\t\t\tinstance:Fire(\"baz\")\n\t\t\texpect(eventSpy.callCount).to.equal(2)\n\t\tend)\n\n\t\tit(\"should drop events until resumed initially\", function()\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\t\t\tlocal eventSpy = createSpy()\n\n\t\t\tmanager:connectEvent(\"Event\", eventSpy.value)\n\n\t\t\tinstance:Fire(\"foo\")\n\t\t\texpect(eventSpy.callCount).to.equal(0)\n\n\t\t\tmanager:resume()\n\n\t\t\tinstance:Fire(\"bar\")\n\t\t\texpect(eventSpy.callCount).to.equal(1)\n\t\t\teventSpy:assertCalledWith(instance, \"bar\")\n\t\tend)\n\n\t\tit(\"should invoke suspended events when resumed\", function()\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\t\t\tlocal eventSpy = createSpy()\n\n\t\t\tmanager:connectEvent(\"Event\", eventSpy.value)\n\t\t\tmanager:resume()\n\n\t\t\tinstance:Fire(\"foo\")\n\t\t\texpect(eventSpy.callCount).to.equal(1)\n\t\t\teventSpy:assertCalledWith(instance, \"foo\")\n\n\t\t\tmanager:suspend()\n\n\t\t\tinstance:Fire(\"bar\")\n\t\t\texpect(eventSpy.callCount).to.equal(1)\n\n\t\t\tmanager:resume()\n\t\t\texpect(eventSpy.callCount).to.equal(2)\n\t\t\teventSpy:assertCalledWith(instance, \"bar\")\n\t\tend)\n\n\t\tit(\"should invoke events triggered during resumption in the correct order\", function()\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\n\t\t\tlocal recordedValues = {}\n\t\t\tlocal eventSpy = createSpy(function(_, value)\n\t\t\t\ttable.insert(recordedValues, value)\n\n\t\t\t\tif value == 2 then\n\t\t\t\t\tinstance:Fire(3)\n\t\t\t\telseif value == 3 then\n\t\t\t\t\tinstance:Fire(4)\n\t\t\t\tend\n\t\t\tend)\n\n\t\t\tmanager:connectEvent(\"Event\", eventSpy.value)\n\t\t\tmanager:suspend()\n\n\t\t\tinstance:Fire(1)\n\t\t\tinstance:Fire(2)\n\n\t\t\tmanager:resume()\n\t\t\texpect(eventSpy.callCount).to.equal(4)\n\t\t\tassertDeepEqual(recordedValues, { 1, 2, 3, 4 })\n\t\tend)\n\n\t\tit(\"should not invoke events fired during suspension but disconnected before resumption\", function()\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\t\t\tlocal eventSpy = createSpy()\n\n\t\t\tmanager:connectEvent(\"Event\", eventSpy.value)\n\t\t\tmanager:suspend()\n\n\t\t\tinstance:Fire(1)\n\n\t\t\tmanager:connectEvent(\"Event\", nil)\n\n\t\t\tmanager:resume()\n\t\t\texpect(eventSpy.callCount).to.equal(0)\n\t\tend)\n\n\t\tit(\"should not yield events through the SingleEventManager when resuming\", function()\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\n\t\t\tmanager:connectEvent(\"Event\", function()\n\t\t\t\tcoroutine.yield()\n\t\t\tend)\n\n\t\t\tmanager:resume()\n\n\t\t\tlocal co = coroutine.create(function()\n\t\t\t\tinstance:Fire(5)\n\t\t\tend)\n\n\t\t\tassert(coroutine.resume(co))\n\t\t\texpect(coroutine.status(co)).to.equal(\"dead\")\n\n\t\t\tmanager:suspend()\n\t\t\tinstance:Fire(5)\n\n\t\t\tco = coroutine.create(function()\n\t\t\t\tmanager:resume()\n\t\t\tend)\n\n\t\t\tassert(coroutine.resume(co))\n\t\t\texpect(coroutine.status(co)).to.equal(\"dead\")\n\t\tend)\n\n\t\tit(\"should not throw errors through SingleEventManager when resuming\", function()\n\t\t\tlocal errorText = \"Error from SingleEventManager test\"\n\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\n\t\t\tmanager:connectEvent(\"Event\", function()\n\t\t\t\terror(errorText)\n\t\t\tend)\n\n\t\t\tmanager:resume()\n\n\t\t\t-- If we call instance:Fire() here, the error message will leak to\n\t\t\t-- the console since the thread's resumption will be handled by\n\t\t\t-- Roblox's scheduler.\n\n\t\t\tmanager:suspend()\n\t\t\tinstance:Fire(5)\n\n\t\t\tlocal logInfo = Logging.capture(function()\n\t\t\t\tmanager:resume()\n\t\t\tend)\n\n\t\t\texpect(#logInfo.errors).to.equal(0)\n\t\t\texpect(#logInfo.warnings).to.equal(1)\n\t\t\texpect(#logInfo.infos).to.equal(0)\n\n\t\t\texpect(logInfo.warnings[1]:find(errorText)).to.be.ok()\n\t\tend)\n\n\t\tit(\"should not overflow with events if manager:resume() is invoked when resuming a suspended event\", function()\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\n\t\t\t-- This connection emulates what happens if reconciliation is\n\t\t\t-- triggered again in response to reconciliation. Without\n\t\t\t-- appropriate guards, the inner resume() call will process the\n\t\t\t-- Fire(1) event again, causing a nasty stack overflow.\n\t\t\tlocal eventSpy = createSpy(function(_, value)\n\t\t\t\tif value == 1 then\n\t\t\t\t\tmanager:suspend()\n\t\t\t\t\tinstance:Fire(2)\n\t\t\t\t\tmanager:resume()\n\t\t\t\tend\n\t\t\tend)\n\n\t\t\tmanager:connectEvent(\"Event\", eventSpy.value)\n\n\t\t\tmanager:suspend()\n\t\t\tinstance:Fire(1)\n\t\t\tmanager:resume()\n\n\t\t\texpect(eventSpy.callCount).to.equal(2)\n\t\tend)\n\tend)\n\n\tdescribe(\"connectPropertyChange\", function()\n\t\t-- Since property changes utilize the same mechanisms as other events,\n\t\t-- the tests here are slimmed down to reduce redundancy.\n\n\t\tit(\"should connect to property changes\", function()\n\t\t\tlocal instance = Instance.new(\"Folder\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\t\t\tlocal eventSpy = createSpy()\n\n\t\t\tmanager:connectPropertyChange(\"Name\", eventSpy.value)\n\t\t\tmanager:resume()\n\n\t\t\tinstance.Name = \"foo\"\n\t\t\texpect(eventSpy.callCount).to.equal(1)\n\t\t\teventSpy:assertCalledWith(instance)\n\n\t\t\tinstance.Name = \"bar\"\n\t\t\texpect(eventSpy.callCount).to.equal(2)\n\t\t\teventSpy:assertCalledWith(instance)\n\n\t\t\tmanager:connectPropertyChange(\"Name\")\n\n\t\t\tinstance.Name = \"baz\"\n\t\t\texpect(eventSpy.callCount).to.equal(2)\n\t\tend)\n\n\t\tit(\"should throw an error if the property is invalid\", function()\n\t\t\tlocal instance = Instance.new(\"Folder\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\n\t\t\texpect(function()\n\t\t\t\tmanager:connectPropertyChange(\"foo\", function() end)\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "SingleEventManager",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tA manager for a single host virtual node's connected events.\n]]\n\nlocal Logging = require(script.Parent.Logging)\n\nlocal CHANGE_PREFIX = \"Change.\"\n\nlocal EventStatus = {\n\t-- No events are processed at all; they're silently discarded\n\tDisabled = \"Disabled\",\n\n\t-- Events are stored in a queue; listeners are invoked when the manager is resumed\n\tSuspended = \"Suspended\",\n\n\t-- Event listeners are invoked as the events fire\n\tEnabled = \"Enabled\",\n}\n\nlocal SingleEventManager = {}\nSingleEventManager.__index = SingleEventManager\n\nfunction SingleEventManager.new(instance)\n\tlocal self = setmetatable({\n\t\t-- The queue of suspended events\n\t\t_suspendedEventQueue = {},\n\n\t\t-- All the event connections being managed\n\t\t-- Events are indexed by a string key\n\t\t_connections = {},\n\n\t\t-- All the listeners being managed\n\t\t-- These are stored distinctly from the connections\n\t\t-- Connections can have their listeners replaced at runtime\n\t\t_listeners = {},\n\n\t\t-- The suspension status of the manager\n\t\t-- Managers start disabled and are \"resumed\" after the initial render\n\t\t_status = EventStatus.Disabled,\n\n\t\t-- If true, the manager is processing queued events right now.\n\t\t_isResuming = false,\n\n\t\t-- The Roblox instance the manager is managing\n\t\t_instance = instance,\n\t}, SingleEventManager)\n\n\treturn self\nend\n\nfunction SingleEventManager:connectEvent(key, listener)\n\tself:_connect(key, self._instance[key], listener)\nend\n\nfunction SingleEventManager:connectPropertyChange(key, listener)\n\tlocal success, event = pcall(function()\n\t\treturn self._instance:GetPropertyChangedSignal(key)\n\tend)\n\n\tif not success then\n\t\terror((\"Cannot get changed signal on property %q: %s\"):format(tostring(key), event), 0)\n\tend\n\n\tself:_connect(CHANGE_PREFIX .. key, event, listener)\nend\n\nfunction SingleEventManager:_connect(eventKey, event, listener)\n\t-- If the listener doesn't exist we can just disconnect the existing connection\n\tif listener == nil then\n\t\tif self._connections[eventKey] ~= nil then\n\t\t\tself._connections[eventKey]:Disconnect()\n\t\t\tself._connections[eventKey] = nil\n\t\tend\n\n\t\tself._listeners[eventKey] = nil\n\telse\n\t\tif self._connections[eventKey] == nil then\n\t\t\tself._connections[eventKey] = event:Connect(function(...)\n\t\t\t\tif self._status == EventStatus.Enabled then\n\t\t\t\t\tself._listeners[eventKey](self._instance, ...)\n\t\t\t\telseif self._status == EventStatus.Suspended then\n\t\t\t\t\t-- Store this event invocation to be fired when resume is\n\t\t\t\t\t-- called.\n\n\t\t\t\t\tlocal argumentCount = select(\"#\", ...)\n\t\t\t\t\ttable.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\n\t\tself._listeners[eventKey] = listener\n\tend\nend\n\nfunction SingleEventManager:suspend()\n\tself._status = EventStatus.Suspended\nend\n\nfunction SingleEventManager:resume()\n\t-- If we're already resuming events for this instance, trying to resume\n\t-- again would cause a disaster.\n\tif self._isResuming then\n\t\treturn\n\tend\n\n\tself._isResuming = true\n\n\tlocal index = 1\n\n\t-- More events might be added to the queue when evaluating events, so we\n\t-- need to be careful in order to preserve correct evaluation order.\n\twhile index <= #self._suspendedEventQueue do\n\t\tlocal eventInvocation = self._suspendedEventQueue[index]\n\t\tlocal listener = self._listeners[eventInvocation[1]]\n\t\tlocal argumentCount = eventInvocation[2]\n\n\t\t-- The event might have been disconnected since suspension started; in\n\t\t-- this case, we drop the event.\n\t\tif listener ~= nil then\n\t\t\t-- Wrap the listener in a coroutine to catch errors and handle\n\t\t\t-- yielding correctly.\n\t\t\tlocal listenerCo = coroutine.create(listener)\n\t\t\tlocal success, result = coroutine.resume(\n\t\t\t\tlistenerCo,\n\t\t\t\tself._instance,\n\t\t\t\tunpack(eventInvocation, 3, 2 + argumentCount)\n\t\t\t)\n\n\t\t\t-- If the listener threw an error, we log it as a warning, since\n\t\t\t-- there's no way to write error text in Roblox Lua without killing\n\t\t\t-- our thread!\n\t\t\tif not success then\n\t\t\t\tLogging.warn(\"%s\", result)\n\t\t\tend\n\t\tend\n\n\t\tindex = index + 1\n\tend\n\n\tself._isResuming = false\n\tself._status = EventStatus.Enabled\n\tself._suspendedEventQueue = {}\nend\n\nreturn SingleEventManager\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "RobloxRenderer.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n\tlocal assertDeepEqual = require(script.Parent.assertDeepEqual)\n\tlocal Binding = require(script.Parent.Binding)\n\tlocal Children = require(script.Parent.PropMarkers.Children)\n\tlocal Component = require(script.Parent.Component)\n\tlocal createElement = require(script.Parent.createElement)\n\tlocal createFragment = require(script.Parent.createFragment)\n\tlocal createReconciler = require(script.Parent.createReconciler)\n\tlocal createRef = require(script.Parent.createRef)\n\tlocal createSpy = require(script.Parent.createSpy)\n\tlocal GlobalConfig = require(script.Parent.GlobalConfig)\n\tlocal Portal = require(script.Parent.Portal)\n\tlocal Ref = require(script.Parent.PropMarkers.Ref)\n\tlocal Event = require(script.Parent.PropMarkers.Event)\n\n\tlocal RobloxRenderer = require(script.Parent.RobloxRenderer)\n\n\tlocal reconciler = createReconciler(RobloxRenderer)\n\n\tdescribe(\"mountHostNode\", function()\n\t\tit(\"should create instances with correct props\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal value = \"Hello!\"\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal element = createElement(\"StringValue\", {\n\t\t\t\tValue = value,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal root = parent:GetChildren()[1]\n\n\t\t\texpect(root.ClassName).to.equal(\"StringValue\")\n\t\t\texpect(root.Value).to.equal(value)\n\t\t\texpect(root.Name).to.equal(key)\n\t\tend)\n\n\t\tit(\"should create children with correct names and props\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal rootValue = \"Hey there!\"\n\t\t\tlocal childValue = 173\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal element = createElement(\"StringValue\", {\n\t\t\t\tValue = rootValue,\n\t\t\t}, {\n\t\t\t\tChildA = createElement(\"IntValue\", {\n\t\t\t\t\tValue = childValue,\n\t\t\t\t}),\n\n\t\t\t\tChildB = createElement(\"Folder\"),\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal root = parent:GetChildren()[1]\n\n\t\t\texpect(root.ClassName).to.equal(\"StringValue\")\n\t\t\texpect(root.Value).to.equal(rootValue)\n\t\t\texpect(root.Name).to.equal(key)\n\n\t\t\texpect(#root:GetChildren()).to.equal(2)\n\n\t\t\tlocal childA = root.ChildA\n\t\t\tlocal childB = root.ChildB\n\n\t\t\texpect(childA).to.be.ok()\n\t\t\texpect(childB).to.be.ok()\n\n\t\t\texpect(childA.ClassName).to.equal(\"IntValue\")\n\t\t\texpect(childA.Value).to.equal(childValue)\n\n\t\t\texpect(childB.ClassName).to.equal(\"Folder\")\n\t\tend)\n\n\t\tit(\"should attach Bindings to Roblox properties\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal binding, update = Binding.create(10)\n\t\t\tlocal element = createElement(\"IntValue\", {\n\t\t\t\tValue = binding,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(instance.ClassName).to.equal(\"IntValue\")\n\t\t\texpect(instance.Value).to.equal(10)\n\n\t\t\tupdate(20)\n\n\t\t\texpect(instance.Value).to.equal(20)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\t\tend)\n\n\t\tit(\"should connect Binding refs\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal ref = createRef()\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\t[Ref] = ref,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(ref.current).to.be.ok()\n\t\t\texpect(ref.current).to.equal(instance)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\t\tend)\n\n\t\tit(\"should call function refs\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal spyRef = createSpy()\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\t[Ref] = spyRef.value,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(spyRef.callCount).to.equal(1)\n\t\t\tspyRef:assertCalledWith(instance)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\t\tend)\n\n\t\tit(\"should throw if setting invalid instance properties\", function()\n\t\t\tlocal configValues = {\n\t\t\t\telementTracing = true,\n\t\t\t}\n\n\t\t\tGlobalConfig.scoped(configValues, function()\n\t\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\t\tlocal key = \"Some Key\"\n\n\t\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\t\tFrob = 6,\n\t\t\t\t})\n\n\t\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\t\tlocal success, message = pcall(RobloxRenderer.mountHostNode, reconciler, node)\n\t\t\t\tassert(not success, \"Expected call to fail\")\n\n\t\t\t\texpect(message:find(\"Frob\")).to.be.ok()\n\t\t\t\texpect(message:find(\"Frame\")).to.be.ok()\n\t\t\t\texpect(message:find(\"RobloxRenderer%.spec\")).to.be.ok()\n\t\t\tend)\n\t\tend)\n\tend)\n\n\tdescribe(\"updateHostNode\", function()\n\t\tit(\"should update node props and children\", function()\n\t\t\t-- TODO: Break up test\n\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"updateHostNodeTest\"\n\t\t\tlocal firstValue = \"foo\"\n\t\t\tlocal newValue = \"bar\"\n\n\t\t\tlocal defaultStringValue = Instance.new(\"StringValue\").Value\n\n\t\t\tlocal element = createElement(\"StringValue\", {\n\t\t\t\tValue = firstValue,\n\t\t\t}, {\n\t\t\t\tChildA = createElement(\"IntValue\", {\n\t\t\t\t\tValue = 1,\n\t\t\t\t}),\n\t\t\t\tChildB = createElement(\"BoolValue\", {\n\t\t\t\t\tValue = true,\n\t\t\t\t}),\n\t\t\t\tChildC = createElement(\"StringValue\", {\n\t\t\t\t\tValue = \"test\",\n\t\t\t\t}),\n\t\t\t\tChildD = createElement(\"StringValue\", {\n\t\t\t\t\tValue = \"test\",\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\t-- Not testing mountHostNode's work here, only testing that the\n\t\t\t-- node is properly updated.\n\n\t\t\tlocal newElement = createElement(\"StringValue\", {\n\t\t\t\tValue = newValue,\n\t\t\t}, {\n\t\t\t\t-- ChildA changes element type.\n\t\t\t\tChildA = createElement(\"StringValue\", {\n\t\t\t\t\tValue = \"test\",\n\t\t\t\t}),\n\t\t\t\t-- ChildB changes child properties.\n\t\t\t\tChildB = createElement(\"BoolValue\", {\n\t\t\t\t\tValue = false,\n\t\t\t\t}),\n\t\t\t\t-- ChildC should reset its Value property back to the default.\n\t\t\t\tChildC = createElement(\"StringValue\", {}),\n\t\t\t\t-- ChildD is deleted.\n\t\t\t\t-- ChildE is added.\n\t\t\t\tChildE = createElement(\"Folder\", {}),\n\t\t\t})\n\n\t\t\tRobloxRenderer.updateHostNode(reconciler, node, newElement)\n\n\t\t\tlocal root = parent[key]\n\t\t\texpect(root.ClassName).to.equal(\"StringValue\")\n\t\t\texpect(root.Value).to.equal(newValue)\n\t\t\texpect(#root:GetChildren()).to.equal(4)\n\n\t\t\tlocal childA = root.ChildA\n\t\t\texpect(childA.ClassName).to.equal(\"StringValue\")\n\t\t\texpect(childA.Value).to.equal(\"test\")\n\n\t\t\tlocal childB = root.ChildB\n\t\t\texpect(childB.ClassName).to.equal(\"BoolValue\")\n\t\t\texpect(childB.Value).to.equal(false)\n\n\t\t\tlocal childC = root.ChildC\n\t\t\texpect(childC.ClassName).to.equal(\"StringValue\")\n\t\t\texpect(childC.Value).to.equal(defaultStringValue)\n\n\t\t\tlocal childE = root.ChildE\n\t\t\texpect(childE.ClassName).to.equal(\"Folder\")\n\t\tend)\n\n\t\tit(\"should update Bindings\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal bindingA, updateA = Binding.create(10)\n\t\t\tlocal element = createElement(\"IntValue\", {\n\t\t\t\tValue = bindingA,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(instance.Value).to.equal(10)\n\n\t\t\tlocal bindingB, updateB = Binding.create(99)\n\t\t\tlocal newElement = createElement(\"IntValue\", {\n\t\t\t\tValue = bindingB,\n\t\t\t})\n\n\t\t\tRobloxRenderer.updateHostNode(reconciler, node, newElement)\n\n\t\t\texpect(instance.Value).to.equal(99)\n\n\t\t\tupdateA(123)\n\n\t\t\texpect(instance.Value).to.equal(99)\n\n\t\t\tupdateB(123)\n\n\t\t\texpect(instance.Value).to.equal(123)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\t\tend)\n\n\t\tit(\"should update Binding refs\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal refA = createRef()\n\t\t\tlocal refB = createRef()\n\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\t[Ref] = refA,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(refA.current).to.equal(instance)\n\t\t\texpect(refB.current).never.to.be.ok()\n\n\t\t\tlocal newElement = createElement(\"Frame\", {\n\t\t\t\t[Ref] = refB,\n\t\t\t})\n\n\t\t\tRobloxRenderer.updateHostNode(reconciler, node, newElement)\n\n\t\t\texpect(refA.current).never.to.be.ok()\n\t\t\texpect(refB.current).to.equal(instance)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\t\tend)\n\n\t\tit(\"should call old function refs with nil and new function refs with a valid rbx\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal spyRefA = createSpy()\n\t\t\tlocal spyRefB = createSpy()\n\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\t[Ref] = spyRefA.value,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(spyRefA.callCount).to.equal(1)\n\t\t\tspyRefA:assertCalledWith(instance)\n\t\t\texpect(spyRefB.callCount).to.equal(0)\n\n\t\t\tlocal newElement = createElement(\"Frame\", {\n\t\t\t\t[Ref] = spyRefB.value,\n\t\t\t})\n\n\t\t\tRobloxRenderer.updateHostNode(reconciler, node, newElement)\n\n\t\t\texpect(spyRefA.callCount).to.equal(2)\n\t\t\tspyRefA:assertCalledWith(nil)\n\t\t\texpect(spyRefB.callCount).to.equal(1)\n\t\t\tspyRefB:assertCalledWith(instance)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\t\tend)\n\n\t\tit(\"should not call function refs again if they didn't change\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal spyRef = createSpy()\n\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\tSize = UDim2.new(1, 0, 1, 0),\n\t\t\t\t[Ref] = spyRef.value,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(spyRef.callCount).to.equal(1)\n\t\t\tspyRef:assertCalledWith(instance)\n\n\t\t\tlocal newElement = createElement(\"Frame\", {\n\t\t\t\tSize = UDim2.new(0.5, 0, 0.5, 0),\n\t\t\t\t[Ref] = spyRef.value,\n\t\t\t})\n\n\t\t\tRobloxRenderer.updateHostNode(reconciler, node, newElement)\n\n\t\t\t-- Not called again\n\t\t\texpect(spyRef.callCount).to.equal(1)\n\t\tend)\n\n\t\tit(\"should throw if setting invalid instance properties\", function()\n\t\t\tlocal configValues = {\n\t\t\t\telementTracing = true,\n\t\t\t}\n\n\t\t\tGlobalConfig.scoped(configValues, function()\n\t\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\t\tlocal key = \"Some Key\"\n\n\t\t\t\tlocal firstElement = createElement(\"Frame\")\n\t\t\t\tlocal secondElement = createElement(\"Frame\", {\n\t\t\t\t\tFrob = 6,\n\t\t\t\t})\n\n\t\t\t\tlocal node = reconciler.createVirtualNode(firstElement, parent, key)\n\t\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\t\tlocal success, message = pcall(RobloxRenderer.updateHostNode, reconciler, node, secondElement)\n\t\t\t\tassert(not success, \"Expected call to fail\")\n\n\t\t\t\texpect(message:find(\"Frob\")).to.be.ok()\n\t\t\t\texpect(message:find(\"Frame\")).to.be.ok()\n\t\t\t\texpect(message:find(\"RobloxRenderer%.spec\")).to.be.ok()\n\t\t\tend)\n\t\tend)\n\n\t\tit(\"should delete instances when reconciling to nil children\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\tSize = UDim2.new(1, 0, 1, 0),\n\t\t\t}, {\n\t\t\t\tchild = createElement(\"Frame\"),\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\t\t\texpect(#instance:GetChildren()).to.equal(1)\n\n\t\t\tlocal newElement = createElement(\"Frame\", {\n\t\t\t\tSize = UDim2.new(0.5, 0, 0.5, 0),\n\t\t\t})\n\n\t\t\tRobloxRenderer.updateHostNode(reconciler, node, newElement)\n\t\t\texpect(#instance:GetChildren()).to.equal(0)\n\t\tend)\n\tend)\n\n\tdescribe(\"unmountHostNode\", function()\n\t\tit(\"should delete instances from the inside-out\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Root\"\n\t\t\tlocal element = createElement(\"Folder\", nil, {\n\t\t\t\tChild = createElement(\"Folder\", nil, {\n\t\t\t\t\tGrandchild = createElement(\"Folder\"),\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal node = reconciler.mountVirtualNode(element, parent, key)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal root = parent:GetChildren()[1]\n\t\t\texpect(#root:GetChildren()).to.equal(1)\n\n\t\t\tlocal child = root:GetChildren()[1]\n\t\t\texpect(#child:GetChildren()).to.equal(1)\n\n\t\t\tlocal grandchild = child:GetChildren()[1]\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\n\t\t\texpect(grandchild.Parent).to.equal(nil)\n\t\t\texpect(child.Parent).to.equal(nil)\n\t\t\texpect(root.Parent).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should unsubscribe from any Bindings\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal binding, update = Binding.create(10)\n\t\t\tlocal element = createElement(\"IntValue\", {\n\t\t\t\tValue = binding,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(instance.Value).to.equal(10)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\t\t\tupdate(56)\n\n\t\t\texpect(instance.Value).to.equal(10)\n\t\tend)\n\n\t\tit(\"should clear Binding refs\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal ref = createRef()\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\t[Ref] = ref,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(ref.current).to.be.ok()\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\n\t\t\texpect(ref.current).never.to.be.ok()\n\t\tend)\n\n\t\tit(\"should call function refs with nil\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal spyRef = createSpy()\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\t[Ref] = spyRef.value,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(spyRef.callCount).to.equal(1)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\n\t\t\texpect(spyRef.callCount).to.equal(2)\n\t\t\tspyRef:assertCalledWith(nil)\n\t\tend)\n\tend)\n\n\tdescribe(\"Portals\", function()\n\t\tit(\"should create and destroy instances as children of `target`\", function()\n\t\t\tlocal target = Instance.new(\"Folder\")\n\n\t\t\tlocal function FunctionComponent(props)\n\t\t\t\treturn createElement(\"IntValue\", {\n\t\t\t\t\tValue = props.value,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(Portal, {\n\t\t\t\ttarget = target,\n\t\t\t}, {\n\t\t\t\tfolderOne = createElement(\"Folder\"),\n\t\t\t\tfolderTwo = createElement(\"Folder\"),\n\t\t\t\tintValueOne = createElement(FunctionComponent, {\n\t\t\t\t\tvalue = 42,\n\t\t\t\t}),\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\tlocal node = reconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\t\texpect(#target:GetChildren()).to.equal(3)\n\n\t\t\texpect(target:FindFirstChild(\"folderOne\")).to.be.ok()\n\t\t\texpect(target:FindFirstChild(\"folderTwo\")).to.be.ok()\n\t\t\texpect(target:FindFirstChild(\"intValueOne\")).to.be.ok()\n\t\t\texpect(target:FindFirstChild(\"intValueOne\").Value).to.equal(42)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(#target:GetChildren()).to.equal(0)\n\t\tend)\n\n\t\tit(\"should pass prop updates through to children\", function()\n\t\t\tlocal target = Instance.new(\"Folder\")\n\n\t\t\tlocal firstElement = createElement(Portal, {\n\t\t\t\ttarget = target,\n\t\t\t}, {\n\t\t\t\tChildValue = createElement(\"IntValue\", {\n\t\t\t\t\tValue = 1,\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal secondElement = createElement(Portal, {\n\t\t\t\ttarget = target,\n\t\t\t}, {\n\t\t\t\tChildValue = createElement(\"IntValue\", {\n\t\t\t\t\tValue = 2,\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"A Host Key\"\n\t\t\tlocal node = reconciler.mountVirtualNode(firstElement, hostParent, hostKey)\n\n\t\t\texpect(#target:GetChildren()).to.equal(1)\n\n\t\t\tlocal firstValue = target.ChildValue\n\t\t\texpect(firstValue.Value).to.equal(1)\n\n\t\t\tnode = reconciler.updateVirtualNode(node, secondElement)\n\n\t\t\texpect(#target:GetChildren()).to.equal(1)\n\n\t\t\tlocal secondValue = target.ChildValue\n\t\t\texpect(firstValue).to.equal(secondValue)\n\t\t\texpect(secondValue.Value).to.equal(2)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(#target:GetChildren()).to.equal(0)\n\t\tend)\n\n\t\tit(\"should throw if `target` is nil\", function()\n\t\t\t-- TODO: Relax this restriction?\n\t\t\tlocal element = createElement(Portal)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Keys for Everyone\"\n\n\t\t\texpect(function()\n\t\t\t\treconciler.mountVirtualNode(element, hostParent, hostKey)\n\t\t\tend).to.throw()\n\t\tend)\n\n\t\tit(\"should throw if `target` is not a Roblox instance\", function()\n\t\t\tlocal element = createElement(Portal, {\n\t\t\t\ttarget = {},\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Unleash the keys!\"\n\n\t\t\texpect(function()\n\t\t\t\treconciler.mountVirtualNode(element, hostParent, hostKey)\n\t\t\tend).to.throw()\n\t\tend)\n\n\t\tit(\"should recreate instances if `target` changes in an update\", function()\n\t\t\tlocal firstTarget = Instance.new(\"Folder\")\n\t\t\tlocal secondTarget = Instance.new(\"Folder\")\n\n\t\t\tlocal firstElement = createElement(Portal, {\n\t\t\t\ttarget = firstTarget,\n\t\t\t}, {\n\t\t\t\tChildValue = createElement(\"IntValue\", {\n\t\t\t\t\tValue = 1,\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal secondElement = createElement(Portal, {\n\t\t\t\ttarget = secondTarget,\n\t\t\t}, {\n\t\t\t\tChildValue = createElement(\"IntValue\", {\n\t\t\t\t\tValue = 2,\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\tlocal node = reconciler.mountVirtualNode(firstElement, hostParent, hostKey)\n\n\t\t\texpect(#firstTarget:GetChildren()).to.equal(1)\n\t\t\texpect(#secondTarget:GetChildren()).to.equal(0)\n\n\t\t\tlocal firstChild = firstTarget.ChildValue\n\t\t\texpect(firstChild.Value).to.equal(1)\n\n\t\t\tnode = reconciler.updateVirtualNode(node, secondElement)\n\n\t\t\texpect(#firstTarget:GetChildren()).to.equal(0)\n\t\t\texpect(#secondTarget:GetChildren()).to.equal(1)\n\n\t\t\tlocal secondChild = secondTarget.ChildValue\n\t\t\texpect(secondChild.Value).to.equal(2)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(#firstTarget:GetChildren()).to.equal(0)\n\t\t\texpect(#secondTarget:GetChildren()).to.equal(0)\n\t\tend)\n\tend)\n\n\tdescribe(\"Fragments\", function()\n\t\tit(\"should parent the fragment's elements into the fragment's parent\", function()\n\t\t\tlocal hostParent = Instance.new(\"Folder\")\n\n\t\t\tlocal fragment = createFragment({\n\t\t\t\tkey = createElement(\"IntValue\", {\n\t\t\t\t\tValue = 1,\n\t\t\t\t}),\n\t\t\t\tkey2 = createElement(\"IntValue\", {\n\t\t\t\t\tValue = 2,\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal node = reconciler.mountVirtualNode(fragment, hostParent, \"test\")\n\n\t\t\texpect(hostParent:FindFirstChild(\"key\")).to.be.ok()\n\t\t\texpect(hostParent.key.ClassName).to.equal(\"IntValue\")\n\t\t\texpect(hostParent.key.Value).to.equal(1)\n\n\t\t\texpect(hostParent:FindFirstChild(\"key2\")).to.be.ok()\n\t\t\texpect(hostParent.key2.ClassName).to.equal(\"IntValue\")\n\t\t\texpect(hostParent.key2.Value).to.equal(2)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(#hostParent:GetChildren()).to.equal(0)\n\t\tend)\n\n\t\tit(\"should allow sibling fragment to have common keys\", function()\n\t\t\tlocal hostParent = Instance.new(\"Folder\")\n\t\t\tlocal hostKey = \"Test\"\n\n\t\t\tlocal function parent(_props)\n\t\t\t\treturn createElement(\"IntValue\", {}, {\n\t\t\t\t\tfragmentA = createFragment({\n\t\t\t\t\t\tkey = createElement(\"StringValue\", {\n\t\t\t\t\t\t\tValue = \"A\",\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tkey2 = createElement(\"StringValue\", {\n\t\t\t\t\t\t\tValue = \"B\",\n\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t\tfragmentB = createFragment({\n\t\t\t\t\t\tkey = createElement(\"StringValue\", {\n\t\t\t\t\t\t\tValue = \"C\",\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tkey2 = createElement(\"StringValue\", {\n\t\t\t\t\t\t\tValue = \"D\",\n\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal node = reconciler.mountVirtualNode(createElement(parent), hostParent, hostKey)\n\t\t\tlocal parentChildren = hostParent[hostKey]:GetChildren()\n\n\t\t\texpect(#parentChildren).to.equal(4)\n\n\t\t\tlocal childValues = {}\n\n\t\t\tfor _, child in pairs(parentChildren) do\n\t\t\t\texpect(child.ClassName).to.equal(\"StringValue\")\n\t\t\t\tchildValues[child.Value] = 1 + (childValues[child.Value] or 0)\n\t\t\tend\n\n\t\t\t-- check if the StringValues have not collided\n\t\t\texpect(childValues.A).to.equal(1)\n\t\t\texpect(childValues.B).to.equal(1)\n\t\t\texpect(childValues.C).to.equal(1)\n\t\t\texpect(childValues.D).to.equal(1)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(#hostParent:GetChildren()).to.equal(0)\n\t\tend)\n\n\t\tit(\"should render nested fragments\", function()\n\t\t\tlocal hostParent = Instance.new(\"Folder\")\n\n\t\t\tlocal fragment = createFragment({\n\t\t\t\tkey = createFragment({\n\t\t\t\t\tTheValue = createElement(\"IntValue\", {\n\t\t\t\t\t\tValue = 1,\n\t\t\t\t\t}),\n\t\t\t\t\tTheOtherValue = createElement(\"IntValue\", {\n\t\t\t\t\t\tValue = 2,\n\t\t\t\t\t}),\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal node = reconciler.mountVirtualNode(fragment, hostParent, \"Test\")\n\n\t\t\texpect(hostParent:FindFirstChild(\"TheValue\")).to.be.ok()\n\t\t\texpect(hostParent.TheValue.ClassName).to.equal(\"IntValue\")\n\t\t\texpect(hostParent.TheValue.Value).to.equal(1)\n\n\t\t\texpect(hostParent:FindFirstChild(\"TheOtherValue\")).to.be.ok()\n\t\t\texpect(hostParent.TheOtherValue.ClassName).to.equal(\"IntValue\")\n\t\t\texpect(hostParent.TheOtherValue.Value).to.equal(2)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(#hostParent:GetChildren()).to.equal(0)\n\t\tend)\n\n\t\tit(\"should not add any instances if the fragment is empty\", function()\n\t\t\tlocal hostParent = Instance.new(\"Folder\")\n\n\t\t\tlocal node = reconciler.mountVirtualNode(createFragment({}), hostParent, \"test\")\n\n\t\t\texpect(#hostParent:GetChildren()).to.equal(0)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(#hostParent:GetChildren()).to.equal(0)\n\t\tend)\n\tend)\n\n\tdescribe(\"Context\", function()\n\t\tit(\"should pass context values through Roblox host nodes\", function()\n\t\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\t\tlocal capturedContext\n\t\t\tfunction Consumer:init()\n\t\t\t\tcapturedContext = {\n\t\t\t\t\thello = self:__getContext(\"hello\"),\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tfunction Consumer:render() end\n\n\t\t\tlocal element = createElement(\"Folder\", nil, {\n\t\t\t\tConsumer = createElement(Consumer),\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Context Test\"\n\t\t\tlocal context = {\n\t\t\t\thello = \"world\",\n\t\t\t}\n\t\t\tlocal node = reconciler.mountVirtualNode(element, hostParent, hostKey, context)\n\n\t\t\texpect(capturedContext).never.to.equal(context)\n\t\t\tassertDeepEqual(capturedContext, context)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\t\tend)\n\n\t\tit(\"should pass context values through portal nodes\", function()\n\t\t\tlocal target = Instance.new(\"Folder\")\n\n\t\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\t\tfunction Provider:init()\n\t\t\t\tself:__addContext(\"foo\", \"bar\")\n\t\t\tend\n\n\t\t\tfunction Provider:render()\n\t\t\t\treturn createElement(\"Folder\", nil, self.props[Children])\n\t\t\tend\n\n\t\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\t\tlocal capturedContext\n\t\t\tfunction Consumer:init()\n\t\t\t\tcapturedContext = {\n\t\t\t\t\tfoo = self:__getContext(\"foo\"),\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tfunction Consumer:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(Provider, nil, {\n\t\t\t\tPortal = createElement(Portal, {\n\t\t\t\t\ttarget = target,\n\t\t\t\t}, {\n\t\t\t\t\tConsumer = createElement(Consumer),\n\t\t\t\t}),\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\treconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\t\tassertDeepEqual(capturedContext, {\n\t\t\t\tfoo = \"bar\",\n\t\t\t})\n\t\tend)\n\tend)\n\n\tdescribe(\"Legacy context\", function()\n\t\tit(\"should pass context values through Roblox host nodes\", function()\n\t\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\t\tlocal capturedContext\n\t\t\tfunction Consumer:init()\n\t\t\t\tcapturedContext = self._context\n\t\t\tend\n\n\t\t\tfunction Consumer:render() end\n\n\t\t\tlocal element = createElement(\"Folder\", nil, {\n\t\t\t\tConsumer = createElement(Consumer),\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Context Test\"\n\t\t\tlocal context = {\n\t\t\t\thello = \"world\",\n\t\t\t}\n\t\t\tlocal node = reconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)\n\n\t\t\texpect(capturedContext).never.to.equal(context)\n\t\t\tassertDeepEqual(capturedContext, context)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\t\tend)\n\n\t\tit(\"should pass context values through portal nodes\", function()\n\t\t\tlocal target = Instance.new(\"Folder\")\n\n\t\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\t\tfunction Provider:init()\n\t\t\t\tself._context.foo = \"bar\"\n\t\t\tend\n\n\t\t\tfunction Provider:render()\n\t\t\t\treturn createElement(\"Folder\", nil, self.props[Children])\n\t\t\tend\n\n\t\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\t\tlocal capturedContext\n\t\t\tfunction Consumer:init()\n\t\t\t\tcapturedContext = self._context\n\t\t\tend\n\n\t\t\tfunction Consumer:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(Provider, nil, {\n\t\t\t\tPortal = createElement(Portal, {\n\t\t\t\t\ttarget = target,\n\t\t\t\t}, {\n\t\t\t\t\tConsumer = createElement(Consumer),\n\t\t\t\t}),\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\treconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\t\tassertDeepEqual(capturedContext, {\n\t\t\t\tfoo = \"bar\",\n\t\t\t})\n\t\tend)\n\tend)\n\n\tdescribe(\"Integration Tests\", function()\n\t\tlocal temporaryParent = nil\n\t\tbeforeEach(function()\n\t\t\ttemporaryParent = Instance.new(\"Folder\")\n\t\t\ttemporaryParent.Parent = ReplicatedStorage\n\t\tend)\n\n\t\tafterEach(function()\n\t\t\ttemporaryParent:Destroy()\n\t\t\ttemporaryParent = nil\n\t\tend)\n\n\t\tit(\"should not allow re-entrancy in updateChildren\", function()\n\t\t\tlocal ChildComponent = Component:extend(\"ChildComponent\")\n\n\t\t\tfunction ChildComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tfirstTime = true,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal childCoroutine\n\n\t\t\tfunction ChildComponent:render()\n\t\t\t\tif self.state.firstTime then\n\t\t\t\t\treturn createElement(\"Frame\")\n\t\t\t\tend\n\n\t\t\t\treturn createElement(\"TextLabel\")\n\t\t\tend\n\n\t\t\tfunction ChildComponent:didMount()\n\t\t\t\tchildCoroutine = coroutine.create(function()\n\t\t\t\t\tself:setState({\n\t\t\t\t\t\tfirstTime = false,\n\t\t\t\t\t})\n\t\t\t\tend)\n\t\t\tend\n\n\t\t\tlocal ParentComponent = Component:extend(\"ParentComponent\")\n\n\t\t\tfunction ParentComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tcount = 1,\n\t\t\t\t})\n\n\t\t\t\tself.childAdded = function()\n\t\t\t\t\tself:setState({\n\t\t\t\t\t\tcount = self.state.count + 1,\n\t\t\t\t\t})\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction ParentComponent:render()\n\t\t\t\treturn createElement(\"Frame\", {\n\t\t\t\t\t[Event.ChildAdded] = self.childAdded,\n\t\t\t\t}, {\n\t\t\t\t\tChildComponent = createElement(ChildComponent, {\n\t\t\t\t\t\tcount = self.state.count,\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal parent = Instance.new(\"ScreenGui\")\n\t\t\tparent.Parent = temporaryParent\n\n\t\t\tlocal tree = createElement(ParentComponent)\n\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\tlocal instance = reconciler.mountVirtualNode(tree, parent, hostKey)\n\n\t\t\tcoroutine.resume(childCoroutine)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal frame = parent:GetChildren()[1]\n\n\t\t\texpect(#frame:GetChildren()).to.equal(1)\n\n\t\t\treconciler.unmountVirtualNode(instance)\n\t\tend)\n\n\t\tit(\"should not allow re-entrancy in updateChildren even with callbacks\", function()\n\t\t\tlocal LowestComponent = Component:extend(\"LowestComponent\")\n\n\t\t\tfunction LowestComponent:render()\n\t\t\t\treturn createElement(\"Frame\")\n\t\t\tend\n\n\t\t\tfunction LowestComponent:didMount()\n\t\t\t\tself.props.onDidMountCallback()\n\t\t\tend\n\n\t\t\tlocal ChildComponent = Component:extend(\"ChildComponent\")\n\n\t\t\tfunction ChildComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tfirstTime = true,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal childCoroutine\n\n\t\t\tfunction ChildComponent:render()\n\t\t\t\tif self.state.firstTime then\n\t\t\t\t\treturn createElement(\"Frame\")\n\t\t\t\tend\n\n\t\t\t\treturn createElement(LowestComponent, {\n\t\t\t\t\tonDidMountCallback = self.props.onDidMountCallback,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tfunction ChildComponent:didMount()\n\t\t\t\tchildCoroutine = coroutine.create(function()\n\t\t\t\t\tself:setState({\n\t\t\t\t\t\tfirstTime = false,\n\t\t\t\t\t})\n\t\t\t\tend)\n\t\t\tend\n\n\t\t\tlocal ParentComponent = Component:extend(\"ParentComponent\")\n\n\t\t\tlocal didMountCallbackCalled = 0\n\n\t\t\tfunction ParentComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tcount = 1,\n\t\t\t\t})\n\n\t\t\t\tself.onDidMountCallback = function()\n\t\t\t\t\tdidMountCallbackCalled = didMountCallbackCalled + 1\n\t\t\t\t\tif self.state.count < 5 then\n\t\t\t\t\t\tself:setState({\n\t\t\t\t\t\t\tcount = self.state.count + 1,\n\t\t\t\t\t\t})\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction ParentComponent:render()\n\t\t\t\treturn createElement(\"Frame\", {}, {\n\t\t\t\t\tChildComponent = createElement(ChildComponent, {\n\t\t\t\t\t\tcount = self.state.count,\n\t\t\t\t\t\tonDidMountCallback = self.onDidMountCallback,\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal parent = Instance.new(\"ScreenGui\")\n\t\t\tparent.Parent = temporaryParent\n\n\t\t\tlocal tree = createElement(ParentComponent)\n\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\tlocal instance = reconciler.mountVirtualNode(tree, parent, hostKey)\n\n\t\t\tcoroutine.resume(childCoroutine)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal frame = parent:GetChildren()[1]\n\n\t\t\texpect(#frame:GetChildren()).to.equal(1)\n\n\t\t\t-- In an ideal world, the didMount callback would probably be called only once. Since it is called by two different\n\t\t\t-- LowestComponent instantiations 2 is also acceptable though.\n\t\t\texpect(didMountCallbackCalled <= 2).to.equal(true)\n\n\t\t\treconciler.unmountVirtualNode(instance)\n\t\tend)\n\n\t\tit(\"should never call unmount twice in the case of update children re-rentrancy\", function()\n\t\t\tlocal unmountCounts = {}\n\n\t\t\tlocal function addUnmount(id)\n\t\t\t\tunmountCounts[id] = unmountCounts[id] + 1\n\t\t\tend\n\n\t\t\tlocal function addInit(id)\n\t\t\t\tunmountCounts[id] = 0\n\t\t\tend\n\n\t\t\tlocal LowestComponent = Component:extend(\"LowestComponent\")\n\t\t\tfunction LowestComponent:init()\n\t\t\t\taddInit(tostring(self))\n\t\t\tend\n\n\t\t\tfunction LowestComponent:render()\n\t\t\t\treturn createElement(\"Frame\")\n\t\t\tend\n\n\t\t\tfunction LowestComponent:didMount()\n\t\t\t\tself.props.onDidMountCallback()\n\t\t\tend\n\n\t\t\tfunction LowestComponent:willUnmount()\n\t\t\t\taddUnmount(tostring(self))\n\t\t\tend\n\n\t\t\tlocal FirstComponent = Component:extend(\"FirstComponent\")\n\t\t\tfunction FirstComponent:init()\n\t\t\t\taddInit(tostring(self))\n\t\t\tend\n\n\t\t\tfunction FirstComponent:render()\n\t\t\t\treturn createElement(\"TextLabel\")\n\t\t\tend\n\n\t\t\tfunction FirstComponent:willUnmount()\n\t\t\t\taddUnmount(tostring(self))\n\t\t\tend\n\n\t\t\tlocal ChildComponent = Component:extend(\"ChildComponent\")\n\n\t\t\tfunction ChildComponent:init()\n\t\t\t\taddInit(tostring(self))\n\n\t\t\t\tself:setState({\n\t\t\t\t\tfirstTime = true,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal childCoroutine\n\n\t\t\tfunction ChildComponent:render()\n\t\t\t\tif self.state.firstTime then\n\t\t\t\t\treturn createElement(FirstComponent)\n\t\t\t\tend\n\n\t\t\t\treturn createElement(LowestComponent, {\n\t\t\t\t\tonDidMountCallback = self.props.onDidMountCallback,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tfunction ChildComponent:didMount()\n\t\t\t\tchildCoroutine = coroutine.create(function()\n\t\t\t\t\tself:setState({\n\t\t\t\t\t\tfirstTime = false,\n\t\t\t\t\t})\n\t\t\t\tend)\n\t\t\tend\n\n\t\t\tfunction ChildComponent:willUnmount()\n\t\t\t\taddUnmount(tostring(self))\n\t\t\tend\n\n\t\t\tlocal ParentComponent = Component:extend(\"ParentComponent\")\n\n\t\t\tlocal didMountCallbackCalled = 0\n\n\t\t\tfunction ParentComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tcount = 1,\n\t\t\t\t})\n\n\t\t\t\tself.onDidMountCallback = function()\n\t\t\t\t\tdidMountCallbackCalled = didMountCallbackCalled + 1\n\t\t\t\t\tif self.state.count < 5 then\n\t\t\t\t\t\tself:setState({\n\t\t\t\t\t\t\tcount = self.state.count + 1,\n\t\t\t\t\t\t})\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction ParentComponent:render()\n\t\t\t\treturn createElement(\"Frame\", {}, {\n\t\t\t\t\tChildComponent = createElement(ChildComponent, {\n\t\t\t\t\t\tcount = self.state.count,\n\t\t\t\t\t\tonDidMountCallback = self.onDidMountCallback,\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal parent = Instance.new(\"ScreenGui\")\n\t\t\tparent.Parent = temporaryParent\n\n\t\t\tlocal tree = createElement(ParentComponent)\n\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\tlocal instance = reconciler.mountVirtualNode(tree, parent, hostKey)\n\n\t\t\tcoroutine.resume(childCoroutine)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal frame = parent:GetChildren()[1]\n\n\t\t\texpect(#frame:GetChildren()).to.equal(1)\n\n\t\t\t-- In an ideal world, the didMount callback would probably be called only once. Since it is called by two different\n\t\t\t-- LowestComponent instantiations 2 is also acceptable though.\n\t\t\texpect(didMountCallbackCalled <= 2).to.equal(true)\n\n\t\t\treconciler.unmountVirtualNode(instance)\n\n\t\t\tfor _, value in pairs(unmountCounts) do\n\t\t\t\texpect(value).to.equal(1)\n\t\t\tend\n\t\tend)\n\n\t\tit(\"should never unmount a node unnecesarily in the case of re-rentry\", function()\n\t\t\tlocal LowestComponent = Component:extend(\"LowestComponent\")\n\t\t\tfunction LowestComponent:render()\n\t\t\t\treturn createElement(\"Frame\")\n\t\t\tend\n\n\t\t\tfunction LowestComponent:didUpdate(prevProps, _prevState)\n\t\t\t\tif prevProps.firstTime and not self.props.firstTime then\n\t\t\t\t\tself.props.onChangedCallback()\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tlocal ChildComponent = Component:extend(\"ChildComponent\")\n\n\t\t\tfunction ChildComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tfirstTime = true,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal childCoroutine\n\n\t\t\tfunction ChildComponent:render()\n\t\t\t\treturn createElement(LowestComponent, {\n\t\t\t\t\tfirstTime = self.state.firstTime,\n\t\t\t\t\tonChangedCallback = self.props.onChangedCallback,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tfunction ChildComponent:didMount()\n\t\t\t\tchildCoroutine = coroutine.create(function()\n\t\t\t\t\tself:setState({\n\t\t\t\t\t\tfirstTime = false,\n\t\t\t\t\t})\n\t\t\t\tend)\n\t\t\tend\n\n\t\t\tlocal ParentComponent = Component:extend(\"ParentComponent\")\n\n\t\t\tlocal onChangedCallbackCalled = 0\n\n\t\t\tfunction ParentComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tcount = 1,\n\t\t\t\t})\n\n\t\t\t\tself.onChangedCallback = function()\n\t\t\t\t\tonChangedCallbackCalled = onChangedCallbackCalled + 1\n\t\t\t\t\tif self.state.count < 5 then\n\t\t\t\t\t\tself:setState({\n\t\t\t\t\t\t\tcount = self.state.count + 1,\n\t\t\t\t\t\t})\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction ParentComponent:render()\n\t\t\t\treturn createElement(\"Frame\", {}, {\n\t\t\t\t\tChildComponent = createElement(ChildComponent, {\n\t\t\t\t\t\tcount = self.state.count,\n\t\t\t\t\t\tonChangedCallback = self.onChangedCallback,\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal parent = Instance.new(\"ScreenGui\")\n\t\t\tparent.Parent = temporaryParent\n\n\t\t\tlocal tree = createElement(ParentComponent)\n\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\tlocal instance = reconciler.mountVirtualNode(tree, parent, hostKey)\n\n\t\t\tcoroutine.resume(childCoroutine)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal frame = parent:GetChildren()[1]\n\n\t\t\texpect(#frame:GetChildren()).to.equal(1)\n\n\t\t\texpect(onChangedCallbackCalled).to.equal(1)\n\n\t\t\treconciler.unmountVirtualNode(instance)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "RobloxRenderer",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tRenderer that deals in terms of Roblox Instances. This is the most\n\twell-supported renderer after NoopRenderer and is currently the only\n\trenderer that does anything.\n]]\n\nlocal Binding = require(script.Parent.Binding)\nlocal Children = require(script.Parent.PropMarkers.Children)\nlocal ElementKind = require(script.Parent.ElementKind)\nlocal SingleEventManager = require(script.Parent.SingleEventManager)\nlocal getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)\nlocal Ref = require(script.Parent.PropMarkers.Ref)\nlocal Type = require(script.Parent.Type)\nlocal internalAssert = require(script.Parent.internalAssert)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal applyPropsError = [[\nError applying props:\n\t%s\nIn element:\n%s\n]]\n\nlocal updatePropsError = [[\nError updating props:\n\t%s\nIn element:\n%s\n]]\n\nlocal function identity(...)\n\treturn ...\nend\n\nlocal function applyRef(ref, newHostObject)\n\tif ref == nil then\n\t\treturn\n\tend\n\n\tif typeof(ref) == \"function\" then\n\t\tref(newHostObject)\n\telseif Type.of(ref) == Type.Binding then\n\t\tBinding.update(ref, newHostObject)\n\telse\n\t\t-- TODO (#197): Better error message\n\t\terror((\"Invalid ref: Expected type Binding but got %s\"):format(typeof(ref)))\n\tend\nend\n\nlocal function setRobloxInstanceProperty(hostObject, key, newValue)\n\tif newValue == nil then\n\t\tlocal hostClass = hostObject.ClassName\n\t\tlocal _, defaultValue = getDefaultInstanceProperty(hostClass, key)\n\t\tnewValue = defaultValue\n\tend\n\n\t-- Assign the new value to the object\n\thostObject[key] = newValue\n\n\treturn\nend\n\nlocal function removeBinding(virtualNode, key)\n\tlocal disconnect = virtualNode.bindings[key]\n\tdisconnect()\n\tvirtualNode.bindings[key] = nil\nend\n\nlocal function attachBinding(virtualNode, key, newBinding)\n\tlocal function updateBoundProperty(newValue)\n\t\tlocal success, errorMessage = xpcall(function()\n\t\t\tsetRobloxInstanceProperty(virtualNode.hostObject, key, newValue)\n\t\tend, identity)\n\n\t\tif not success then\n\t\t\tlocal source = virtualNode.currentElement.source\n\n\t\t\tif source == nil then\n\t\t\t\tsource = \"<enable element tracebacks>\"\n\t\t\tend\n\n\t\t\tlocal fullMessage = updatePropsError:format(errorMessage, source)\n\t\t\terror(fullMessage, 0)\n\t\tend\n\tend\n\n\tif virtualNode.bindings == nil then\n\t\tvirtualNode.bindings = {}\n\tend\n\n\tvirtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)\n\n\tupdateBoundProperty(newBinding:getValue())\nend\n\nlocal function detachAllBindings(virtualNode)\n\tif virtualNode.bindings ~= nil then\n\t\tfor _, disconnect in pairs(virtualNode.bindings) do\n\t\t\tdisconnect()\n\t\tend\n\tend\nend\n\nlocal function applyProp(virtualNode, key, newValue, oldValue)\n\tif newValue == oldValue then\n\t\treturn\n\tend\n\n\tif key == Ref or key == Children then\n\t\t-- Refs and children are handled in a separate pass\n\t\treturn\n\tend\n\n\tlocal internalKeyType = Type.of(key)\n\n\tif internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then\n\t\tif virtualNode.eventManager == nil then\n\t\t\tvirtualNode.eventManager = SingleEventManager.new(virtualNode.hostObject)\n\t\tend\n\n\t\tlocal eventName = key.name\n\n\t\tif internalKeyType == Type.HostChangeEvent then\n\t\t\tvirtualNode.eventManager:connectPropertyChange(eventName, newValue)\n\t\telse\n\t\t\tvirtualNode.eventManager:connectEvent(eventName, newValue)\n\t\tend\n\n\t\treturn\n\tend\n\n\tlocal newIsBinding = Type.of(newValue) == Type.Binding\n\tlocal oldIsBinding = Type.of(oldValue) == Type.Binding\n\n\tif oldIsBinding then\n\t\tremoveBinding(virtualNode, key)\n\tend\n\n\tif newIsBinding then\n\t\tattachBinding(virtualNode, key, newValue)\n\telse\n\t\tsetRobloxInstanceProperty(virtualNode.hostObject, key, newValue)\n\tend\nend\n\nlocal function applyProps(virtualNode, props)\n\tfor propKey, value in pairs(props) do\n\t\tapplyProp(virtualNode, propKey, value, nil)\n\tend\nend\n\nlocal function updateProps(virtualNode, oldProps, newProps)\n\t-- Apply props that were added or updated\n\tfor propKey, newValue in pairs(newProps) do\n\t\tlocal oldValue = oldProps[propKey]\n\n\t\tapplyProp(virtualNode, propKey, newValue, oldValue)\n\tend\n\n\t-- Clean up props that were removed\n\tfor propKey, oldValue in pairs(oldProps) do\n\t\tlocal newValue = newProps[propKey]\n\n\t\tif newValue == nil then\n\t\t\tapplyProp(virtualNode, propKey, nil, oldValue)\n\t\tend\n\tend\nend\n\nlocal RobloxRenderer = {}\n\nfunction RobloxRenderer.isHostObject(target)\n\treturn typeof(target) == \"Instance\"\nend\n\nfunction RobloxRenderer.mountHostNode(reconciler, virtualNode)\n\tlocal element = virtualNode.currentElement\n\tlocal hostParent = virtualNode.hostParent\n\tlocal hostKey = virtualNode.hostKey\n\n\tif config.internalTypeChecks then\n\t\tinternalAssert(ElementKind.of(element) == ElementKind.Host, \"Element at given node is not a host Element\")\n\tend\n\tif config.typeChecks then\n\t\tassert(element.props.Name == nil, \"Name can not be specified as a prop to a host component in Roact.\")\n\t\tassert(element.props.Parent == nil, \"Parent can not be specified as a prop to a host component in Roact.\")\n\tend\n\n\tlocal instance = Instance.new(element.component)\n\tvirtualNode.hostObject = instance\n\n\tlocal success, errorMessage = xpcall(function()\n\t\tapplyProps(virtualNode, element.props)\n\tend, identity)\n\n\tif not success then\n\t\tlocal source = element.source\n\n\t\tif source == nil then\n\t\t\tsource = \"<enable element tracebacks>\"\n\t\tend\n\n\t\tlocal fullMessage = applyPropsError:format(errorMessage, source)\n\t\terror(fullMessage, 0)\n\tend\n\n\tinstance.Name = tostring(hostKey)\n\n\tlocal children = element.props[Children]\n\n\tif children ~= nil then\n\t\treconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)\n\tend\n\n\tinstance.Parent = hostParent\n\tvirtualNode.hostObject = instance\n\n\tapplyRef(element.props[Ref], instance)\n\n\tif virtualNode.eventManager ~= nil then\n\t\tvirtualNode.eventManager:resume()\n\tend\nend\n\nfunction RobloxRenderer.unmountHostNode(reconciler, virtualNode)\n\tlocal element = virtualNode.currentElement\n\n\tapplyRef(element.props[Ref], nil)\n\n\tfor _, childNode in pairs(virtualNode.children) do\n\t\treconciler.unmountVirtualNode(childNode)\n\tend\n\n\tdetachAllBindings(virtualNode)\n\n\tvirtualNode.hostObject:Destroy()\nend\n\nfunction RobloxRenderer.updateHostNode(reconciler, virtualNode, newElement)\n\tlocal oldProps = virtualNode.currentElement.props\n\tlocal newProps = newElement.props\n\n\tif virtualNode.eventManager ~= nil then\n\t\tvirtualNode.eventManager:suspend()\n\tend\n\n\t-- If refs changed, detach the old ref and attach the new one\n\tif oldProps[Ref] ~= newProps[Ref] then\n\t\tapplyRef(oldProps[Ref], nil)\n\t\tapplyRef(newProps[Ref], virtualNode.hostObject)\n\tend\n\n\tlocal success, errorMessage = xpcall(function()\n\t\tupdateProps(virtualNode, oldProps, newProps)\n\tend, identity)\n\n\tif not success then\n\t\tlocal source = newElement.source\n\n\t\tif source == nil then\n\t\t\tsource = \"<enable element tracebacks>\"\n\t\tend\n\n\t\tlocal fullMessage = updatePropsError:format(errorMessage, source)\n\t\terror(fullMessage, 0)\n\tend\n\n\tlocal children = newElement.props[Children]\n\tif children ~= nil or oldProps[Children] ~= nil then\n\t\treconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)\n\tend\n\n\tif virtualNode.eventManager ~= nil then\n\t\tvirtualNode.eventManager:resume()\n\tend\n\n\treturn virtualNode\nend\n\nreturn RobloxRenderer\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "PureComponent.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal createElement = require(script.Parent.createElement)\n\tlocal NoopRenderer = require(script.Parent.NoopRenderer)\n\tlocal createReconciler = require(script.Parent.createReconciler)\n\n\tlocal PureComponent = require(script.Parent.PureComponent)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be extendable\", function()\n\t\tlocal MyComponent = PureComponent:extend(\"MyComponent\")\n\n\t\texpect(MyComponent).to.be.ok()\n\tend)\n\n\tit(\"should skip updates for shallow-equal props\", function()\n\t\tlocal updateCount = 0\n\t\tlocal setValue\n\n\t\tlocal PureChild = PureComponent:extend(\"PureChild\")\n\n\t\tfunction PureChild:willUpdate()\n\t\t\tupdateCount = updateCount + 1\n\t\tend\n\n\t\tfunction PureChild:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal PureContainer = PureComponent:extend(\"PureContainer\")\n\n\t\tfunction PureContainer:init()\n\t\t\tself.state = {\n\t\t\t\tvalue = 0,\n\t\t\t}\n\t\tend\n\n\t\tfunction PureContainer:didMount()\n\t\t\tsetValue = function(value)\n\t\t\t\tself:setState({\n\t\t\t\t\tvalue = value,\n\t\t\t\t})\n\t\t\tend\n\t\tend\n\n\t\tfunction PureContainer:render()\n\t\t\treturn createElement(PureChild, {\n\t\t\t\tvalue = self.state.value,\n\t\t\t})\n\t\tend\n\n\t\tlocal element = createElement(PureContainer)\n\t\tlocal tree = noopReconciler.mountVirtualTree(element, nil, \"PureComponent Tree\")\n\n\t\texpect(updateCount).to.equal(0)\n\n\t\tsetValue(1)\n\n\t\texpect(updateCount).to.equal(1)\n\n\t\tsetValue(1)\n\n\t\texpect(updateCount).to.equal(1)\n\n\t\tsetValue(2)\n\n\t\texpect(updateCount).to.equal(2)\n\n\t\tsetValue(1)\n\n\t\texpect(updateCount).to.equal(3)\n\n\t\tnoopReconciler.unmountVirtualTree(tree)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "PureComponent",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tA version of Component with a `shouldUpdate` method that forces the\n\tresulting component to be pure.\n]]\n\nlocal Component = require(script.Parent.Component)\n\nlocal PureComponent = Component:extend(\"PureComponent\")\n\n-- When extend()ing a component, you don't get an extend method.\n-- This is to promote composition over inheritance.\n-- PureComponent is an exception to this rule.\nPureComponent.extend = Component.extend\n\nfunction PureComponent:shouldUpdate(newProps, newState)\n\t-- In a vast majority of cases, if state updated, something has updated.\n\t-- We don't bother checking in this case.\n\tif newState ~= self.state then\n\t\treturn true\n\tend\n\n\tif newProps == self.props then\n\t\treturn false\n\tend\n\n\tfor key, value in pairs(newProps) do\n\t\tif self.props[key] ~= value then\n\t\t\treturn true\n\t\tend\n\tend\n\n\tfor key, value in pairs(self.props) do\n\t\tif newProps[key] ~= value then\n\t\t\treturn true\n\t\tend\n\tend\n\n\treturn false\nend\n\nreturn PureComponent\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "PropMarkers",
                        "Archivable": true,
                        "Children": [
                            {
                                "Name": "Ref",
                                "ClassName": "ModuleScript",
                                "Source": "local Symbol = require(script.Parent.Parent.Symbol)\n\nlocal Ref = Symbol.named(\"Ref\")\n\nreturn Ref\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "Event.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Event = require(script.Parent.Event)\n\n\tit(\"should yield event objects when indexed\", function()\n\t\texpect(Type.of(Event.MouseButton1Click)).to.equal(Type.HostEvent)\n\t\texpect(Type.of(Event.Touched)).to.equal(Type.HostEvent)\n\tend)\n\n\tit(\"should yield the same object when indexed again\", function()\n\t\tlocal a = Event.MouseButton1Click\n\t\tlocal b = Event.MouseButton1Click\n\t\tlocal c = Event.Touched\n\n\t\texpect(a).to.equal(b)\n\t\texpect(a).never.to.equal(c)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "Event",
                                "ClassName": "ModuleScript",
                                "Source": "--[[\n\tIndex into `Event` to get a prop key for attaching to an event on a Roblox\n\tInstance.\n\n\tExample:\n\n\t\tRoact.createElement(\"TextButton\", {\n\t\t\tText = \"Hello, world!\",\n\n\t\t\t[Roact.Event.MouseButton1Click] = function(rbx)\n\t\t\t\tprint(\"Clicked\", rbx)\n\t\t\tend\n\t\t})\n]]\n\nlocal Type = require(script.Parent.Parent.Type)\n\nlocal Event = {}\n\nlocal eventMetatable = {\n\t__tostring = function(self)\n\t\treturn (\"RoactHostEvent(%s)\"):format(self.name)\n\tend,\n}\n\nsetmetatable(Event, {\n\t__index = function(_self, eventName)\n\t\tlocal event = {\n\t\t\t[Type] = Type.HostEvent,\n\t\t\tname = eventName,\n\t\t}\n\n\t\tsetmetatable(event, eventMetatable)\n\n\t\tEvent[eventName] = event\n\n\t\treturn event\n\tend,\n})\n\nreturn Event\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "Children",
                                "ClassName": "ModuleScript",
                                "Source": "local Symbol = require(script.Parent.Parent.Symbol)\n\nlocal Children = Symbol.named(\"Children\")\n\nreturn Children\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "Change.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Change = require(script.Parent.Change)\n\n\tit(\"should yield change listener objects when indexed\", function()\n\t\texpect(Type.of(Change.Text)).to.equal(Type.HostChangeEvent)\n\t\texpect(Type.of(Change.Selected)).to.equal(Type.HostChangeEvent)\n\tend)\n\n\tit(\"should yield the same object when indexed again\", function()\n\t\tlocal a = Change.Text\n\t\tlocal b = Change.Text\n\t\tlocal c = Change.Selected\n\n\t\texpect(a).to.equal(b)\n\t\texpect(a).never.to.equal(c)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "Change",
                                "ClassName": "ModuleScript",
                                "Source": "--[[\n\tChange is used to generate special prop keys that can be used to connect to\n\tGetPropertyChangedSignal.\n\n\tGenerally, Change is indexed by a Roblox property name:\n\n\t\tRoact.createElement(\"TextBox\", {\n\t\t\t[Roact.Change.Text] = function(rbx)\n\t\t\t\tprint(\"The TextBox\", rbx, \"changed text to\", rbx.Text)\n\t\t\tend,\n\t\t})\n]]\n\nlocal Type = require(script.Parent.Parent.Type)\n\nlocal Change = {}\n\nlocal changeMetatable = {\n\t__tostring = function(self)\n\t\treturn (\"RoactHostChangeEvent(%s)\"):format(self.name)\n\tend,\n}\n\nsetmetatable(Change, {\n\t__index = function(_self, propertyName)\n\t\tlocal changeListener = {\n\t\t\t[Type] = Type.HostChangeEvent,\n\t\t\tname = propertyName,\n\t\t}\n\n\t\tsetmetatable(changeListener, changeMetatable)\n\t\tChange[propertyName] = changeListener\n\n\t\treturn changeListener\n\tend,\n})\n\nreturn Change\n",
                                "Children": [],
                                "Archivable": true
                            }
                        ],
                        "ClassName": "Folder"
                    },
                    {
                        "Name": "Portal",
                        "ClassName": "ModuleScript",
                        "Source": "local Symbol = require(script.Parent.Symbol)\n\nlocal Portal = Symbol.named(\"Portal\")\n\nreturn Portal\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "NoopRenderer",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tReference renderer intended for use in tests as well as for documenting the\n\tminimum required interface for a Roact renderer.\n]]\n\nlocal NoopRenderer = {}\n\nfunction NoopRenderer.isHostObject(target)\n\t-- Attempting to use NoopRenderer to target a Roblox instance is almost\n\t-- certainly a mistake.\n\treturn target == nil\nend\n\nfunction NoopRenderer.mountHostNode(_reconciler, _node) end\n\nfunction NoopRenderer.unmountHostNode(_reconciler, _node) end\n\nfunction NoopRenderer.updateHostNode(_reconciler, node, _newElement)\n\treturn node\nend\n\nreturn NoopRenderer\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "None",
                        "ClassName": "ModuleScript",
                        "Source": "local Symbol = require(script.Parent.Symbol)\n\n-- Marker used to specify that the value is nothing, because nil cannot be\n-- stored in tables.\nlocal None = Symbol.named(\"None\")\n\nreturn None\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Logging",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tCentralized place to handle logging. Lets us:\n\t- Unit test log output via `Logging.capture`\n\t- Disable verbose log messages when not debugging Roact\n\n\tThis should be broken out into a separate library with the addition of\n\tscoping and logging configuration.\n]]\n\n-- Determines whether log messages will go to stdout/stderr\nlocal outputEnabled = true\n\n-- A set of LogInfo objects that should have messages inserted into them.\n-- This is a set so that nested calls to Logging.capture will behave.\nlocal collectors = {}\n\n-- A set of all stack traces that have called warnOnce.\nlocal onceUsedLocations = {}\n\n--[[\n\tIndent a potentially multi-line string with the given number of tabs, in\n\taddition to any indentation the string already has.\n]]\nlocal function indent(source, indentLevel)\n\tlocal indentString = (\"\\t\"):rep(indentLevel)\n\n\treturn indentString .. source:gsub(\"\\n\", \"\\n\" .. indentString)\nend\n\n--[[\n\tIndents a list of strings and then concatenates them together with newlines\n\tinto a single string.\n]]\nlocal function indentLines(lines, indentLevel)\n\tlocal outputBuffer = {}\n\n\tfor _, line in ipairs(lines) do\n\t\ttable.insert(outputBuffer, indent(line, indentLevel))\n\tend\n\n\treturn table.concat(outputBuffer, \"\\n\")\nend\n\nlocal logInfoMetatable = {}\n\n--[[\n\tAutomatic coercion to strings for LogInfo objects to enable debugging them\n\tmore easily.\n]]\nfunction logInfoMetatable:__tostring()\n\tlocal outputBuffer = { \"LogInfo {\" }\n\n\tlocal errorCount = #self.errors\n\tlocal warningCount = #self.warnings\n\tlocal infosCount = #self.infos\n\n\tif errorCount + warningCount + infosCount == 0 then\n\t\ttable.insert(outputBuffer, \"\\t(no messages)\")\n\tend\n\n\tif errorCount > 0 then\n\t\ttable.insert(outputBuffer, (\"\\tErrors (%d) {\"):format(errorCount))\n\t\ttable.insert(outputBuffer, indentLines(self.errors, 2))\n\t\ttable.insert(outputBuffer, \"\\t}\")\n\tend\n\n\tif warningCount > 0 then\n\t\ttable.insert(outputBuffer, (\"\\tWarnings (%d) {\"):format(warningCount))\n\t\ttable.insert(outputBuffer, indentLines(self.warnings, 2))\n\t\ttable.insert(outputBuffer, \"\\t}\")\n\tend\n\n\tif infosCount > 0 then\n\t\ttable.insert(outputBuffer, (\"\\tInfos (%d) {\"):format(infosCount))\n\t\ttable.insert(outputBuffer, indentLines(self.infos, 2))\n\t\ttable.insert(outputBuffer, \"\\t}\")\n\tend\n\n\ttable.insert(outputBuffer, \"}\")\n\n\treturn table.concat(outputBuffer, \"\\n\")\nend\n\nlocal function createLogInfo()\n\tlocal logInfo = {\n\t\terrors = {},\n\t\twarnings = {},\n\t\tinfos = {},\n\t}\n\n\tsetmetatable(logInfo, logInfoMetatable)\n\n\treturn logInfo\nend\n\nlocal Logging = {}\n\n--[[\n\tInvokes `callback`, capturing all output that happens during its execution.\n\n\tOutput will not go to stdout or stderr and will instead be put into a\n\tLogInfo object that is returned. If `callback` throws, the error will be\n\tbubbled up to the caller of `Logging.capture`.\n]]\nfunction Logging.capture(callback)\n\tlocal collector = createLogInfo()\n\n\tlocal wasOutputEnabled = outputEnabled\n\toutputEnabled = false\n\tcollectors[collector] = true\n\n\tlocal success, result = pcall(callback)\n\n\tcollectors[collector] = nil\n\toutputEnabled = wasOutputEnabled\n\n\tassert(success, result)\n\n\treturn collector\nend\n\n--[[\n\tIssues a warning with an automatically attached stack trace.\n]]\nfunction Logging.warn(messageTemplate, ...)\n\tlocal message = messageTemplate:format(...)\n\n\tfor collector in pairs(collectors) do\n\t\ttable.insert(collector.warnings, message)\n\tend\n\n\t-- debug.traceback inserts a leading newline, so we trim it here\n\tlocal trace = debug.traceback(\"\", 2):sub(2)\n\tlocal fullMessage = (\"%s\\n%s\"):format(message, indent(trace, 1))\n\n\tif outputEnabled then\n\t\twarn(fullMessage)\n\tend\nend\n\n--[[\n\tIssues a warning like `Logging.warn`, but only outputs once per call site.\n\n\tThis is useful for marking deprecated functions that might be called a lot;\n\tusing `warnOnce` instead of `warn` will reduce output noise while still\n\tcorrectly marking all call sites.\n]]\nfunction Logging.warnOnce(messageTemplate, ...)\n\tlocal trace = debug.traceback()\n\n\tif onceUsedLocations[trace] then\n\t\treturn\n\tend\n\n\tonceUsedLocations[trace] = true\n\tLogging.warn(messageTemplate, ...)\nend\n\nreturn Logging\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "GlobalConfig.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal GlobalConfig = require(script.Parent.GlobalConfig)\n\n\tit(\"should have the correct methods\", function()\n\t\texpect(GlobalConfig).to.be.ok()\n\t\texpect(GlobalConfig.set).to.be.ok()\n\t\texpect(GlobalConfig.get).to.be.ok()\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "GlobalConfig",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tExposes a single instance of a configuration as Roact's GlobalConfig.\n]]\n\nlocal Config = require(script.Parent.Config)\n\nreturn Config.new()\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "ElementUtils.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal ElementUtils = require(script.Parent.ElementUtils)\n\tlocal createElement = require(script.Parent.createElement)\n\tlocal createFragment = require(script.Parent.createFragment)\n\tlocal Type = require(script.Parent.Type)\n\n\tdescribe(\"iterateElements\", function()\n\t\tit(\"should iterate once for a single child\", function()\n\t\t\tlocal child = createElement(\"TextLabel\")\n\t\t\tlocal iterator = ElementUtils.iterateElements(child)\n\t\t\tlocal iteratedKey, iteratedChild = iterator()\n\t\t\t-- For single elements, the key should be UseParentKey\n\t\t\texpect(iteratedKey).to.equal(ElementUtils.UseParentKey)\n\t\t\texpect(iteratedChild).to.equal(child)\n\n\t\t\titeratedKey = iterator()\n\t\t\texpect(iteratedKey).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should iterate over tables\", function()\n\t\t\tlocal children = {\n\t\t\t\ta = createElement(\"TextLabel\"),\n\t\t\t\tb = createElement(\"TextLabel\"),\n\t\t\t}\n\n\t\t\tlocal seenChildren = {}\n\t\t\tlocal count = 0\n\n\t\t\tfor key, child in ElementUtils.iterateElements(children) do\n\t\t\t\texpect(typeof(key)).to.equal(\"string\")\n\t\t\t\texpect(Type.of(child)).to.equal(Type.Element)\n\t\t\t\tseenChildren[child] = key\n\t\t\t\tcount = count + 1\n\t\t\tend\n\n\t\t\texpect(count).to.equal(2)\n\t\t\texpect(seenChildren[children.a]).to.equal(\"a\")\n\t\t\texpect(seenChildren[children.b]).to.equal(\"b\")\n\t\tend)\n\n\t\tit(\"should return a zero-element iterator for booleans\", function()\n\t\t\tlocal booleanIterator = ElementUtils.iterateElements(false)\n\t\t\texpect(booleanIterator()).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should return a zero-element iterator for nil\", function()\n\t\t\tlocal nilIterator = ElementUtils.iterateElements(nil)\n\t\t\texpect(nilIterator()).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should throw if given an illegal value\", function()\n\t\t\texpect(function()\n\t\t\t\tElementUtils.iterateElements(1)\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tdescribe(\"getElementByKey\", function()\n\t\tit(\"should return nil for booleans\", function()\n\t\t\texpect(ElementUtils.getElementByKey(true, \"test\")).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should return nil for nil\", function()\n\t\t\texpect(ElementUtils.getElementByKey(nil, \"test\")).to.equal(nil)\n\t\tend)\n\n\t\tdescribe(\"single elements\", function()\n\t\t\tlocal element = createElement(\"TextLabel\")\n\n\t\t\tit(\"should return the element if the key is UseParentKey\", function()\n\t\t\t\texpect(ElementUtils.getElementByKey(element, ElementUtils.UseParentKey)).to.equal(element)\n\t\t\tend)\n\n\t\t\tit(\"should return nil if the key is not UseParentKey\", function()\n\t\t\t\texpect(ElementUtils.getElementByKey(element, \"test\")).to.equal(nil)\n\t\t\tend)\n\t\tend)\n\n\t\tit(\"should return the corresponding element from a table\", function()\n\t\t\tlocal children = {\n\t\t\t\ta = createElement(\"TextLabel\"),\n\t\t\t\tb = createElement(\"TextLabel\"),\n\t\t\t}\n\n\t\t\texpect(ElementUtils.getElementByKey(children, \"a\")).to.equal(children.a)\n\t\t\texpect(ElementUtils.getElementByKey(children, \"b\")).to.equal(children.b)\n\t\tend)\n\n\t\tit(\"should return nil if the key does not exist\", function()\n\t\t\tlocal children = createFragment({})\n\n\t\t\texpect(ElementUtils.getElementByKey(children, \"a\")).to.equal(nil)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "ElementUtils",
                        "ClassName": "ModuleScript",
                        "Source": "local Type = require(script.Parent.Type)\nlocal Symbol = require(script.Parent.Symbol)\n\nlocal function noop()\n\treturn nil\nend\n\nlocal ElementUtils = {}\n\n--[[\n\tA signal value indicating that a child should use its parent's key, because\n\tit has no key of its own.\n\n\tThis occurs when you return only one element from a function component or\n\tstateful render function.\n]]\nElementUtils.UseParentKey = Symbol.named(\"UseParentKey\")\n\n--[[\n\tReturns an iterator over the children of an element.\n\t`elementOrElements` may be one of:\n\t* a boolean\n\t* nil\n\t* a single element\n\t* a fragment\n\t* a table of elements\n\n\tIf `elementOrElements` is a boolean or nil, this will return an iterator with\n\tzero elements.\n\n\tIf `elementOrElements` is a single element, this will return an iterator with\n\tone element: a tuple where the first value is ElementUtils.UseParentKey, and\n\tthe second is the value of `elementOrElements`.\n\n\tIf `elementOrElements` is a fragment or a table, this will return an iterator\n\tover all the elements of the array.\n\n\tIf `elementOrElements` is none of the above, this function will throw.\n]]\nfunction ElementUtils.iterateElements(elementOrElements)\n\tlocal richType = Type.of(elementOrElements)\n\n\t-- Single child\n\tif richType == Type.Element then\n\t\tlocal called = false\n\n\t\treturn function()\n\t\t\tif called then\n\t\t\t\treturn nil\n\t\t\telse\n\t\t\t\tcalled = true\n\t\t\t\treturn ElementUtils.UseParentKey, elementOrElements\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal regularType = typeof(elementOrElements)\n\n\tif elementOrElements == nil or regularType == \"boolean\" then\n\t\treturn noop\n\tend\n\n\tif regularType == \"table\" then\n\t\treturn pairs(elementOrElements)\n\tend\n\n\terror(\"Invalid elements\")\nend\n\n--[[\n\tGets the child corresponding to a given key, respecting Roact's rules for\n\tchildren. Specifically:\n\t* If `elements` is nil or a boolean, this will return `nil`, regardless of\n\t\tthe key given.\n\t* If `elements` is a single element, this will return `nil`, unless the key\n\t\tis ElementUtils.UseParentKey.\n\t* If `elements` is a table of elements, this will return `elements[key]`.\n]]\nfunction ElementUtils.getElementByKey(elements, hostKey)\n\tif elements == nil or typeof(elements) == \"boolean\" then\n\t\treturn nil\n\tend\n\n\tif Type.of(elements) == Type.Element then\n\t\tif hostKey == ElementUtils.UseParentKey then\n\t\t\treturn elements\n\t\tend\n\n\t\treturn nil\n\tend\n\n\tif typeof(elements) == \"table\" then\n\t\treturn elements[hostKey]\n\tend\n\n\terror(\"Invalid elements\")\nend\n\nreturn ElementUtils\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "ElementKind.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal Portal = require(script.Parent.Portal)\n\tlocal Component = require(script.Parent.Component)\n\n\tlocal ElementKind = require(script.Parent.ElementKind)\n\n\tdescribe(\"of\", function()\n\t\tit(\"should return nil for non-table values\", function()\n\t\t\texpect(ElementKind.of(nil)).to.equal(nil)\n\t\t\texpect(ElementKind.of(5)).to.equal(nil)\n\t\t\texpect(ElementKind.of(newproxy(true))).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should return nil for table values without an ElementKind key\", function()\n\t\t\texpect(ElementKind.of({})).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should return the ElementKind from a table\", function()\n\t\t\tlocal value = {\n\t\t\t\t[ElementKind] = ElementKind.Stateful,\n\t\t\t}\n\n\t\t\texpect(ElementKind.of(value)).to.equal(ElementKind.Stateful)\n\t\tend)\n\tend)\n\n\tdescribe(\"fromComponent\", function()\n\t\tit(\"should handle host components\", function()\n\t\t\texpect(ElementKind.fromComponent(\"foo\")).to.equal(ElementKind.Host)\n\t\tend)\n\n\t\tit(\"should handle function components\", function()\n\t\t\tlocal function foo() end\n\n\t\t\texpect(ElementKind.fromComponent(foo)).to.equal(ElementKind.Function)\n\t\tend)\n\n\t\tit(\"should handle stateful components\", function()\n\t\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\t\texpect(ElementKind.fromComponent(Foo)).to.equal(ElementKind.Stateful)\n\t\tend)\n\n\t\tit(\"should handle portals\", function()\n\t\t\texpect(ElementKind.fromComponent(Portal)).to.equal(ElementKind.Portal)\n\t\tend)\n\n\t\tit(\"should return nil for invalid inputs\", function()\n\t\t\texpect(ElementKind.fromComponent(5)).to.equal(nil)\n\t\t\texpect(ElementKind.fromComponent(newproxy(true))).to.equal(nil)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "ElementKind",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tContains markers for annotating the type of an element.\n\n\tUse `ElementKind` as a key, and values from it as the value.\n\n\t\tlocal element = {\n\t\t\t[ElementKind] = ElementKind.Host,\n\t\t}\n]]\n\nlocal Symbol = require(script.Parent.Symbol)\nlocal strict = require(script.Parent.strict)\nlocal Portal = require(script.Parent.Portal)\n\nlocal ElementKind = newproxy(true)\n\nlocal ElementKindInternal = {\n\tPortal = Symbol.named(\"Portal\"),\n\tHost = Symbol.named(\"Host\"),\n\tFunction = Symbol.named(\"Function\"),\n\tStateful = Symbol.named(\"Stateful\"),\n\tFragment = Symbol.named(\"Fragment\"),\n}\n\nfunction ElementKindInternal.of(value)\n\tif typeof(value) ~= \"table\" then\n\t\treturn nil\n\tend\n\n\treturn value[ElementKind]\nend\n\nlocal componentTypesToKinds = {\n\t[\"string\"] = ElementKindInternal.Host,\n\t[\"function\"] = ElementKindInternal.Function,\n\t[\"table\"] = ElementKindInternal.Stateful,\n}\n\nfunction ElementKindInternal.fromComponent(component)\n\tif component == Portal then\n\t\treturn ElementKind.Portal\n\telse\n\t\treturn componentTypesToKinds[typeof(component)]\n\tend\nend\n\ngetmetatable(ElementKind).__index = ElementKindInternal\n\nstrict(ElementKindInternal, \"ElementKind\")\n\nreturn ElementKind\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Config.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal Config = require(script.Parent.Config)\n\n\tit(\"should accept valid configuration\", function()\n\t\tlocal config = Config.new()\n\t\tlocal values = config.get()\n\n\t\texpect(values.elementTracing).to.equal(false)\n\n\t\tconfig.set({\n\t\t\telementTracing = true,\n\t\t})\n\n\t\texpect(values.elementTracing).to.equal(true)\n\tend)\n\n\tit(\"should reject invalid configuration keys\", function()\n\t\tlocal config = Config.new()\n\n\t\tlocal badKey = \"garblegoop\"\n\n\t\tlocal ok, err = pcall(function()\n\t\t\tconfig.set({\n\t\t\t\t[badKey] = true,\n\t\t\t})\n\t\tend)\n\n\t\texpect(ok).to.equal(false)\n\n\t\t-- The error should mention our bad key somewhere.\n\t\texpect(err:find(badKey)).to.be.ok()\n\tend)\n\n\tit(\"should reject invalid configuration values\", function()\n\t\tlocal config = Config.new()\n\n\t\tlocal goodKey = \"elementTracing\"\n\t\tlocal badValue = \"Hello there!\"\n\n\t\tlocal ok, err = pcall(function()\n\t\t\tconfig.set({\n\t\t\t\t[goodKey] = badValue,\n\t\t\t})\n\t\tend)\n\n\t\texpect(ok).to.equal(false)\n\n\t\t-- The error should mention both our key and value\n\t\texpect(err:find(goodKey)).to.be.ok()\n\t\texpect(err:find(badValue)).to.be.ok()\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Config",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tExposes an interface to set global configuration values for Roact.\n\n\tConfiguration can only occur once, and should only be done by an application\n\tusing Roact, not a library.\n\n\tAny keys that aren't recognized will cause errors. Configuration is only\n\tintended for configuring Roact itself, not extensions or libraries.\n\n\tConfiguration is expected to be set immediately after loading Roact. Setting\n\tconfiguration values after an application starts may produce unpredictable\n\tbehavior.\n]]\n\n-- Every valid configuration value should be non-nil in this table.\nlocal defaultConfig = {\n\t-- Enables asserts for internal Roact APIs. Useful for debugging Roact itself.\n\t[\"internalTypeChecks\"] = false,\n\t-- Enables stricter type asserts for Roact's public API.\n\t[\"typeChecks\"] = false,\n\t-- Enables storage of `debug.traceback()` values on elements for debugging.\n\t[\"elementTracing\"] = false,\n\t-- Enables validation of component props in stateful components.\n\t[\"propValidation\"] = false,\n}\n\n-- Build a list of valid configuration values up for debug messages.\nlocal defaultConfigKeys = {}\nfor key in pairs(defaultConfig) do\n\ttable.insert(defaultConfigKeys, key)\nend\n\nlocal Config = {}\n\nfunction Config.new()\n\tlocal self = {}\n\n\tself._currentConfig = setmetatable({}, {\n\t\t__index = function(_, key)\n\t\t\tlocal message = (\"Invalid global configuration key %q. Valid configuration keys are: %s\"):format(\n\t\t\t\ttostring(key),\n\t\t\t\ttable.concat(defaultConfigKeys, \", \")\n\t\t\t)\n\n\t\t\terror(message, 3)\n\t\tend,\n\t})\n\n\t-- We manually bind these methods here so that the Config's methods can be\n\t-- used without passing in self, since they eventually get exposed on the\n\t-- root Roact object.\n\tself.set = function(...)\n\t\treturn Config.set(self, ...)\n\tend\n\n\tself.get = function(...)\n\t\treturn Config.get(self, ...)\n\tend\n\n\tself.scoped = function(...)\n\t\treturn Config.scoped(self, ...)\n\tend\n\n\tself.set(defaultConfig)\n\n\treturn self\nend\n\nfunction Config:set(configValues)\n\t-- Validate values without changing any configuration.\n\t-- We only want to apply this configuration if it's valid!\n\tfor key, value in pairs(configValues) do\n\t\tif defaultConfig[key] == nil then\n\t\t\tlocal message = (\"Invalid global configuration key %q (type %s). Valid configuration keys are: %s\"):format(\n\t\t\t\ttostring(key),\n\t\t\t\ttypeof(key),\n\t\t\t\ttable.concat(defaultConfigKeys, \", \")\n\t\t\t)\n\n\t\t\terror(message, 3)\n\t\tend\n\n\t\t-- Right now, all configuration values must be boolean.\n\t\tif typeof(value) ~= \"boolean\" then\n\t\t\tlocal message = (\n\t\t\t\t\"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false\"\n\t\t\t):format(tostring(value), typeof(value), tostring(key))\n\n\t\t\terror(message, 3)\n\t\tend\n\n\t\tself._currentConfig[key] = value\n\tend\nend\n\nfunction Config:get()\n\treturn self._currentConfig\nend\n\nfunction Config:scoped(configValues, callback)\n\tlocal previousValues = {}\n\tfor key, value in pairs(self._currentConfig) do\n\t\tpreviousValues[key] = value\n\tend\n\n\tself.set(configValues)\n\n\tlocal success, result = pcall(callback)\n\n\tself.set(previousValues)\n\n\tassert(success, result)\nend\n\nreturn Config\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "ComponentLifecyclePhase",
                        "ClassName": "ModuleScript",
                        "Source": "local Symbol = require(script.Parent.Symbol)\nlocal strict = require(script.Parent.strict)\n\nlocal ComponentLifecyclePhase = strict({\n\t-- Component methods\n\tInit = Symbol.named(\"init\"),\n\tRender = Symbol.named(\"render\"),\n\tShouldUpdate = Symbol.named(\"shouldUpdate\"),\n\tWillUpdate = Symbol.named(\"willUpdate\"),\n\tDidMount = Symbol.named(\"didMount\"),\n\tDidUpdate = Symbol.named(\"didUpdate\"),\n\tWillUnmount = Symbol.named(\"willUnmount\"),\n\n\t-- Phases describing reconciliation status\n\tReconcileChildren = Symbol.named(\"reconcileChildren\"),\n\tIdle = Symbol.named(\"idle\"),\n}, \"ComponentLifecyclePhase\")\n\nreturn ComponentLifecyclePhase\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Component.spec",
                        "Archivable": true,
                        "Children": [
                            {
                                "Name": "willUpdate.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked when updated via updateVirtualNode\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal willUpdateSpy = createSpy()\n\n\t\tMyComponent.willUpdate = willUpdateSpy.value\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal initialProps = {\n\t\t\ta = 5,\n\t\t}\n\t\tlocal initialElement = createElement(MyComponent, initialProps)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)\n\n\t\tlocal newProps = {\n\t\t\ta = 6,\n\t\t\tb = 2,\n\t\t}\n\t\tlocal newElement = createElement(MyComponent, newProps)\n\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\n\t\texpect(willUpdateSpy.callCount).to.equal(1)\n\n\t\tlocal values = willUpdateSpy:captureValues(\"self\", \"newProps\", \"newState\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\t\tassertDeepEqual(values.newProps, newProps)\n\t\tassertDeepEqual(values.newState, {})\n\tend)\n\n\tit(\"it should be invoked when updated via setState\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\t\tlocal setComponentState\n\n\t\tlocal willUpdateSpy = createSpy()\n\n\t\tMyComponent.willUpdate = willUpdateSpy.value\n\n\t\tfunction MyComponent:init()\n\t\t\tsetComponentState = function(state)\n\t\t\t\tself:setState(state)\n\t\t\tend\n\n\t\t\tself:setState({\n\t\t\t\tfoo = 1,\n\t\t\t})\n\t\tend\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal initialElement = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tnoopReconciler.mountVirtualNode(initialElement, hostParent, key)\n\n\t\texpect(willUpdateSpy.callCount).to.equal(0)\n\n\t\tsetComponentState({\n\t\t\tfoo = 2,\n\t\t})\n\n\t\texpect(willUpdateSpy.callCount).to.equal(1)\n\n\t\tlocal values = willUpdateSpy:captureValues(\"self\", \"newProps\", \"newState\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\t\tassertDeepEqual(values.newProps, {})\n\t\tassertDeepEqual(values.newState, {\n\t\t\tfoo = 2,\n\t\t})\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "willUnmount.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked when unmounted\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal willUnmountSpy = createSpy()\n\n\t\tMyComponent.willUnmount = willUnmountSpy.value\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal element = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\t\tnoopReconciler.unmountVirtualNode(node)\n\n\t\texpect(willUnmountSpy.callCount).to.equal(1)\n\n\t\tlocal values = willUnmountSpy:captureValues(\"self\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "validateProps.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal GlobalConfig = require(script.Parent.Parent.GlobalConfig)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked when mounted\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\t\tlocal validatePropsSpy = createSpy(function()\n\t\t\t\treturn true\n\t\t\tend)\n\n\t\t\tMyComponent.validateProps = validatePropsSpy.value\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(1)\n\t\tend)\n\tend)\n\n\tit(\"should be invoked when props change\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\t\tlocal validatePropsSpy = createSpy(function()\n\t\t\t\treturn true\n\t\t\tend)\n\n\t\t\tMyComponent.validateProps = validatePropsSpy.value\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent, { a = 1 })\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(1)\n\t\t\tvalidatePropsSpy:assertCalledWithDeepEqual({\n\t\t\t\ta = 1,\n\t\t\t})\n\n\t\t\tlocal newElement = createElement(MyComponent, { a = 2 })\n\t\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(2)\n\t\t\tvalidatePropsSpy:assertCalledWithDeepEqual({\n\t\t\t\ta = 2,\n\t\t\t})\n\t\tend)\n\tend)\n\n\tit(\"should not be invoked when state changes\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\t\tlocal setStateCallback = nil\n\t\t\tlocal validatePropsSpy = createSpy(function()\n\t\t\t\treturn true\n\t\t\tend)\n\n\t\t\tMyComponent.validateProps = validatePropsSpy.value\n\n\t\t\tfunction MyComponent:init()\n\t\t\t\tsetStateCallback = function(newState)\n\t\t\t\t\tself:setState(newState)\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent, { a = 1 })\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(1)\n\t\t\tvalidatePropsSpy:assertCalledWithDeepEqual({\n\t\t\t\ta = 1,\n\t\t\t})\n\n\t\t\tsetStateCallback({\n\t\t\t\tb = 1,\n\t\t\t})\n\n\t\t\texpect(validatePropsSpy.callCount).to.equal(1)\n\t\tend)\n\tend)\n\n\tit(\"should throw if validateProps is not a function\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\t\t\tMyComponent.validateProps = 1\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\texpect(function()\n\t\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tit(\"should throw if validateProps returns false\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\t\t\tMyComponent.validateProps = function()\n\t\t\t\treturn false\n\t\t\tend\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\texpect(function()\n\t\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tit(\"should include the component name in the error message\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\t\t\tMyComponent.validateProps = function()\n\t\t\t\treturn false\n\t\t\tend\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal success, error = pcall(function()\n\t\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\tend)\n\n\t\t\texpect(success).to.equal(false)\n\t\t\tlocal startIndex = error:find(\"MyComponent\")\n\t\t\texpect(startIndex).to.be.ok()\n\t\tend)\n\tend)\n\n\tit(\"should be invoked after defaultProps are applied\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\t\tlocal validatePropsSpy = createSpy(function()\n\t\t\t\treturn true\n\t\t\tend)\n\n\t\t\tMyComponent.validateProps = validatePropsSpy.value\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tMyComponent.defaultProps = {\n\t\t\t\tb = 2,\n\t\t\t}\n\n\t\t\tlocal element = createElement(MyComponent, { a = 1 })\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(1)\n\t\t\tvalidatePropsSpy:assertCalledWithDeepEqual({\n\t\t\t\ta = 1,\n\t\t\t\tb = 2,\n\t\t\t})\n\n\t\t\tlocal newElement = createElement(MyComponent, { a = 2 })\n\t\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(2)\n\t\t\tvalidatePropsSpy:assertCalledWithDeepEqual({\n\t\t\t\ta = 2,\n\t\t\t\tb = 2,\n\t\t\t})\n\t\tend)\n\tend)\n\n\tit(\"should not be invoked if the flag is off\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = false,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\t\tlocal validatePropsSpy = createSpy(function()\n\t\t\t\treturn true\n\t\t\tend)\n\n\t\t\tMyComponent.validateProps = validatePropsSpy.value\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent, { a = 1 })\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(0)\n\n\t\t\tlocal newElement = createElement(MyComponent, { a = 2 })\n\t\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(0)\n\t\tend)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "shouldUpdate.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked when props update\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal capturedProps\n\t\tlocal capturedState\n\t\tlocal shouldUpdateSpy = createSpy(function(self)\n\t\t\tcapturedProps = self.props\n\t\t\tcapturedState = self.state\n\n\t\t\treturn true\n\t\tend)\n\n\t\tMyComponent.shouldUpdate = shouldUpdateSpy.value\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal initialProps = {\n\t\t\ta = 5,\n\t\t}\n\t\tlocal initialElement = createElement(MyComponent, initialProps)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)\n\n\t\texpect(shouldUpdateSpy.callCount).to.equal(0)\n\n\t\tlocal newProps = {\n\t\t\ta = 6,\n\t\t\tb = 2,\n\t\t}\n\t\tlocal newElement = createElement(MyComponent, newProps)\n\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\n\t\texpect(shouldUpdateSpy.callCount).to.equal(1)\n\n\t\tlocal values = shouldUpdateSpy:captureValues(\"self\", \"newProps\", \"newState\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\n\t\tassertDeepEqual(values.newProps, newProps)\n\n\t\tassertDeepEqual(capturedProps, initialProps)\n\n\t\texpect(values.newState).to.equal(capturedState)\n\t\tassertDeepEqual(capturedState, {})\n\tend)\n\n\tit(\"should be invoked when state is updated\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal initialState = {\n\t\t\ta = 1,\n\t\t}\n\n\t\tlocal setState\n\t\tlocal initState\n\t\tfunction MyComponent:init()\n\t\t\tsetState = function(...)\n\t\t\t\treturn self:setState(...)\n\t\t\tend\n\n\t\t\tself:setState(initialState)\n\n\t\t\tinitState = self.state\n\t\tend\n\n\t\tlocal capturedProps\n\t\tlocal capturedState\n\t\tlocal shouldUpdateSpy = createSpy(function(self)\n\t\t\tcapturedProps = self.props\n\t\t\tcapturedState = self.state\n\n\t\t\treturn true\n\t\tend)\n\n\t\tMyComponent.shouldUpdate = shouldUpdateSpy.value\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal initialElement = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tnoopReconciler.mountVirtualNode(initialElement, hostParent, key)\n\n\t\texpect(shouldUpdateSpy.callCount).to.equal(0)\n\n\t\tlocal newState = {\n\t\t\ta = 2,\n\t\t\tb = 3,\n\t\t}\n\n\t\tsetState(newState)\n\n\t\texpect(shouldUpdateSpy.callCount).to.equal(1)\n\n\t\tlocal values = shouldUpdateSpy:captureValues(\"self\", \"newProps\", \"newState\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\n\t\texpect(values.newProps).to.equal(capturedProps)\n\t\tassertDeepEqual(capturedProps, {})\n\n\t\tassertDeepEqual(capturedState, initialState)\n\t\texpect(capturedState).to.equal(initState)\n\t\tassertDeepEqual(values.newState, newState)\n\tend)\n\n\tit(\"should not abort an update when returning true\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tfunction MyComponent:shouldUpdate()\n\t\t\treturn true\n\t\tend\n\n\t\tlocal renderSpy = createSpy()\n\n\t\tMyComponent.render = renderSpy.value\n\n\t\tlocal initialElement = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)\n\n\t\texpect(renderSpy.callCount).to.equal(1)\n\n\t\tlocal newElement = createElement(MyComponent)\n\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\n\t\texpect(renderSpy.callCount).to.equal(2)\n\tend)\n\n\tit(\"should abort an update when retuning false\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tfunction MyComponent:shouldUpdate()\n\t\t\treturn false\n\t\tend\n\n\t\tlocal renderSpy = createSpy()\n\n\t\tMyComponent.render = renderSpy.value\n\n\t\tlocal initialElement = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)\n\n\t\texpect(renderSpy.callCount).to.equal(1)\n\n\t\tlocal newElement = createElement(MyComponent)\n\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\n\t\texpect(renderSpy.callCount).to.equal(1)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "setState.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal None = require(script.Parent.Parent.None)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tdescribe(\"setState\", function()\n\t\tit(\"should not trigger an extra update when called in init\", function()\n\t\t\tlocal renderCount = 0\n\t\t\tlocal updateCount = 0\n\t\t\tlocal capturedState\n\n\t\t\tlocal InitComponent = Component:extend(\"InitComponent\")\n\n\t\t\tfunction InitComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\ta = 1,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tfunction InitComponent:willUpdate()\n\t\t\t\tupdateCount = updateCount + 1\n\t\t\tend\n\n\t\t\tfunction InitComponent:render()\n\t\t\t\trenderCount = renderCount + 1\n\t\t\t\tcapturedState = self.state\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal initElement = createElement(InitComponent)\n\n\t\t\tnoopReconciler.mountVirtualTree(initElement)\n\n\t\t\texpect(renderCount).to.equal(1)\n\t\t\texpect(updateCount).to.equal(0)\n\t\t\texpect(capturedState.a).to.equal(1)\n\t\tend)\n\n\t\tit(\"should throw when called in render\", function()\n\t\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\n\t\t\tfunction TestComponent:render()\n\t\t\t\tself:setState({\n\t\t\t\t\ta = 1,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal renderElement = createElement(TestComponent)\n\n\t\t\tlocal success, result = pcall(noopReconciler.mountVirtualTree, renderElement)\n\n\t\t\texpect(success).to.equal(false)\n\t\t\texpect(result:match(\"render\")).to.be.ok()\n\t\t\texpect(result:match(\"TestComponent\")).to.be.ok()\n\t\tend)\n\n\t\tit(\"should throw when called in shouldUpdate\", function()\n\t\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\n\t\t\tfunction TestComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction TestComponent:shouldUpdate()\n\t\t\t\tself:setState({\n\t\t\t\t\ta = 1,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal initialElement = createElement(TestComponent)\n\t\t\tlocal updatedElement = createElement(TestComponent)\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(initialElement)\n\n\t\t\tlocal success, result = pcall(noopReconciler.updateVirtualTree, tree, updatedElement)\n\n\t\t\texpect(success).to.equal(false)\n\t\t\texpect(result:match(\"shouldUpdate\")).to.be.ok()\n\t\t\texpect(result:match(\"TestComponent\")).to.be.ok()\n\t\tend)\n\n\t\tit(\"should throw when called in willUpdate\", function()\n\t\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\n\t\t\tfunction TestComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction TestComponent:willUpdate()\n\t\t\t\tself:setState({\n\t\t\t\t\ta = 1,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal initialElement = createElement(TestComponent)\n\t\t\tlocal updatedElement = createElement(TestComponent)\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(initialElement)\n\n\t\t\tlocal success, result = pcall(noopReconciler.updateVirtualTree, tree, updatedElement)\n\n\t\t\texpect(success).to.equal(false)\n\t\t\texpect(result:match(\"willUpdate\")).to.be.ok()\n\t\t\texpect(result:match(\"TestComponent\")).to.be.ok()\n\t\tend)\n\n\t\tit(\"should throw when called in willUnmount\", function()\n\t\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\n\t\t\tfunction TestComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction TestComponent:willUnmount()\n\t\t\t\tself:setState({\n\t\t\t\t\ta = 1,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(TestComponent)\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(element)\n\n\t\t\tlocal success, result = pcall(noopReconciler.unmountVirtualTree, tree)\n\n\t\t\texpect(success).to.equal(false)\n\t\t\texpect(result:match(\"willUnmount\")).to.be.ok()\n\t\t\texpect(result:match(\"TestComponent\")).to.be.ok()\n\t\tend)\n\n\t\tit(\"should remove values from state when the value is None\", function()\n\t\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\t\t\tlocal setStateCallback, getStateCallback\n\n\t\t\tfunction TestComponent:init()\n\t\t\t\tsetStateCallback = function(newState)\n\t\t\t\t\tself:setState(newState)\n\t\t\t\tend\n\n\t\t\t\tgetStateCallback = function()\n\t\t\t\t\treturn self.state\n\t\t\t\tend\n\n\t\t\t\tself:setState({\n\t\t\t\t\tvalue = 0,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tfunction TestComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(TestComponent)\n\t\t\tlocal instance = noopReconciler.mountVirtualNode(element, nil, \"Test\")\n\n\t\t\texpect(getStateCallback().value).to.equal(0)\n\n\t\t\tsetStateCallback({\n\t\t\t\tvalue = None,\n\t\t\t})\n\n\t\t\texpect(getStateCallback().value).to.equal(nil)\n\n\t\t\tnoopReconciler.unmountVirtualNode(instance)\n\t\tend)\n\n\t\tit(\"should invoke functions to compute a partial state\", function()\n\t\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\t\t\tlocal setStateCallback, getStateCallback, getPropsCallback\n\n\t\t\tfunction TestComponent:init()\n\t\t\t\tsetStateCallback = function(newState)\n\t\t\t\t\tself:setState(newState)\n\t\t\t\tend\n\n\t\t\t\tgetStateCallback = function()\n\t\t\t\t\treturn self.state\n\t\t\t\tend\n\n\t\t\t\tgetPropsCallback = function()\n\t\t\t\t\treturn self.props\n\t\t\t\tend\n\n\t\t\t\tself:setState({\n\t\t\t\t\tvalue = 0,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tfunction TestComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(TestComponent)\n\t\t\tlocal instance = noopReconciler.mountVirtualNode(element, nil, \"Test\")\n\n\t\t\texpect(getStateCallback().value).to.equal(0)\n\n\t\t\tsetStateCallback(function(state, props)\n\t\t\t\texpect(state).to.equal(getStateCallback())\n\t\t\t\texpect(props).to.equal(getPropsCallback())\n\n\t\t\t\treturn {\n\t\t\t\t\tvalue = state.value + 1,\n\t\t\t\t}\n\t\t\tend)\n\n\t\t\texpect(getStateCallback().value).to.equal(1)\n\n\t\t\tnoopReconciler.unmountVirtualNode(instance)\n\t\tend)\n\n\t\tit(\"should cancel rendering if the function returns nil\", function()\n\t\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\t\t\tlocal setStateCallback\n\t\t\tlocal renderCount = 0\n\n\t\t\tfunction TestComponent:init()\n\t\t\t\tsetStateCallback = function(newState)\n\t\t\t\t\tself:setState(newState)\n\t\t\t\tend\n\n\t\t\t\tself:setState({\n\t\t\t\t\tvalue = 0,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tfunction TestComponent:render()\n\t\t\t\trenderCount = renderCount + 1\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(TestComponent)\n\t\t\tlocal instance = noopReconciler.mountVirtualNode(element, nil, \"Test\")\n\t\t\texpect(renderCount).to.equal(1)\n\n\t\t\tsetStateCallback(function(_state, _props)\n\t\t\t\treturn nil\n\t\t\tend)\n\n\t\t\texpect(renderCount).to.equal(1)\n\n\t\t\tnoopReconciler.unmountVirtualNode(instance)\n\t\tend)\n\tend)\n\n\tdescribe(\"setState suspension\", function()\n\t\tit(\"should defer setState triggered while reconciling\", function()\n\t\t\tlocal Child = Component:extend(\"Child\")\n\t\t\tlocal getParentStateCallback\n\n\t\t\tfunction Child:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction Child:didMount()\n\t\t\t\tself.props.callback()\n\t\t\tend\n\n\t\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\t\tfunction Parent:init()\n\t\t\t\tgetParentStateCallback = function()\n\t\t\t\t\treturn self.state\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction Parent:render()\n\t\t\t\treturn createElement(Child, {\n\t\t\t\t\tcallback = function()\n\t\t\t\t\t\tself:setState({\n\t\t\t\t\t\t\tfoo = \"bar\",\n\t\t\t\t\t\t})\n\t\t\t\t\tend,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(Parent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal result = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(result).to.be.ok()\n\t\t\texpect(getParentStateCallback().foo).to.equal(\"bar\")\n\t\tend)\n\n\t\tit(\"should defer setState triggered while reconciling during an update\", function()\n\t\t\tlocal Child = Component:extend(\"Child\")\n\t\t\tlocal getParentStateCallback\n\n\t\t\tfunction Child:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction Child:didUpdate()\n\t\t\t\tself.props.callback()\n\t\t\tend\n\n\t\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\t\tfunction Parent:init()\n\t\t\t\tgetParentStateCallback = function()\n\t\t\t\t\treturn self.state\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction Parent:render()\n\t\t\t\treturn createElement(Child, {\n\t\t\t\t\tcallback = function()\n\t\t\t\t\t\t-- This guards against a stack overflow that would be OUR fault\n\t\t\t\t\t\tif not self.state.foo then\n\t\t\t\t\t\t\tself:setState({\n\t\t\t\t\t\t\t\tfoo = \"bar\",\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\tend\n\t\t\t\t\tend,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(Parent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal result = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(result).to.be.ok()\n\t\t\texpect(getParentStateCallback().foo).to.equal(nil)\n\n\t\t\tresult = noopReconciler.updateVirtualNode(result, createElement(Parent))\n\n\t\t\texpect(result).to.be.ok()\n\t\t\texpect(getParentStateCallback().foo).to.equal(\"bar\")\n\n\t\t\tnoopReconciler.unmountVirtualNode(result)\n\t\tend)\n\n\t\tit(\"should combine pending state changes properly\", function()\n\t\t\tlocal Child = Component:extend(\"Child\")\n\t\t\tlocal getParentStateCallback\n\n\t\t\tfunction Child:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction Child:didMount()\n\t\t\t\tself.props.callback(\"foo\", 1)\n\t\t\t\tself.props.callback(\"bar\", 3)\n\t\t\tend\n\n\t\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\t\tfunction Parent:init()\n\t\t\t\tgetParentStateCallback = function()\n\t\t\t\t\treturn self.state\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction Parent:render()\n\t\t\t\treturn createElement(Child, {\n\t\t\t\t\tcallback = function(key, value)\n\t\t\t\t\t\tself:setState({\n\t\t\t\t\t\t\t[key] = value,\n\t\t\t\t\t\t})\n\t\t\t\t\tend,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(Parent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal result = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(result).to.be.ok()\n\t\t\texpect(getParentStateCallback().foo).to.equal(1)\n\t\t\texpect(getParentStateCallback().bar).to.equal(3)\n\n\t\t\tnoopReconciler.unmountVirtualNode(result)\n\t\tend)\n\n\t\tit(\"should abort properly when functional setState returns nil while deferred\", function()\n\t\t\tlocal Child = Component:extend(\"Child\")\n\n\t\t\tfunction Child:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction Child:didMount()\n\t\t\t\tself.props.callback()\n\t\t\tend\n\n\t\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\t\tlocal renderSpy = createSpy(function(self)\n\t\t\t\treturn createElement(Child, {\n\t\t\t\t\tcallback = function()\n\t\t\t\t\t\tself:setState(function()\n\t\t\t\t\t\t\t-- abort the setState\n\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\tend)\n\t\t\t\t\tend,\n\t\t\t\t})\n\t\t\tend)\n\n\t\t\tParent.render = renderSpy.value\n\n\t\t\tlocal element = createElement(Parent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal result = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(result).to.be.ok()\n\t\t\texpect(renderSpy.callCount).to.equal(1)\n\n\t\t\tnoopReconciler.unmountVirtualNode(result)\n\t\tend)\n\n\t\tit(\"should still apply pending state if a subsequent state update was aborted\", function()\n\t\t\tlocal Child = Component:extend(\"Child\")\n\t\t\tlocal getParentStateCallback\n\n\t\t\tfunction Child:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction Child:didMount()\n\t\t\t\tself.props.callback(function()\n\t\t\t\t\treturn {\n\t\t\t\t\t\tfoo = 1,\n\t\t\t\t\t}\n\t\t\t\tend)\n\t\t\t\tself.props.callback(function()\n\t\t\t\t\treturn nil\n\t\t\t\tend)\n\t\t\tend\n\n\t\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\t\tfunction Parent:init()\n\t\t\t\tgetParentStateCallback = function()\n\t\t\t\t\treturn self.state\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction Parent:render()\n\t\t\t\treturn createElement(Child, {\n\t\t\t\t\tcallback = function(stateUpdater)\n\t\t\t\t\t\tself:setState(stateUpdater)\n\t\t\t\t\tend,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(Parent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal result = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(result).to.be.ok()\n\t\t\texpect(getParentStateCallback().foo).to.equal(1)\n\n\t\t\tnoopReconciler.unmountVirtualNode(result)\n\t\tend)\n\n\t\tit(\"should not re-process new state when pending state is present after update\", function()\n\t\t\tlocal setComponentState\n\t\t\tlocal getComponentState\n\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\t\tfunction MyComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\thasUpdatedOnce = false,\n\t\t\t\t\tcounter = 0,\n\t\t\t\t})\n\n\t\t\t\tsetComponentState = function(mapState)\n\t\t\t\t\tself:setState(mapState)\n\t\t\t\tend\n\n\t\t\t\tgetComponentState = function()\n\t\t\t\t\treturn self.state\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction MyComponent:didUpdate()\n\t\t\t\tif self.state.hasUpdatedOnce == false then\n\t\t\t\t\tself:setState({\n\t\t\t\t\t\thasUpdatedOnce = true,\n\t\t\t\t\t})\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(getComponentState().hasUpdatedOnce).to.equal(false)\n\t\t\texpect(getComponentState().counter).to.equal(0)\n\n\t\t\tsetComponentState(function(state)\n\t\t\t\treturn {\n\t\t\t\t\tcounter = state.counter + 1,\n\t\t\t\t}\n\t\t\tend)\n\n\t\t\texpect(getComponentState().hasUpdatedOnce).to.equal(true)\n\t\t\texpect(getComponentState().counter).to.equal(1)\n\t\tend)\n\n\t\tit(\"should throw when an infinite update is triggered\", function()\n\t\t\tlocal InfiniteUpdater = Component:extend(\"InfiniteUpdater\")\n\n\t\t\tfunction InfiniteUpdater:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction InfiniteUpdater:didMount()\n\t\t\t\tself:setState({})\n\t\t\tend\n\n\t\t\tfunction InfiniteUpdater:didUpdate()\n\t\t\t\tself:setState({})\n\t\t\tend\n\n\t\t\tlocal element = createElement(InfiniteUpdater)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal success, result = pcall(noopReconciler.mountVirtualNode, element, hostParent, key)\n\n\t\t\texpect(success).to.equal(false)\n\t\t\texpect(result:find(\"InfiniteUpdater\")).to.be.ok()\n\t\t\texpect(result:find(\"reached the setState update recursion limit\")).to.be.ok()\n\t\tend)\n\n\t\titSKIP(\"should process single updates with both new and pending state\", function()\n\t\t\t--[[\n\t\t\t\tThis situation shouldn't be possible currently, but the implementation\n\t\t\t\tshould support it for future update de-duplication\n\t\t\t]]\n\t\tend)\n\n\t\tit(\"should call trigger update after didMount when setting state in didMount\", function()\n\t\t\t--[[\n\t\t\t\tBefore setState suspension, it was possible to call setState in didMount but it would\n\t\t\t\tnot actually finish resolving didMount until after the entire update.\n\n\t\t\t\tThis is theoretically problematic, as it means that lifecycle methods like didUpdate\n\t\t\t\tcould be called before didMount is finished. setState suspension resolves this by\n\t\t\t\tsuspending state updates made in didMount and didUpdate as well as reconciliation\n\t\t\t]]\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\t\tfunction MyComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tstatus = \"initial mount\",\n\t\t\t\t})\n\n\t\t\t\tself.isMounted = false\n\t\t\tend\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction MyComponent:didMount()\n\t\t\t\tself:setState({\n\t\t\t\t\tstatus = \"mounted\",\n\t\t\t\t})\n\n\t\t\t\tself.isMounted = true\n\t\t\tend\n\n\t\t\tfunction MyComponent:didUpdate(_oldProps, oldState)\n\t\t\t\texpect(oldState.status).to.equal(\"initial mount\")\n\t\t\t\texpect(self.state.status).to.equal(\"mounted\")\n\n\t\t\t\texpect(self.isMounted).to.equal(true)\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal result = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(result).to.be.ok()\n\t\tend)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "render.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should throw on mount if not overridden\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal element = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tlocal success, result = pcall(function()\n\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\tend)\n\n\t\texpect(success).to.equal(false)\n\t\texpect(result:match(\"MyComponent\")).to.be.ok()\n\t\texpect(result:match(\"render\")).to.be.ok()\n\tend)\n\n\tit(\"should be invoked when a component is mounted\", function()\n\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\tlocal capturedProps\n\t\tlocal capturedState\n\t\tlocal renderSpy = createSpy(function(self)\n\t\t\tcapturedProps = self.props\n\t\t\tcapturedState = self.state\n\t\tend)\n\t\tFoo.render = renderSpy.value\n\n\t\tlocal element = createElement(Foo)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Foo Test\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\texpect(renderSpy.callCount).to.equal(1)\n\n\t\tlocal renderArguments = renderSpy:captureValues(\"self\")\n\n\t\texpect(Type.of(renderArguments.self)).to.equal(Type.StatefulComponentInstance)\n\t\tassertDeepEqual(capturedProps, {})\n\t\tassertDeepEqual(capturedState, {})\n\tend)\n\n\tit(\"should be invoked when a component is updated via props\", function()\n\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\tlocal capturedProps\n\t\tlocal capturedState\n\t\tlocal renderSpy = createSpy(function(self)\n\t\t\tcapturedProps = self.props\n\t\t\tcapturedState = self.state\n\t\tend)\n\t\tFoo.render = renderSpy.value\n\n\t\tlocal initialProps = {\n\t\t\ta = 2,\n\t\t}\n\t\tlocal element = createElement(Foo, initialProps)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Foo Test\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\texpect(renderSpy.callCount).to.equal(1)\n\n\t\tlocal firstRenderArguments = renderSpy:captureValues(\"self\")\n\t\tlocal firstProps = capturedProps\n\t\tlocal firstState = capturedState\n\n\t\texpect(Type.of(firstRenderArguments.self)).to.equal(Type.StatefulComponentInstance)\n\t\tassertDeepEqual(firstProps, initialProps)\n\t\tassertDeepEqual(firstState, {})\n\n\t\tlocal updatedProps = {\n\t\t\ta = 3,\n\t\t}\n\t\tlocal newElement = createElement(Foo, updatedProps)\n\n\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\n\t\texpect(renderSpy.callCount).to.equal(2)\n\n\t\tlocal secondRenderArguments = renderSpy:captureValues(\"self\")\n\t\tlocal secondProps = capturedProps\n\t\tlocal secondState = capturedState\n\n\t\texpect(Type.of(secondRenderArguments.self)).to.equal(Type.StatefulComponentInstance)\n\t\texpect(secondProps).never.to.equal(firstProps)\n\t\tassertDeepEqual(secondProps, updatedProps)\n\t\texpect(secondState).to.equal(firstState)\n\tend)\n\n\tit(\"should be invoked when a component is updated via state\", function()\n\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\tlocal setState\n\t\tfunction Foo:init()\n\t\t\tsetState = function(...)\n\t\t\t\treturn self:setState(...)\n\t\t\tend\n\t\tend\n\n\t\tlocal capturedProps\n\t\tlocal capturedState\n\t\tlocal renderSpy = createSpy(function(self)\n\t\t\tcapturedProps = self.props\n\t\t\tcapturedState = self.state\n\t\tend)\n\t\tFoo.render = renderSpy.value\n\n\t\tlocal element = createElement(Foo)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Foo Test\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\texpect(renderSpy.callCount).to.equal(1)\n\n\t\tlocal firstRenderArguments = renderSpy:captureValues(\"self\")\n\t\tlocal firstProps = capturedProps\n\t\tlocal firstState = capturedState\n\n\t\texpect(Type.of(firstRenderArguments.self)).to.equal(Type.StatefulComponentInstance)\n\n\t\tsetState({})\n\n\t\texpect(renderSpy.callCount).to.equal(2)\n\n\t\tlocal renderArguments = renderSpy:captureValues(\"self\")\n\n\t\texpect(Type.of(renderArguments.self)).to.equal(Type.StatefulComponentInstance)\n\t\texpect(capturedProps).to.equal(firstProps)\n\t\texpect(capturedState).never.to.equal(firstState)\n\tend)\n\n\titSKIP(\"Test defaultProps on initial render\", function() end)\n\titSKIP(\"Test defaultProps on prop update\", function() end)\n\titSKIP(\"Test defaultProps on state update\", function() end)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "legacyContext.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be provided as a mutable self._context in Component:init\", function()\n\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\tfunction Provider:init()\n\t\t\tself._context.foo = \"bar\"\n\t\tend\n\n\t\tfunction Provider:render() end\n\n\t\tlocal element = createElement(Provider)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Provider\"\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\tlocal expectedContext = {\n\t\t\tfoo = \"bar\",\n\t\t}\n\n\t\tassertDeepEqual(node.legacyContext, expectedContext)\n\tend)\n\n\tit(\"should be inherited from parent stateful nodes\", function()\n\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\tlocal capturedContext\n\t\tfunction Consumer:init()\n\t\t\tcapturedContext = self._context\n\t\tend\n\n\t\tfunction Consumer:render() end\n\n\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\tfunction Parent:render()\n\t\t\treturn createElement(Consumer)\n\t\tend\n\n\t\tlocal element = createElement(Parent)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Parent\"\n\t\tlocal context = {\n\t\t\thello = \"world\",\n\t\t\tvalue = 6,\n\t\t}\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)\n\n\t\texpect(capturedContext).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(node.legacyContext)\n\t\tassertDeepEqual(node.legacyContext, context)\n\t\tassertDeepEqual(capturedContext, context)\n\tend)\n\n\tit(\"should be inherited from parent function nodes\", function()\n\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\tlocal capturedContext\n\t\tfunction Consumer:init()\n\t\t\tcapturedContext = self._context\n\t\tend\n\n\t\tfunction Consumer:render() end\n\n\t\tlocal function Parent()\n\t\t\treturn createElement(Consumer)\n\t\tend\n\n\t\tlocal element = createElement(Parent)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Parent\"\n\t\tlocal context = {\n\t\t\thello = \"world\",\n\t\t\tvalue = 6,\n\t\t}\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)\n\n\t\texpect(capturedContext).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(node.legacyContext)\n\t\tassertDeepEqual(node.legacyContext, context)\n\t\tassertDeepEqual(capturedContext, context)\n\tend)\n\n\tit(\"should contain values put into the tree by parent nodes\", function()\n\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\tlocal capturedContext\n\t\tfunction Consumer:init()\n\t\t\tcapturedContext = self._context\n\t\tend\n\n\t\tfunction Consumer:render() end\n\n\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\tfunction Provider:init()\n\t\t\tself._context.frob = \"ulator\"\n\t\tend\n\n\t\tfunction Provider:render()\n\t\t\treturn createElement(Consumer)\n\t\tend\n\n\t\tlocal element = createElement(Provider)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Consumer\"\n\t\tlocal context = {\n\t\t\tdont = \"try it\",\n\t\t}\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)\n\n\t\tlocal initialContext = {\n\t\t\tdont = \"try it\",\n\t\t}\n\n\t\tlocal expectedContext = {\n\t\t\tdont = \"try it\",\n\t\t\tfrob = \"ulator\",\n\t\t}\n\n\t\t-- Because components mutate context, we're careful with equality\n\t\texpect(node.legacyContext).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(node.legacyContext)\n\n\t\tassertDeepEqual(context, initialContext)\n\t\tassertDeepEqual(node.legacyContext, expectedContext)\n\t\tassertDeepEqual(capturedContext, expectedContext)\n\tend)\n\n\tit(\"should transfer context to children that are replaced\", function()\n\t\tlocal ConsumerA = Component:extend(\"ConsumerA\")\n\n\t\tlocal capturedContextA\n\t\tfunction ConsumerA:init()\n\t\t\tself._context.A = \"hello\"\n\n\t\t\tcapturedContextA = self._context\n\t\tend\n\n\t\tfunction ConsumerA:render() end\n\n\t\tlocal ConsumerB = Component:extend(\"ConsumerB\")\n\n\t\tlocal capturedContextB\n\t\tfunction ConsumerB:init()\n\t\t\tself._context.B = \"hello\"\n\n\t\t\tcapturedContextB = self._context\n\t\tend\n\n\t\tfunction ConsumerB:render() end\n\n\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\tfunction Provider:init()\n\t\t\tself._context.frob = \"ulator\"\n\t\tend\n\n\t\tfunction Provider:render()\n\t\t\tlocal useConsumerB = self.props.useConsumerB\n\n\t\t\tif useConsumerB then\n\t\t\t\treturn createElement(ConsumerB)\n\t\t\telse\n\t\t\t\treturn createElement(ConsumerA)\n\t\t\tend\n\t\tend\n\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Consumer\"\n\n\t\tlocal element = createElement(Provider)\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\tlocal expectedContextA = {\n\t\t\tfrob = \"ulator\",\n\t\t\tA = \"hello\",\n\t\t}\n\n\t\tassertDeepEqual(capturedContextA, expectedContextA)\n\n\t\tlocal expectedContextB = {\n\t\t\tfrob = \"ulator\",\n\t\t\tB = \"hello\",\n\t\t}\n\n\t\tlocal replacedElement = createElement(Provider, {\n\t\t\tuseConsumerB = true,\n\t\t})\n\t\tnoopReconciler.updateVirtualNode(node, replacedElement)\n\n\t\tassertDeepEqual(capturedContextB, expectedContextB)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "init.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked with props when mounted\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal initSpy = createSpy()\n\n\t\tMyComponent.init = initSpy.value\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal props = {\n\t\t\ta = 5,\n\t\t}\n\t\tlocal element = createElement(MyComponent, props)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Some Component Key\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\texpect(initSpy.callCount).to.equal(1)\n\n\t\tlocal values = initSpy:captureValues(\"self\", \"props\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\t\texpect(typeof(values.props)).to.equal(\"table\")\n\t\tassertDeepEqual(values.props, props)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "getElementTraceback.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal GlobalConfig = require(script.Parent.Parent.GlobalConfig)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should return stack traces in initial renders\", function()\n\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\n\t\tlocal stackTrace\n\t\tfunction TestComponent:init()\n\t\t\tstackTrace = self:getElementTraceback()\n\t\tend\n\n\t\tfunction TestComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal config = {\n\t\t\telementTracing = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal element = createElement(TestComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Some key\"\n\n\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\tend)\n\n\t\texpect(stackTrace).to.be.a(\"string\")\n\tend)\n\n\titSKIP(\"it should return an updated stack trace after an update\", function() end)\n\n\tit(\"should return nil when elementTracing is off\", function()\n\t\tlocal stackTrace = nil\n\n\t\tlocal config = {\n\t\t\telementTracing = false,\n\t\t}\n\n\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\n\t\tfunction TestComponent:init()\n\t\t\tstackTrace = self:getElementTraceback()\n\t\tend\n\n\t\tfunction TestComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal element = createElement(TestComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Some key\"\n\n\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\tend)\n\n\t\texpect(stackTrace).to.equal(nil)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "getDerivedStateFromProps.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createFragment = require(script.Parent.Parent.createFragment)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked on initial mount\", function()\n\t\tlocal getDerivedSpy = createSpy()\n\t\tlocal WithDerivedState = Component:extend(\"WithDerivedState\")\n\n\t\tWithDerivedState.getDerivedStateFromProps = getDerivedSpy.value\n\n\t\tfunction WithDerivedState:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal element = createElement(WithDerivedState, {\n\t\t\tsomeProp = 1,\n\t\t})\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"WithDerivedState\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\texpect(getDerivedSpy.callCount).to.equal(1)\n\n\t\tlocal values = getDerivedSpy:captureValues(\"props\", \"state\")\n\n\t\tassertDeepEqual(values.props, { someProp = 1 })\n\t\tassertDeepEqual(values.state, {})\n\tend)\n\n\tit(\"should be invoked when updated via props\", function()\n\t\tlocal getDerivedSpy = createSpy()\n\t\tlocal WithDerivedState = Component:extend(\"WithDerivedState\")\n\n\t\tWithDerivedState.getDerivedStateFromProps = getDerivedSpy.value\n\n\t\tfunction WithDerivedState:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"WithDerivedState\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(\n\t\t\tcreateElement(WithDerivedState, {\n\t\t\t\tsomeProp = 1,\n\t\t\t}),\n\t\t\thostParent,\n\t\t\thostKey\n\t\t)\n\n\t\tnoopReconciler.updateVirtualNode(\n\t\t\tnode,\n\t\t\tcreateElement(WithDerivedState, {\n\t\t\t\tsomeProp = 2,\n\t\t\t})\n\t\t)\n\n\t\texpect(getDerivedSpy.callCount).to.equal(2)\n\n\t\tlocal values = getDerivedSpy:captureValues(\"props\", \"state\")\n\n\t\tassertDeepEqual(values.props, { someProp = 2 })\n\t\tassertDeepEqual(values.state, {})\n\tend)\n\n\tit(\"should be invoked when updated via state\", function()\n\t\tlocal getDerivedSpy = createSpy()\n\t\tlocal WithDerivedState = Component:extend(\"WithDerivedState\")\n\n\t\tWithDerivedState.getDerivedStateFromProps = getDerivedSpy.value\n\n\t\tfunction WithDerivedState:init()\n\t\t\tself:setState({\n\t\t\t\tsomeState = 1,\n\t\t\t})\n\t\tend\n\n\t\tfunction WithDerivedState:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal element = createElement(WithDerivedState)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"WithDerivedState\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\tnoopReconciler.updateVirtualNode(node, element, {\n\t\t\tsomeState = 2,\n\t\t})\n\n\t\t-- getDerivedStateFromProps will be called:\n\t\t-- * Once on empty props\n\t\t-- * Once during the self:setState in init\n\t\t-- * Once more, defensively, on the resulting state AFTER init\n\t\t-- * On updating with new state via updateVirtualNode\n\t\texpect(getDerivedSpy.callCount).to.equal(4)\n\n\t\tlocal values = getDerivedSpy:captureValues(\"props\", \"state\")\n\n\t\tassertDeepEqual(values.props, {})\n\t\tassertDeepEqual(values.state, { someState = 2 })\n\tend)\n\n\tit(\"should be invoked when updating via state in init (which skips reconciliation)\", function()\n\t\tlocal getDerivedSpy = createSpy()\n\t\tlocal WithDerivedState = Component:extend(\"WithDerivedState\")\n\n\t\tWithDerivedState.getDerivedStateFromProps = getDerivedSpy.value\n\n\t\tfunction WithDerivedState:init()\n\t\t\tself:setState({\n\t\t\t\tstateFromInit = 1,\n\t\t\t})\n\t\tend\n\n\t\tfunction WithDerivedState:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal element = createElement(WithDerivedState, {\n\t\t\tsomeProp = 1,\n\t\t})\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"WithDerivedState\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\t-- getDerivedStateFromProps will be called:\n\t\t-- * Once on empty props\n\t\t-- * Once during the self:setState in init\n\t\t-- * Once more, defensively, on the resulting state AFTER init\n\t\texpect(getDerivedSpy.callCount).to.equal(3)\n\n\t\tlocal values = getDerivedSpy:captureValues(\"props\", \"state\")\n\n\t\tassertDeepEqual(values.props, {\n\t\t\tsomeProp = 1,\n\t\t})\n\t\tassertDeepEqual(values.state, {\n\t\t\tstateFromInit = 1,\n\t\t})\n\tend)\n\n\tit(\"should receive defaultProps\", function()\n\t\tlocal getDerivedSpy = createSpy()\n\t\tlocal WithDerivedState = Component:extend(\"WithDerivedState\")\n\n\t\tWithDerivedState.defaultProps = {\n\t\t\tsomeDefaultProp = \"foo\",\n\t\t}\n\n\t\tWithDerivedState.getDerivedStateFromProps = getDerivedSpy.value\n\n\t\tfunction WithDerivedState:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal element = createElement(WithDerivedState, {\n\t\t\tsomeProp = 1,\n\t\t})\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"WithDerivedState\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\texpect(getDerivedSpy.callCount).to.equal(1)\n\n\t\tlocal values = getDerivedSpy:captureValues(\"props\", \"state\")\n\n\t\tassertDeepEqual(values.props, {\n\t\t\tsomeDefaultProp = \"foo\",\n\t\t\tsomeProp = 1,\n\t\t})\n\n\t\t-- Update via props, confirm that defaultProp is still present\n\t\telement = createElement(WithDerivedState, {\n\t\t\tsomeProp = 2,\n\t\t})\n\n\t\tnoopReconciler.updateVirtualNode(node, element)\n\n\t\texpect(getDerivedSpy.callCount).to.equal(2)\n\n\t\tvalues = getDerivedSpy:captureValues(\"props\", \"state\")\n\n\t\tassertDeepEqual(values.props, {\n\t\t\tsomeDefaultProp = \"foo\",\n\t\t\tsomeProp = 2,\n\t\t})\n\tend)\n\n\tit(\"should derive state for all setState updates, even when deferred\", function()\n\t\tlocal Child = Component:extend(\"Child\")\n\t\tlocal stateUpdaterSpy = createSpy(function()\n\t\t\treturn {}\n\t\tend)\n\t\tlocal stateDerivedSpy = createSpy()\n\n\t\tfunction Child:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tfunction Child:didMount()\n\t\t\tself.props.callback()\n\t\tend\n\n\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\tParent.getDerivedStateFromProps = stateDerivedSpy.value\n\n\t\tfunction Parent:render()\n\t\t\tlocal callback = function()\n\t\t\t\tself:setState(stateUpdaterSpy.value)\n\t\t\tend\n\n\t\t\treturn createFragment({\n\t\t\t\tChildA = createElement(Child, {\n\t\t\t\t\tcallback = callback,\n\t\t\t\t}),\n\t\t\t\tChildB = createElement(Child, {\n\t\t\t\t\tcallback = callback,\n\t\t\t\t}),\n\t\t\t})\n\t\tend\n\n\t\tlocal element = createElement(Parent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\texpect(stateUpdaterSpy.callCount).to.equal(2)\n\n\t\t-- getDerivedStateFromProps is always called on initial state\n\t\texpect(stateDerivedSpy.callCount).to.equal(3)\n\tend)\n\n\tit(\"should have derived state after assigning to state in init\", function()\n\t\tlocal getStateCallback\n\t\tlocal getDerivedSpy = createSpy(function()\n\t\t\treturn {\n\t\t\t\tderived = true,\n\t\t\t}\n\t\tend)\n\t\tlocal WithDerivedState = Component:extend(\"WithDerivedState\")\n\n\t\tWithDerivedState.getDerivedStateFromProps = getDerivedSpy.value\n\n\t\tfunction WithDerivedState:init()\n\t\t\tself.state = {\n\t\t\t\tinit = true,\n\t\t\t}\n\n\t\t\tgetStateCallback = function()\n\t\t\t\treturn self.state\n\t\t\tend\n\t\tend\n\n\t\tfunction WithDerivedState:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"WithDerivedState\"\n\t\tlocal element = createElement(WithDerivedState)\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\texpect(getDerivedSpy.callCount).to.equal(2)\n\n\t\tassertDeepEqual(getStateCallback(), {\n\t\t\tinit = true,\n\t\t\tderived = true,\n\t\t})\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "extend.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tit(\"should be extendable\", function()\n\t\tlocal MyComponent = Component:extend(\"The Senate\")\n\n\t\texpect(MyComponent).to.be.ok()\n\t\texpect(Type.of(MyComponent)).to.equal(Type.StatefulComponentClass)\n\tend)\n\n\tit(\"should prevent extending a user component\", function()\n\t\tlocal MyComponent = Component:extend(\"Sheev\")\n\n\t\texpect(function()\n\t\t\tMyComponent:extend(\"Frank\")\n\t\tend).to.throw()\n\tend)\n\n\tit(\"should use a given name\", function()\n\t\tlocal MyComponent = Component:extend(\"FooBar\")\n\n\t\tlocal name = tostring(MyComponent)\n\n\t\texpect(name).to.be.a(\"string\")\n\t\texpect(name:find(\"FooBar\")).to.be.ok()\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "didUpdate.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked when updated via updateVirtualNode\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal didUpdateSpy = createSpy()\n\t\tMyComponent.didUpdate = didUpdateSpy.value\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal initialProps = {\n\t\t\ta = 5,\n\t\t}\n\t\tlocal initialElement = createElement(MyComponent, initialProps)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tlocal virtualNode = noopReconciler.mountVirtualNode(initialElement, hostParent, key)\n\n\t\texpect(didUpdateSpy.callCount).to.equal(0)\n\n\t\tlocal newProps = {\n\t\t\ta = 6,\n\t\t\tb = 2,\n\t\t}\n\t\tlocal newElement = createElement(MyComponent, newProps)\n\t\tnoopReconciler.updateVirtualNode(virtualNode, newElement)\n\n\t\texpect(didUpdateSpy.callCount).to.equal(1)\n\n\t\tlocal values = didUpdateSpy:captureValues(\"self\", \"oldProps\", \"oldState\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\t\tassertDeepEqual(values.oldProps, initialProps)\n\t\tassertDeepEqual(values.oldState, {})\n\tend)\n\n\tit(\"should be invoked when updated via setState\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal didUpdateSpy = createSpy()\n\t\tMyComponent.didUpdate = didUpdateSpy.value\n\n\t\tlocal initialState = {\n\t\t\ta = 4,\n\t\t}\n\n\t\tlocal setState\n\t\tfunction MyComponent:init()\n\t\t\tsetState = function(...)\n\t\t\t\treturn self:setState(...)\n\t\t\tend\n\n\t\t\tself:setState(initialState)\n\t\tend\n\n\t\tfunction MyComponent:render() end\n\n\t\tlocal element = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\texpect(didUpdateSpy.callCount).to.equal(0)\n\n\t\tsetState({\n\t\t\ta = 5,\n\t\t})\n\n\t\texpect(didUpdateSpy.callCount).to.equal(1)\n\n\t\tlocal values = didUpdateSpy:captureValues(\"self\", \"oldProps\", \"oldState\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\t\tassertDeepEqual(values.oldProps, {})\n\t\tassertDeepEqual(values.oldState, initialState)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "didMount.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked when mounted\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal didMountSpy = createSpy()\n\n\t\tMyComponent.didMount = didMountSpy.value\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal element = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\texpect(didMountSpy.callCount).to.equal(1)\n\n\t\tlocal values = didMountSpy:captureValues(\"self\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "defaultProps.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal None = require(script.Parent.Parent.None)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should fill in when mounting before init\", function()\n\t\tlocal defaultProps = {\n\t\t\ta = 3,\n\t\t\tb = 2,\n\t\t}\n\n\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\tFoo.defaultProps = defaultProps\n\n\t\tlocal capturedProps\n\t\tfunction Foo:init()\n\t\t\tcapturedProps = self.props\n\t\tend\n\n\t\tfunction Foo:render() end\n\n\t\tlocal initialProps = {\n\t\t\tb = 4,\n\t\t\tc = 6,\n\t\t}\n\n\t\tlocal element = createElement(Foo, initialProps)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Some Foo\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\tlocal expectedProps = {\n\t\t\ta = defaultProps.a,\n\t\t\tb = initialProps.b,\n\t\t\tc = initialProps.c,\n\t\t}\n\n\t\tassertDeepEqual(capturedProps, expectedProps)\n\tend)\n\n\tit(\"should fill in when updating via props\", function()\n\t\tlocal defaultProps = {\n\t\t\ta = 3,\n\t\t\tb = 2,\n\t\t}\n\n\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\tFoo.defaultProps = defaultProps\n\n\t\tlocal capturedProps\n\t\tfunction Foo:render()\n\t\t\tcapturedProps = self.props\n\t\tend\n\n\t\tlocal initialProps = {\n\t\t\tb = 4,\n\t\t\tc = 6,\n\t\t}\n\n\t\tlocal element = createElement(Foo, initialProps)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Some Foo\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\tlocal updatedProps = {\n\t\t\tc = 5,\n\t\t}\n\t\tlocal updatedElement = createElement(Foo, updatedProps)\n\n\t\tnoopReconciler.updateVirtualNode(node, updatedElement)\n\n\t\tlocal expectedProps = {\n\t\t\ta = defaultProps.a,\n\t\t\tb = defaultProps.b,\n\t\t\tc = updatedProps.c,\n\t\t}\n\n\t\tassertDeepEqual(capturedProps, expectedProps)\n\tend)\n\n\tit(\"should respect None to override a default prop with nil\", function()\n\t\tlocal defaultProps = {\n\t\t\ta = 3,\n\t\t\tb = 2,\n\t\t}\n\n\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\tFoo.defaultProps = defaultProps\n\n\t\tlocal capturedProps\n\t\tfunction Foo:render()\n\t\t\tcapturedProps = self.props\n\t\tend\n\n\t\tlocal initialProps = {\n\t\t\tb = None,\n\t\t\tc = 4,\n\t\t}\n\n\t\tlocal element = createElement(Foo, initialProps)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Some Foo\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\tlocal expectedProps = {\n\t\t\ta = defaultProps.a,\n\t\t\tb = nil,\n\t\t\tc = initialProps.c,\n\t\t}\n\n\t\tassertDeepEqual(capturedProps, expectedProps)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "context.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal oneChild = require(script.Parent.Parent.oneChild)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be provided as an internal api on Component\", function()\n\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\tfunction Provider:init()\n\t\t\tself:__addContext(\"foo\", \"bar\")\n\t\tend\n\n\t\tfunction Provider:render() end\n\n\t\tlocal element = createElement(Provider)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Provider\"\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\tlocal expectedContext = {\n\t\t\tfoo = \"bar\",\n\t\t}\n\n\t\tassertDeepEqual(node.context, expectedContext)\n\tend)\n\n\tit(\"should be inherited from parent stateful nodes\", function()\n\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\tlocal capturedContext\n\t\tfunction Consumer:init()\n\t\t\tcapturedContext = {\n\t\t\t\thello = self:__getContext(\"hello\"),\n\t\t\t\tvalue = self:__getContext(\"value\"),\n\t\t\t}\n\t\tend\n\n\t\tfunction Consumer:render() end\n\n\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\tfunction Parent:render()\n\t\t\treturn createElement(Consumer)\n\t\tend\n\n\t\tlocal element = createElement(Parent)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Parent\"\n\t\tlocal context = {\n\t\t\thello = \"world\",\n\t\t\tvalue = 6,\n\t\t}\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)\n\n\t\texpect(capturedContext).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(node.context)\n\t\tassertDeepEqual(node.context, context)\n\t\tassertDeepEqual(capturedContext, context)\n\tend)\n\n\tit(\"should be inherited from parent function nodes\", function()\n\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\tlocal capturedContext\n\t\tfunction Consumer:init()\n\t\t\tcapturedContext = {\n\t\t\t\thello = self:__getContext(\"hello\"),\n\t\t\t\tvalue = self:__getContext(\"value\"),\n\t\t\t}\n\t\tend\n\n\t\tfunction Consumer:render() end\n\n\t\tlocal function Parent()\n\t\t\treturn createElement(Consumer)\n\t\tend\n\n\t\tlocal element = createElement(Parent)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Parent\"\n\t\tlocal context = {\n\t\t\thello = \"world\",\n\t\t\tvalue = 6,\n\t\t}\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)\n\n\t\texpect(capturedContext).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(node.context)\n\t\tassertDeepEqual(node.context, context)\n\t\tassertDeepEqual(capturedContext, context)\n\tend)\n\n\tit(\"should not copy the context table if it doesn't need to\", function()\n\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\tfunction Parent:init()\n\t\t\tself:__addContext(\"parent\", \"I'm here!\")\n\t\tend\n\n\t\tfunction Parent:render()\n\t\t\t-- Create some child element\n\t\t\treturn createElement(function() end)\n\t\tend\n\n\t\tlocal element = createElement(Parent)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Parent\"\n\t\tlocal parentNode = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\tlocal expectedContext = {\n\t\t\tparent = \"I'm here!\",\n\t\t}\n\n\t\tassertDeepEqual(parentNode.context, expectedContext)\n\n\t\tlocal childNode = oneChild(parentNode.children)\n\n\t\t-- Parent and child should have the same context table\n\t\texpect(parentNode.context).to.equal(childNode.context)\n\tend)\n\n\tit(\"should not allow context to move up the tree\", function()\n\t\tlocal ChildProvider = Component:extend(\"ChildProvider\")\n\n\t\tfunction ChildProvider:init()\n\t\t\tself:__addContext(\"child\", \"I'm here too!\")\n\t\tend\n\n\t\tfunction ChildProvider:render() end\n\n\t\tlocal ParentProvider = Component:extend(\"ParentProvider\")\n\n\t\tfunction ParentProvider:init()\n\t\t\tself:__addContext(\"parent\", \"I'm here!\")\n\t\tend\n\n\t\tfunction ParentProvider:render()\n\t\t\treturn createElement(ChildProvider)\n\t\tend\n\n\t\tlocal element = createElement(ParentProvider)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Parent\"\n\n\t\tlocal parentNode = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\t\tlocal childNode = oneChild(parentNode.children)\n\n\t\tlocal expectedParentContext = {\n\t\t\tparent = \"I'm here!\",\n\t\t\t-- Context does not travel back up\n\t\t}\n\n\t\tlocal expectedChildContext = {\n\t\t\tparent = \"I'm here!\",\n\t\t\tchild = \"I'm here too!\",\n\t\t}\n\n\t\tassertDeepEqual(parentNode.context, expectedParentContext)\n\t\tassertDeepEqual(childNode.context, expectedChildContext)\n\tend)\n\n\tit(\"should contain values put into the tree by parent nodes\", function()\n\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\tlocal capturedContext\n\t\tfunction Consumer:init()\n\t\t\tcapturedContext = {\n\t\t\t\tdont = self:__getContext(\"dont\"),\n\t\t\t\tfrob = self:__getContext(\"frob\"),\n\t\t\t}\n\t\tend\n\n\t\tfunction Consumer:render() end\n\n\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\tfunction Provider:init()\n\t\t\tself:__addContext(\"frob\", \"ulator\")\n\t\tend\n\n\t\tfunction Provider:render()\n\t\t\treturn createElement(Consumer)\n\t\tend\n\n\t\tlocal element = createElement(Provider)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Consumer\"\n\t\tlocal context = {\n\t\t\tdont = \"try it\",\n\t\t}\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)\n\n\t\tlocal initialContext = {\n\t\t\tdont = \"try it\",\n\t\t}\n\n\t\tlocal expectedContext = {\n\t\t\tdont = \"try it\",\n\t\t\tfrob = \"ulator\",\n\t\t}\n\n\t\t-- Because components mutate context, we're careful with equality\n\t\texpect(node.context).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(node.context)\n\n\t\tassertDeepEqual(context, initialContext)\n\t\tassertDeepEqual(node.context, expectedContext)\n\t\tassertDeepEqual(capturedContext, expectedContext)\n\tend)\n\n\tit(\"should transfer context to children that are replaced\", function()\n\t\tlocal ConsumerA = Component:extend(\"ConsumerA\")\n\n\t\tlocal function captureAllContext(component)\n\t\t\treturn {\n\t\t\t\tA = component:__getContext(\"A\"),\n\t\t\t\tB = component:__getContext(\"B\"),\n\t\t\t\tfrob = component:__getContext(\"frob\"),\n\t\t\t}\n\t\tend\n\n\t\tlocal capturedContextA\n\t\tfunction ConsumerA:init()\n\t\t\tself:__addContext(\"A\", \"hello\")\n\n\t\t\tcapturedContextA = captureAllContext(self)\n\t\tend\n\n\t\tfunction ConsumerA:render() end\n\n\t\tlocal ConsumerB = Component:extend(\"ConsumerB\")\n\n\t\tlocal capturedContextB\n\t\tfunction ConsumerB:init()\n\t\t\tself:__addContext(\"B\", \"hello\")\n\n\t\t\tcapturedContextB = captureAllContext(self)\n\t\tend\n\n\t\tfunction ConsumerB:render() end\n\n\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\tfunction Provider:init()\n\t\t\tself:__addContext(\"frob\", \"ulator\")\n\t\tend\n\n\t\tfunction Provider:render()\n\t\t\tlocal useConsumerB = self.props.useConsumerB\n\n\t\t\tif useConsumerB then\n\t\t\t\treturn createElement(ConsumerB)\n\t\t\telse\n\t\t\t\treturn createElement(ConsumerA)\n\t\t\tend\n\t\tend\n\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Consumer\"\n\n\t\tlocal element = createElement(Provider)\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\tlocal expectedContextA = {\n\t\t\tfrob = \"ulator\",\n\t\t\tA = \"hello\",\n\t\t}\n\n\t\tassertDeepEqual(capturedContextA, expectedContextA)\n\n\t\tlocal expectedContextB = {\n\t\t\tfrob = \"ulator\",\n\t\t\tB = \"hello\",\n\t\t}\n\n\t\tlocal replacedElement = createElement(Provider, {\n\t\t\tuseConsumerB = true,\n\t\t})\n\t\tnoopReconciler.updateVirtualNode(node, replacedElement)\n\n\t\tassertDeepEqual(capturedContextB, expectedContextB)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            }
                        ],
                        "ClassName": "Folder"
                    },
                    {
                        "Name": "Component",
                        "ClassName": "ModuleScript",
                        "Source": "local assign = require(script.Parent.assign)\nlocal ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)\nlocal Type = require(script.Parent.Type)\nlocal Symbol = require(script.Parent.Symbol)\nlocal invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)\nlocal internalAssert = require(script.Parent.internalAssert)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\n--[[\n\tCalling setState during certain lifecycle allowed methods has the potential\n\tto create an infinitely updating component. Rather than time out, we exit\n\twith an error if an unreasonable number of self-triggering updates occur\n]]\nlocal MAX_PENDING_UPDATES = 100\n\nlocal InternalData = Symbol.named(\"InternalData\")\n\nlocal componentMissingRenderMessage = [[\nThe component %q is missing the `render` method.\n`render` must be defined when creating a Roact component!]]\n\nlocal tooManyUpdatesMessage = [[\nThe component %q has reached the setState update recursion limit.\nWhen using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]\n\nlocal componentClassMetatable = {}\n\nfunction componentClassMetatable:__tostring()\n\treturn self.__componentName\nend\n\nlocal Component = {}\nsetmetatable(Component, componentClassMetatable)\n\nComponent[Type] = Type.StatefulComponentClass\nComponent.__index = Component\nComponent.__componentName = \"Component\"\n\n--[[\n\tA method called by consumers of Roact to create a new component class.\n\tComponents can not be extended beyond this point, with the exception of\n\tPureComponent.\n]]\nfunction Component:extend(name)\n\tif config.typeChecks then\n\t\tassert(Type.of(self) == Type.StatefulComponentClass, \"Invalid `self` argument to `extend`.\")\n\t\tassert(typeof(name) == \"string\", \"Component class name must be a string\")\n\tend\n\n\tlocal class = {}\n\n\tfor key, value in pairs(self) do\n\t\t-- Roact opts to make consumers use composition over inheritance, which\n\t\t-- lines up with React.\n\t\t-- https://reactjs.org/docs/composition-vs-inheritance.html\n\t\tif key ~= \"extend\" then\n\t\t\tclass[key] = value\n\t\tend\n\tend\n\n\tclass[Type] = Type.StatefulComponentClass\n\tclass.__index = class\n\tclass.__componentName = name\n\n\tsetmetatable(class, componentClassMetatable)\n\n\treturn class\nend\n\nfunction Component:__getDerivedState(incomingProps, incomingState)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__getDerivedState`\")\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal componentClass = internalData.componentClass\n\n\tif componentClass.getDerivedStateFromProps ~= nil then\n\t\tlocal derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)\n\n\t\tif derivedState ~= nil then\n\t\t\tif config.typeChecks then\n\t\t\t\tassert(typeof(derivedState) == \"table\", \"getDerivedStateFromProps must return a table!\")\n\t\t\tend\n\n\t\t\treturn derivedState\n\t\tend\n\tend\n\n\treturn nil\nend\n\nfunction Component:setState(mapState)\n\tif config.typeChecks then\n\t\tassert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid `self` argument to `extend`.\")\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal lifecyclePhase = internalData.lifecyclePhase\n\n\t--[[\n\t\tWhen preparing to update, rendering, or unmounting, it is not safe\n\t\tto call `setState` as it will interfere with in-flight updates. It's\n\t\talso disallowed during unmounting\n\t]]\n\tif\n\t\tlifecyclePhase == ComponentLifecyclePhase.ShouldUpdate\n\t\tor lifecyclePhase == ComponentLifecyclePhase.WillUpdate\n\t\tor lifecyclePhase == ComponentLifecyclePhase.Render\n\t\tor lifecyclePhase == ComponentLifecyclePhase.WillUnmount\n\tthen\n\t\tlocal messageTemplate = invalidSetStateMessages[internalData.lifecyclePhase]\n\n\t\tlocal message = messageTemplate:format(tostring(internalData.componentClass))\n\n\t\terror(message, 2)\n\tend\n\n\tlocal pendingState = internalData.pendingState\n\n\tlocal partialState\n\tif typeof(mapState) == \"function\" then\n\t\tpartialState = mapState(pendingState or self.state, self.props)\n\n\t\t-- Abort the state update if the given state updater function returns nil\n\t\tif partialState == nil then\n\t\t\treturn\n\t\tend\n\telseif typeof(mapState) == \"table\" then\n\t\tpartialState = mapState\n\telse\n\t\terror(\"Invalid argument to setState, expected function or table\", 2)\n\tend\n\n\tlocal newState\n\tif pendingState ~= nil then\n\t\tnewState = assign(pendingState, partialState)\n\telse\n\t\tnewState = assign({}, self.state, partialState)\n\tend\n\n\tif lifecyclePhase == ComponentLifecyclePhase.Init then\n\t\t-- If `setState` is called in `init`, we can skip triggering an update!\n\t\tlocal derivedState = self:__getDerivedState(self.props, newState)\n\t\tself.state = assign(newState, derivedState)\n\telseif\n\t\tlifecyclePhase == ComponentLifecyclePhase.DidMount\n\t\tor lifecyclePhase == ComponentLifecyclePhase.DidUpdate\n\t\tor lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren\n\tthen\n\t\t--[[\n\t\t\tDuring certain phases of the component lifecycle, it's acceptable to\n\t\t\tallow `setState` but defer the update until we're done with ones in flight.\n\t\t\tWe do this by collapsing it into any pending updates we have.\n\t\t]]\n\t\tlocal derivedState = self:__getDerivedState(self.props, newState)\n\t\tinternalData.pendingState = assign(newState, derivedState)\n\telseif lifecyclePhase == ComponentLifecyclePhase.Idle then\n\t\t-- Outside of our lifecycle, the state update is safe to make immediately\n\t\tself:__update(nil, newState)\n\telse\n\t\tlocal messageTemplate = invalidSetStateMessages.default\n\n\t\tlocal message = messageTemplate:format(tostring(internalData.componentClass))\n\n\t\terror(message, 2)\n\tend\nend\n\n--[[\n\tReturns the stack trace of where the element was created that this component\n\tinstance's properties are based on.\n\n\tIntended to be used primarily by diagnostic tools.\n]]\nfunction Component:getElementTraceback()\n\treturn self[InternalData].virtualNode.currentElement.source\nend\n\n--[[\n\tReturns a snapshot of this component given the current props and state. Must\n\tbe overridden by consumers of Roact and should be a pure function with\n\tregards to props and state.\n\n\tTODO (#199): Accept props and state as arguments.\n]]\nfunction Component:render()\n\tlocal internalData = self[InternalData]\n\n\tlocal message = componentMissingRenderMessage:format(tostring(internalData.componentClass))\n\n\terror(message, 0)\nend\n\n--[[\n\tRetrieves the context value corresponding to the given key. Can return nil\n\tif a requested context key is not present\n]]\nfunction Component:__getContext(key)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__getContext`\")\n\t\tinternalAssert(key ~= nil, \"Context key cannot be nil\")\n\tend\n\n\tlocal virtualNode = self[InternalData].virtualNode\n\tlocal context = virtualNode.context\n\n\treturn context[key]\nend\n\n--[[\n\tAdds a new context entry to this component's context table (which will be\n\tpassed down to child components).\n]]\nfunction Component:__addContext(key, value)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__addContext`\")\n\tend\n\tlocal virtualNode = self[InternalData].virtualNode\n\n\t-- Make sure we store a reference to the component's original, unmodified\n\t-- context the virtual node. In the reconciler, we'll restore the original\n\t-- context if we need to replace the node (this happens when a node gets\n\t-- re-rendered as a different component)\n\tif virtualNode.originalContext == nil then\n\t\tvirtualNode.originalContext = virtualNode.context\n\tend\n\n\t-- Build a new context table on top of the existing one, then apply it to\n\t-- our virtualNode\n\tlocal existing = virtualNode.context\n\tvirtualNode.context = assign({}, existing, { [key] = value })\nend\n\n--[[\n\tPerforms property validation if the static method validateProps is declared.\n\tvalidateProps should follow assert's expected arguments:\n\t(false, message: string) | true. The function may return a message in the\n\ttrue case; it will be ignored. If this fails, the function will throw the\n\terror.\n]]\nfunction Component:__validateProps(props)\n\tif not config.propValidation then\n\t\treturn\n\tend\n\n\tlocal validator = self[InternalData].componentClass.validateProps\n\n\tif validator == nil then\n\t\treturn\n\tend\n\n\tif typeof(validator) ~= \"function\" then\n\t\terror(\n\t\t\t(\"validateProps must be a function, but it is a %s.\\nCheck the definition of the component %q.\"):format(\n\t\t\t\ttypeof(validator),\n\t\t\t\tself.__componentName\n\t\t\t)\n\t\t)\n\tend\n\n\tlocal success, failureReason = validator(props)\n\n\tif not success then\n\t\tfailureReason = failureReason or \"<Validator function did not supply a message>\"\n\t\terror(\n\t\t\t(\"Property validation failed in %s: %s\\n\\n%s\"):format(\n\t\t\t\tself.__componentName,\n\t\t\t\ttostring(failureReason),\n\t\t\t\tself:getElementTraceback() or \"<enable element tracebacks>\"\n\t\t\t),\n\t\t\t0\n\t\t)\n\tend\nend\n\n--[[\n\tAn internal method used by the reconciler to construct a new component\n\tinstance and attach it to the given virtualNode.\n]]\nfunction Component:__mount(reconciler, virtualNode)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentClass, \"Invalid use of `__mount`\")\n\t\tinternalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #2 to be of type VirtualNode\")\n\tend\n\n\tlocal currentElement = virtualNode.currentElement\n\tlocal hostParent = virtualNode.hostParent\n\n\t-- Contains all the information that we want to keep from consumers of\n\t-- Roact, or even other parts of the codebase like the reconciler.\n\tlocal internalData = {\n\t\treconciler = reconciler,\n\t\tvirtualNode = virtualNode,\n\t\tcomponentClass = self,\n\t\tlifecyclePhase = ComponentLifecyclePhase.Init,\n\t}\n\n\tlocal instance = {\n\t\t[Type] = Type.StatefulComponentInstance,\n\t\t[InternalData] = internalData,\n\t}\n\n\tsetmetatable(instance, self)\n\n\tvirtualNode.instance = instance\n\n\tlocal props = currentElement.props\n\n\tif self.defaultProps ~= nil then\n\t\tprops = assign({}, self.defaultProps, props)\n\tend\n\n\tinstance:__validateProps(props)\n\n\tinstance.props = props\n\n\tlocal newContext = assign({}, virtualNode.legacyContext)\n\tinstance._context = newContext\n\n\tinstance.state = assign({}, instance:__getDerivedState(instance.props, {}))\n\n\tif instance.init ~= nil then\n\t\tinstance:init(instance.props)\n\t\tassign(instance.state, instance:__getDerivedState(instance.props, instance.state))\n\tend\n\n\t-- It's possible for init() to redefine _context!\n\tvirtualNode.legacyContext = instance._context\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Render\n\tlocal renderResult = instance:render()\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren\n\treconciler.updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)\n\n\tif instance.didMount ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.DidMount\n\t\tinstance:didMount()\n\tend\n\n\tif internalData.pendingState ~= nil then\n\t\t-- __update will handle pendingState, so we don't pass any new element or state\n\t\tinstance:__update(nil, nil)\n\tend\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Idle\nend\n\n--[[\n\tInternal method used by the reconciler to clean up any resources held by\n\tthis component instance.\n]]\nfunction Component:__unmount()\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__unmount`\")\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal virtualNode = internalData.virtualNode\n\tlocal reconciler = internalData.reconciler\n\n\tif self.willUnmount ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount\n\t\tself:willUnmount()\n\tend\n\n\tfor _, childNode in pairs(virtualNode.children) do\n\t\treconciler.unmountVirtualNode(childNode)\n\tend\nend\n\n--[[\n\tInternal method used by setState (to trigger updates based on state) and by\n\tthe reconciler (to trigger updates based on props)\n\n\tReturns true if the update was completed, false if it was cancelled by shouldUpdate\n]]\nfunction Component:__update(updatedElement, updatedState)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__update`\")\n\t\tinternalAssert(\n\t\t\tType.of(updatedElement) == Type.Element or updatedElement == nil,\n\t\t\t\"Expected arg #1 to be of type Element or nil\"\n\t\t)\n\t\tinternalAssert(\n\t\t\ttypeof(updatedState) == \"table\" or updatedState == nil,\n\t\t\t\"Expected arg #2 to be of type table or nil\"\n\t\t)\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal componentClass = internalData.componentClass\n\n\tlocal newProps = self.props\n\tif updatedElement ~= nil then\n\t\tnewProps = updatedElement.props\n\n\t\tif componentClass.defaultProps ~= nil then\n\t\t\tnewProps = assign({}, componentClass.defaultProps, newProps)\n\t\tend\n\n\t\tself:__validateProps(newProps)\n\tend\n\n\tlocal updateCount = 0\n\trepeat\n\t\tlocal finalState\n\t\tlocal pendingState = nil\n\n\t\t-- Consume any pending state we might have\n\t\tif internalData.pendingState ~= nil then\n\t\t\tpendingState = internalData.pendingState\n\t\t\tinternalData.pendingState = nil\n\t\tend\n\n\t\t-- Consume a standard update to state or props\n\t\tif updatedState ~= nil or newProps ~= self.props then\n\t\t\tif pendingState == nil then\n\t\t\t\tfinalState = updatedState or self.state\n\t\t\telse\n\t\t\t\tfinalState = assign(pendingState, updatedState)\n\t\t\tend\n\n\t\t\tlocal derivedState = self:__getDerivedState(newProps, finalState)\n\n\t\t\tif derivedState ~= nil then\n\t\t\t\tfinalState = assign({}, finalState, derivedState)\n\t\t\tend\n\n\t\t\tupdatedState = nil\n\t\telse\n\t\t\tfinalState = pendingState\n\t\tend\n\n\t\tif not self:__resolveUpdate(newProps, finalState) then\n\t\t\t-- If the update was short-circuited, bubble the result up to the caller\n\t\t\treturn false\n\t\tend\n\n\t\tupdateCount = updateCount + 1\n\n\t\tif updateCount > MAX_PENDING_UPDATES then\n\t\t\terror(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)\n\t\tend\n\tuntil internalData.pendingState == nil\n\n\treturn true\nend\n\n--[[\n\tInternal method used by __update to apply new props and state\n\n\tReturns true if the update was completed, false if it was cancelled by shouldUpdate\n]]\nfunction Component:__resolveUpdate(incomingProps, incomingState)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__resolveUpdate`\")\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal virtualNode = internalData.virtualNode\n\tlocal reconciler = internalData.reconciler\n\n\tlocal oldProps = self.props\n\tlocal oldState = self.state\n\n\tif incomingProps == nil then\n\t\tincomingProps = oldProps\n\tend\n\tif incomingState == nil then\n\t\tincomingState = oldState\n\tend\n\n\tif self.shouldUpdate ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate\n\t\tlocal continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)\n\n\t\tif not continueWithUpdate then\n\t\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Idle\n\t\t\treturn false\n\t\tend\n\tend\n\n\tif self.willUpdate ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate\n\t\tself:willUpdate(incomingProps, incomingState)\n\tend\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Render\n\n\tself.props = incomingProps\n\tself.state = incomingState\n\n\tlocal renderResult = virtualNode.instance:render()\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren\n\treconciler.updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, renderResult)\n\n\tif self.didUpdate ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate\n\t\tself:didUpdate(oldProps, oldState)\n\tend\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Idle\n\treturn true\nend\n\nreturn Component\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Binding.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal createSpy = require(script.Parent.createSpy)\n\tlocal Type = require(script.Parent.Type)\n\tlocal GlobalConfig = require(script.Parent.GlobalConfig)\n\n\tlocal Binding = require(script.Parent.Binding)\n\n\tdescribe(\"Binding.create\", function()\n\t\tit(\"should return a Binding object and an update function\", function()\n\t\t\tlocal binding, update = Binding.create(1)\n\n\t\t\texpect(Type.of(binding)).to.equal(Type.Binding)\n\t\t\texpect(typeof(update)).to.equal(\"function\")\n\t\tend)\n\n\t\tit(\"should support tostring on bindings\", function()\n\t\t\tlocal binding, update = Binding.create(1)\n\t\t\texpect(tostring(binding)).to.equal(\"RoactBinding(1)\")\n\n\t\t\tupdate(\"foo\")\n\t\t\texpect(tostring(binding)).to.equal(\"RoactBinding(foo)\")\n\t\tend)\n\tend)\n\n\tdescribe(\"Binding object\", function()\n\t\tit(\"should provide a getter and setter\", function()\n\t\t\tlocal binding, update = Binding.create(1)\n\n\t\t\texpect(binding:getValue()).to.equal(1)\n\n\t\t\tupdate(3)\n\n\t\t\texpect(binding:getValue()).to.equal(3)\n\t\tend)\n\n\t\tit(\"should let users subscribe and unsubscribe to its updates\", function()\n\t\t\tlocal binding, update = Binding.create(1)\n\n\t\t\tlocal spy = createSpy()\n\t\t\tlocal disconnect = Binding.subscribe(binding, spy.value)\n\n\t\t\texpect(spy.callCount).to.equal(0)\n\n\t\t\tupdate(2)\n\n\t\t\texpect(spy.callCount).to.equal(1)\n\t\t\tspy:assertCalledWith(2)\n\n\t\t\tdisconnect()\n\t\t\tupdate(3)\n\n\t\t\texpect(spy.callCount).to.equal(1)\n\t\tend)\n\tend)\n\n\tdescribe(\"Mapped bindings\", function()\n\t\tit(\"should be composable\", function()\n\t\t\tlocal word, updateWord = Binding.create(\"hi\")\n\n\t\t\tlocal wordLength = word:map(string.len)\n\t\t\tlocal isEvenLength = wordLength:map(function(value)\n\t\t\t\treturn value % 2 == 0\n\t\t\tend)\n\n\t\t\texpect(word:getValue()).to.equal(\"hi\")\n\t\t\texpect(wordLength:getValue()).to.equal(2)\n\t\t\texpect(isEvenLength:getValue()).to.equal(true)\n\n\t\t\tupdateWord(\"sup\")\n\n\t\t\texpect(word:getValue()).to.equal(\"sup\")\n\t\t\texpect(wordLength:getValue()).to.equal(3)\n\t\t\texpect(isEvenLength:getValue()).to.equal(false)\n\t\tend)\n\n\t\tit(\"should cascade updates when subscribed\", function()\n\t\t\t-- base binding\n\t\t\tlocal word, updateWord = Binding.create(\"hi\")\n\n\t\t\tlocal wordSpy = createSpy()\n\t\t\tlocal disconnectWord = Binding.subscribe(word, wordSpy.value)\n\n\t\t\t-- binding -> base binding\n\t\t\tlocal length = word:map(string.len)\n\n\t\t\tlocal lengthSpy = createSpy()\n\t\t\tlocal disconnectLength = Binding.subscribe(length, lengthSpy.value)\n\n\t\t\t-- binding -> binding -> base binding\n\t\t\tlocal isEvenLength = length:map(function(value)\n\t\t\t\treturn value % 2 == 0\n\t\t\tend)\n\n\t\t\tlocal isEvenLengthSpy = createSpy()\n\t\t\tlocal disconnectIsEvenLength = Binding.subscribe(isEvenLength, isEvenLengthSpy.value)\n\n\t\t\texpect(wordSpy.callCount).to.equal(0)\n\t\t\texpect(lengthSpy.callCount).to.equal(0)\n\t\t\texpect(isEvenLengthSpy.callCount).to.equal(0)\n\n\t\t\tupdateWord(\"nice\")\n\n\t\t\texpect(wordSpy.callCount).to.equal(1)\n\t\t\twordSpy:assertCalledWith(\"nice\")\n\n\t\t\texpect(lengthSpy.callCount).to.equal(1)\n\t\t\tlengthSpy:assertCalledWith(4)\n\n\t\t\texpect(isEvenLengthSpy.callCount).to.equal(1)\n\t\t\tisEvenLengthSpy:assertCalledWith(true)\n\n\t\t\tdisconnectWord()\n\t\t\tdisconnectLength()\n\t\t\tdisconnectIsEvenLength()\n\n\t\t\tupdateWord(\"goodbye\")\n\n\t\t\texpect(wordSpy.callCount).to.equal(1)\n\t\t\texpect(isEvenLengthSpy.callCount).to.equal(1)\n\t\t\texpect(lengthSpy.callCount).to.equal(1)\n\t\tend)\n\n\t\tit(\"should throw when updated directly\", function()\n\t\t\tlocal source = Binding.create(1)\n\t\t\tlocal mapped = source:map(function(v)\n\t\t\t\treturn v\n\t\t\tend)\n\n\t\t\texpect(function()\n\t\t\t\tBinding.update(mapped, 5)\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tdescribe(\"Binding.join\", function()\n\t\tit(\"should have getValue\", function()\n\t\t\tlocal binding1 = Binding.create(1)\n\t\t\tlocal binding2 = Binding.create(2)\n\t\t\tlocal binding3 = Binding.create(3)\n\n\t\t\tlocal joinedBinding = Binding.join({\n\t\t\t\tbinding1,\n\t\t\t\tbinding2,\n\t\t\t\tfoo = binding3,\n\t\t\t})\n\n\t\t\tlocal bindingValue = joinedBinding:getValue()\n\t\t\texpect(bindingValue).to.be.a(\"table\")\n\t\t\texpect(bindingValue[1]).to.equal(1)\n\t\t\texpect(bindingValue[2]).to.equal(2)\n\t\t\texpect(bindingValue.foo).to.equal(3)\n\t\tend)\n\n\t\tit(\"should update when any one of the subscribed bindings updates\", function()\n\t\t\tlocal binding1, update1 = Binding.create(1)\n\t\t\tlocal binding2, update2 = Binding.create(2)\n\t\t\tlocal binding3, update3 = Binding.create(3)\n\n\t\t\tlocal joinedBinding = Binding.join({\n\t\t\t\tbinding1,\n\t\t\t\tbinding2,\n\t\t\t\tfoo = binding3,\n\t\t\t})\n\n\t\t\tlocal spy = createSpy()\n\t\t\tBinding.subscribe(joinedBinding, spy.value)\n\n\t\t\texpect(spy.callCount).to.equal(0)\n\n\t\t\tupdate1(3)\n\t\t\texpect(spy.callCount).to.equal(1)\n\n\t\t\tlocal args = spy:captureValues(\"value\")\n\t\t\texpect(args.value).to.be.a(\"table\")\n\t\t\texpect(args.value[1]).to.equal(3)\n\t\t\texpect(args.value[2]).to.equal(2)\n\t\t\texpect(args.value[\"foo\"]).to.equal(3)\n\n\t\t\tupdate2(4)\n\t\t\texpect(spy.callCount).to.equal(2)\n\n\t\t\targs = spy:captureValues(\"value\")\n\t\t\texpect(args.value).to.be.a(\"table\")\n\t\t\texpect(args.value[1]).to.equal(3)\n\t\t\texpect(args.value[2]).to.equal(4)\n\t\t\texpect(args.value[\"foo\"]).to.equal(3)\n\n\t\t\tupdate3(8)\n\t\t\texpect(spy.callCount).to.equal(3)\n\n\t\t\targs = spy:captureValues(\"value\")\n\t\t\texpect(args.value).to.be.a(\"table\")\n\t\t\texpect(args.value[1]).to.equal(3)\n\t\t\texpect(args.value[2]).to.equal(4)\n\t\t\texpect(args.value[\"foo\"]).to.equal(8)\n\t\tend)\n\n\t\tit(\"should disconnect from all upstream bindings\", function()\n\t\t\tlocal binding1, update1 = Binding.create(1)\n\t\t\tlocal binding2, update2 = Binding.create(2)\n\n\t\t\tlocal joined = Binding.join({ binding1, binding2 })\n\n\t\t\tlocal spy = createSpy()\n\t\t\tlocal disconnect = Binding.subscribe(joined, spy.value)\n\n\t\t\texpect(spy.callCount).to.equal(0)\n\n\t\t\tupdate1(3)\n\t\t\texpect(spy.callCount).to.equal(1)\n\n\t\t\tupdate2(3)\n\t\t\texpect(spy.callCount).to.equal(2)\n\n\t\t\tdisconnect()\n\t\t\tupdate1(4)\n\t\t\texpect(spy.callCount).to.equal(2)\n\n\t\t\tupdate2(2)\n\t\t\texpect(spy.callCount).to.equal(2)\n\n\t\t\tlocal value = joined:getValue()\n\t\t\texpect(value[1]).to.equal(4)\n\t\t\texpect(value[2]).to.equal(2)\n\t\tend)\n\n\t\tit(\"should be okay with calling disconnect multiple times\", function()\n\t\t\tlocal joined = Binding.join({})\n\n\t\t\tlocal disconnect = Binding.subscribe(joined, function() end)\n\n\t\t\tdisconnect()\n\t\t\tdisconnect()\n\t\tend)\n\n\t\tit(\"should throw if updated directly\", function()\n\t\t\tlocal joined = Binding.join({})\n\n\t\t\texpect(function()\n\t\t\t\tBinding.update(joined, 0)\n\t\t\tend)\n\t\tend)\n\n\t\tit(\"should throw when a non-table value is passed\", function()\n\t\t\tGlobalConfig.scoped({\n\t\t\t\ttypeChecks = true,\n\t\t\t}, function()\n\t\t\t\texpect(function()\n\t\t\t\t\tBinding.join(\"hi\")\n\t\t\t\tend).to.throw()\n\t\t\tend)\n\t\tend)\n\n\t\tit(\"should throw when a non-binding value is passed via table\", function()\n\t\t\tGlobalConfig.scoped({\n\t\t\t\ttypeChecks = true,\n\t\t\t}, function()\n\t\t\t\texpect(function()\n\t\t\t\t\tlocal binding = Binding.create(123)\n\n\t\t\t\t\tBinding.join({\n\t\t\t\t\t\tbinding,\n\t\t\t\t\t\t\"abcde\",\n\t\t\t\t\t})\n\t\t\t\tend).to.throw()\n\t\t\tend)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Binding",
                        "ClassName": "ModuleScript",
                        "Source": "local createSignal = require(script.Parent.createSignal)\nlocal Symbol = require(script.Parent.Symbol)\nlocal Type = require(script.Parent.Type)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal BindingImpl = Symbol.named(\"BindingImpl\")\n\nlocal BindingInternalApi = {}\n\nlocal bindingPrototype = {}\n\nfunction bindingPrototype:getValue()\n\treturn BindingInternalApi.getValue(self)\nend\n\nfunction bindingPrototype:map(predicate)\n\treturn BindingInternalApi.map(self, predicate)\nend\n\nlocal BindingPublicMeta = {\n\t__index = bindingPrototype,\n\t__tostring = function(self)\n\t\treturn string.format(\"RoactBinding(%s)\", tostring(self:getValue()))\n\tend,\n}\n\nfunction BindingInternalApi.update(binding, newValue)\n\treturn binding[BindingImpl].update(newValue)\nend\n\nfunction BindingInternalApi.subscribe(binding, callback)\n\treturn binding[BindingImpl].subscribe(callback)\nend\n\nfunction BindingInternalApi.getValue(binding)\n\treturn binding[BindingImpl].getValue()\nend\n\nfunction BindingInternalApi.create(initialValue)\n\tlocal impl = {\n\t\tvalue = initialValue,\n\t\tchangeSignal = createSignal(),\n\t}\n\n\tfunction impl.subscribe(callback)\n\t\treturn impl.changeSignal:subscribe(callback)\n\tend\n\n\tfunction impl.update(newValue)\n\t\timpl.value = newValue\n\t\timpl.changeSignal:fire(newValue)\n\tend\n\n\tfunction impl.getValue()\n\t\treturn impl.value\n\tend\n\n\treturn setmetatable({\n\t\t[Type] = Type.Binding,\n\t\t[BindingImpl] = impl,\n\t}, BindingPublicMeta), impl.update\nend\n\nfunction BindingInternalApi.map(upstreamBinding, predicate)\n\tif config.typeChecks then\n\t\tassert(Type.of(upstreamBinding) == Type.Binding, \"Expected arg #1 to be a binding\")\n\t\tassert(typeof(predicate) == \"function\", \"Expected arg #1 to be a function\")\n\tend\n\n\tlocal impl = {}\n\n\tfunction impl.subscribe(callback)\n\t\treturn BindingInternalApi.subscribe(upstreamBinding, function(newValue)\n\t\t\tcallback(predicate(newValue))\n\t\tend)\n\tend\n\n\tfunction impl.update(_newValue)\n\t\terror(\"Bindings created by Binding:map(fn) cannot be updated directly\", 2)\n\tend\n\n\tfunction impl.getValue()\n\t\treturn predicate(upstreamBinding:getValue())\n\tend\n\n\treturn setmetatable({\n\t\t[Type] = Type.Binding,\n\t\t[BindingImpl] = impl,\n\t}, BindingPublicMeta)\nend\n\nfunction BindingInternalApi.join(upstreamBindings)\n\tif config.typeChecks then\n\t\tassert(typeof(upstreamBindings) == \"table\", \"Expected arg #1 to be of type table\")\n\n\t\tfor key, value in pairs(upstreamBindings) do\n\t\t\tif Type.of(value) ~= Type.Binding then\n\t\t\t\tlocal message = (\"Expected arg #1 to contain only bindings, but key %q had a non-binding value\"):format(\n\t\t\t\t\ttostring(key)\n\t\t\t\t)\n\t\t\t\terror(message, 2)\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal impl = {}\n\n\tlocal function getValue()\n\t\tlocal value = {}\n\n\t\tfor key, upstream in pairs(upstreamBindings) do\n\t\t\tvalue[key] = upstream:getValue()\n\t\tend\n\n\t\treturn value\n\tend\n\n\tfunction impl.subscribe(callback)\n\t\tlocal disconnects = {}\n\n\t\tfor key, upstream in pairs(upstreamBindings) do\n\t\t\tdisconnects[key] = BindingInternalApi.subscribe(upstream, function(_newValue)\n\t\t\t\tcallback(getValue())\n\t\t\tend)\n\t\tend\n\n\t\treturn function()\n\t\t\tif disconnects == nil then\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\tfor _, disconnect in pairs(disconnects) do\n\t\t\t\tdisconnect()\n\t\t\tend\n\n\t\t\tdisconnects = nil\n\t\tend\n\tend\n\n\tfunction impl.update(_newValue)\n\t\terror(\"Bindings created by joinBindings(...) cannot be updated directly\", 2)\n\tend\n\n\tfunction impl.getValue()\n\t\treturn getValue()\n\tend\n\n\treturn setmetatable({\n\t\t[Type] = Type.Binding,\n\t\t[BindingImpl] = impl,\n\t}, BindingPublicMeta)\nend\n\nreturn BindingInternalApi\n",
                        "Children": [],
                        "Archivable": true
                    }
                ],
                "Archivable": true
            }
        ]
    },
    {
        "ID": "MuX0Ete5HN",
        "Name": "Serializer",
        "Author": "DevCmb",
        "Description": "A roblox instance serializer to convert instances to dictionaries",
        "Downloads": 0,
        "Serialized": [
            {
                "Name": "Serializer",
                "ClassName": "ModuleScript",
                "Source": "local DataStoreService = game:GetService(\"DataStoreService\")\nlocal Properties = require(script.Properties)\nlocal serializer = {}\n\nfunction serializer:Serialize(instance: Instance)\n\tlocal serializedModel = {}\n\n\tif Properties[instance.ClassName] == nil then\n\t\twarn(\"Could not serialize type \" .. instance.ClassName .. \" because it is not supported by the properties file.\")\n\t\treturn\n\tend\n\n\tserializeToTable(instance, serializedModel)\n\treturn serializedModel\nend\n\nfunction serializeToTable(instance, _table)\n\tlocal properties = Properties[instance.ClassName] or {}\n\tlocal propertyData = {\n\t\t[\"ClassName\"] = instance.ClassName,\n\t\t[\"Children\"] = {}\n\t}\n\n\tfor _,property in pairs(properties) do \n\t\tlocal data = instance[property]\n\n\t\t-- Exceptions by type\n\t\tif typeof(data) == \"Color3\" or typeof(data) == \"BrickColor\" then\n\t\t\tif typeof(data) == \"BrickColor\" then data = data.Color end\n\t\t\tdata = {\n\t\t\t\tr = data.R,\n\t\t\t\tg = data.G,\n\t\t\t\tb = data.B\n\t\t\t}\n\t\telseif typeof(data) == \"UDim2\" then\n\t\t\tdata = {\n\t\t\t\txScale = data.X.Scale,\n\t\t\t\txOffset = data.X.Offset,\n\t\t\t\tyScale = data.Y.Scale,\n\t\t\t\tyOffset = data.Y.Offset\n\t\t\t}\n\t\telseif typeof(data) == \"UDim\" then\n\t\t\tdata = {\n\t\t\t\tScale = data.Scale,\n\t\t\t\tOffset = data.Offset\n\t\t\t}\n\t\telseif typeof(data) == \"Vector3\" then\n\t\t\tdata = {\n\t\t\t\tx = data.X,\n\t\t\t\ty = data.Y,\n\t\t\t\tz = data.Z\n\t\t\t}\n\t\telseif typeof(data) == \"Vector2\" then\n\t\t\tdata = {\n\t\t\t\tx = data.X,\n\t\t\t\ty = data.Y\n\t\t\t}\n\t\telseif typeof(data) == \"EnumItem\" then\n\t\t\tdata = {\n\t\t\t\tKey = data.EnumType,\n\t\t\t\tValue = data.Name,\n\t\t\t}\n\t\telseif property == \"Grip\" then\n\t\t\tdata = {\n\t\t\t\tPosition = {\n\t\t\t\t\tx = data.Position.X,\n\t\t\t\t\ty = data.Position.Y,\n\t\t\t\t\tz = data.Position.X\t\n\t\t\t\t},\n\t\t\t\tOrientation = {\n\t\t\t\t\tx = data.Orientation.X,\n\t\t\t\t\ty = data.Orientation.Y,\n\t\t\t\t\tz = data.Orientation.Z\n\t\t\t\t}\n\t\t\t}\n\t\tend\n\n\t\tpropertyData[property] = data\n\tend\t\n\n\tfor _,v in pairs(instance:GetChildren()) do\n\t\tserializeToTable(v, propertyData.Children)\n\tend\n\n\ttable.insert(_table, propertyData)\nend\n\nfunction serializer:Deserialize(_table, parent)\n\tlocal firstObject = _table[1]\n\tif firstObject == nil or firstObject.ClassName == nil then return end\n\treturn deserializeToParent(firstObject, parent or game.ReplicatedStorage)\nend\n\nfunction deserializeToParent(_table, parent)\n\tlocal ins = Instance.new(_table.ClassName, parent)\n\tlocal properties = Properties[ins.ClassName] or {}\n\n\tfor _,v in pairs(properties) do\n\t\tif v == \"Grip\" then\n\t\t\tins[v].Position = _table[v].Position\n\t\t\tins[v].Orientation = _table[v].Orientation\n\t\telseif typeof(_table[v]) ~= \"table\" then\n\t\t\tins[v] = _table[v]\n\t\telseif _table[v].xScale ~= nil and _table[v].xOffset ~= nil and _table[v].yScale ~= nil and _table[v].yOffset ~= nil then\n\t\t\tins[v] = UDim2.new(_table[v].xScale, _table[v].xOffset, _table[v].yScale, _table[v].yOffset)\n\t\telseif _table[v].Scale ~= nil and _table[v].Offset ~= nil then\n\t\t\tins[v] = UDim.new(_table[v].Scale, _table[v].Offset)\n\t\telseif _table[v].X ~= nil and _table[v].Y ~= nil and _table[v].Z ~= nil then\n\t\t\tins[v] = Vector3.new(_table[v].X, _table[v].Y, _table[v].Z)\n\t\telseif _table[v].X ~= nil and _table[v].Y ~= nil and _table[v].Z == nil then\n\t\t\tins[v] = Vector2.new(_table[v].X, _table[v].Y)\n\t\telseif _table[v].r ~= nil and _table[v].g ~= nil and _table[v].b ~= nil then\n\t\t\tins[v] = Color3.new(_table[v].r, _table[v].g, _table[v].b)\n\t\telseif _table[v].Key ~= nil and _table[v].Value ~= nil then\n\t\t\tins[v] = _table[v].Value\n\t\tend\n\tend\n\n\tfor _,child in pairs(_table.Children) do \n\t\tdeserializeToParent(child, ins)\n\tend\n\n\treturn ins\nend\n\nreturn serializer",
                "Children": [
                    {
                        "Name": "Properties",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\n    This was typed by hand\n    Someone help me\n\n]]\n\nreturn {\n    [\"Part\"] = {\n        -- Appearance\n        \"CastShadow\",\n        \"Color\",\n        \"Material\",\n        \"MaterialVariant\",\n        \"Reflectance\",\n        \"Transparency\",\n        -- Data\n        \"Archivable\",\n        \"Locked\",\n        \"Name\",\n        -- Transform\n        \"Size\",\n        \"Position\",\n        \"Orientation\",\n        -- Collision\n        \"CanCollide\",\n        \"CanTouch\",\n        \"CanQuery\",\n        -- Part\n        \"Anchored\",\n        \"Massless\",\n        \"Shape\"\n    },\n    [\"SpawnLocation\"] = {\n        -- Appearance\n        \"CastShadow\",\n        \"Color\",\n        \"Material\",\n        \"MaterialVariant\",\n        \"Reflectance\",\n        \"Transparency\",\n        -- Data\n        \"Archivable\",\n        \"Locked\",\n        \"Name\",\n        -- Transform\n        \"Size\",\n        \"Position\",\n        \"Orientation\",\n        -- Collision\n        \"CanCollide\",\n        \"CanTouch\",\n        \"CanQuery\",\n        -- Part\n        \"Anchored\",\n        \"Massless\",\n        \"Shape\",\n        -- Teams\n        \"AllowTeamChangeOnTouch\",\n        \"Neutral\",\n        \"TeamColor\"\n    },\n    [\"MeshPart\"] = {\n        -- Appearance\n        \"CastShadow\",\n        \"Color\",\n        \"DoubleSided\",\n        \"Material\",\n        \"MaterialVariant\",\n        \"MeshId\",\n        \"Reflectance\",\n        \"RenderFidelity\",\n        \"TextureID\",\n        \"Transparency\",\n        -- Data\n        \"Archivable\",\n        \"Locked\",\n        \"Name\",\n        -- Transform\n        \"Size\",\n        \"Position\",\n        \"Orientation\",\n        -- Collision\n        \"CanCollide\",\n        \"CanTouch\",\n        \"CanQuery\",\n        -- Part\n        \"Anchored\",\n        \"Massless\"\n    },\n    [\"UnionOperation\"] = {\n        -- Appearance\n        \"CastShadow\",\n        \"Color\",\n        \"Material\",\n        \"MaterialVariant\",\n        \"Reflectance\",\n        \"RenderFidelity\",\n        \"SmoothingAngle\",\n        \"Transparency\",\n        -- Data\n        \"Archivable\",\n        \"Locked\",\n        \"Name\",\n        \"UsePartColor\",\n        -- Transform\n        \"Size\",\n        \"Position\",\n        \"Orientation\",\n        -- Collision\n        \"CanCollide\",\n        \"CanTouch\",\n        \"CanQuery\",\n        \"CollisionFidelity\",\n        -- Part\n        \"Anchored\",\n        \"Massless\"\n    },\n    [\"Model\"] = {\n        -- Data\n        \"Archivable\",\n        \"Name\",\n        \"PrimaryPart\"\n    },\n    [\"Folder\"] = {\n        -- Data\n        \"Archivable\",\n        \"Name\"\n    },\n    [\"Configuration\"] = {\n        -- Data\n        \"Archivable\",\n        \"Name\"\n    },\n    [\"Tool\"] = {\n        -- Appearance\n        \"ToolTip\",\n        -- Data\n        \"Archivable\",\n        \"Name\",\n        \"TextureId\",\n        -- Transform\n        \"Grip\",\n        -- Behavior\n        \"CanBeDropped\",\n        \"ManualActivationOnly\",\n        \"RequiresHandle\",\n        -- State\n        \"Enabled\"\n    },\n    [\"Script\"] = {\n        -- Data\n        \"Archivable\",\n        \"Name\",\n        -- Behavior\n        \"Enabled\",\n        \"RunContext\",\n        -- Hidden\n        \"Source\" -- only run if security check is high enough\n    },\n    [\"LocalScript\"] = {\n        -- Data\n        \"Archivable\",\n        \"Name\",\n        -- Behavior\n        \"Enabled\",\n        -- Hidden\n        \"Source\" -- only run if security check is high enough\n    },\n    [\"ModuleScript\"] = {\n        -- Data\n        \"Archivable\",\n        \"Name\",\n        -- Hiddden\n        \"Source\"\n    },\n    [\"Frame\"] = {\n        -- Data\n        \"Archivable\",\n        \"Active\",\n        \"AnchorPoint\",\n        \"BackgroundColor3\",\n        \"BackgroundTransparency\",\n        \"BorderColor3\",\n        \"BorderMode\",\n        \"BorderSizePixel\",\n        \"Interactable\",\n        \"LayoutOrder\",\n        \"Name\",\n        \"Position\",\n        \"Rotation\",\n        \"Size\",\n        \"SizeConstraint\",\n        \"Style\",\n        \"Visible\",\n        \"ZIndex\",\n        -- Behavior\n        \"ClipsDescendants\",\n    },\n    [\"ScreenGui\"] = {\n        -- Appearance\n        \"ClipToDeviceSafeArea\",\n        \"SafeAreaCompatibility\",\n        \"ScreenInsets\",\n        -- Data\n        \"Archivable\",\n        \"DisplayOrder\",\n        \"Enabled\",\n        \"IgnoreGuiInset\",\n        \"Name\",\n        \"ResetOnSpawn\",\n        \"ZIndexBehavior\"\n    },\n    [\"TextButton\"] = {\n        -- Data\n        \"Archivable\",\n        \"Active\",\n        \"AnchorPoint\",\n        \"AutoButtonColor\",\n        \"BackgroundColor3\",\n        \"BackgroundTransparency\",\n        \"BorderColor3\",\n        \"BorderMode\",\n        \"BorderSizePixel\",\n        \"Interactable\",\n        \"LayoutOrder\",\n        \"Name\",\n        \"Position\",\n        \"Rotation\",\n        \"Size\",\n        \"SizeConstraint\",\n        \"Style\",\n        \"Visible\",\n        \"ZIndex\",\n        -- Behavior\n        \"ClipsDescendants\",\n        -- Text\n        \"Font\",\n        \"LineHeight\",\n        \"MaxVisibleGraphemes\",\n        \"RichText\",\n        \"Text\",\n        \"TextColor3\",\n        \"TextDirection\",\n        \"TextScaled\",\n        \"TextSize\",\n        \"TextStrokeColor3\",\n        \"TextStrokeTransparency\",\n        \"TextTransparency\",\n        \"TextTruncate\",\n        \"TextWrapped\",\n        \"TextXAlignment\",\n        \"TextYAlignment\"\n    },\n    [\"TextLabel\"] = {\n        -- Data\n        \"Archivable\",\n        \"Active\",\n        \"AnchorPoint\",\n        \"BackgroundColor3\",\n        \"BackgroundTransparency\",\n        \"BorderColor3\",\n        \"BorderMode\",\n        \"BorderSizePixel\",\n        \"Interactable\",\n        \"LayoutOrder\",\n        \"Name\",\n        \"Position\",\n        \"Rotation\",\n        \"Size\",\n        \"SizeConstraint\",\n        \"Visible\",\n        \"ZIndex\",\n        -- Behavior\n        \"ClipsDescendants\",\n        -- Text\n        \"Font\",\n        \"LineHeight\",\n        \"MaxVisibleGraphemes\",\n        \"RichText\",\n        \"Text\",\n        \"TextColor3\",\n        \"TextDirection\",\n        \"TextScaled\",\n        \"TextSize\",\n        \"TextStrokeColor3\",\n        \"TextStrokeTransparency\",\n        \"TextTransparency\",\n        \"TextTruncate\",\n        \"TextWrapped\",\n        \"TextXAlignment\",\n        \"TextYAlignment\"\n    },\n    [\"ImageLabel\"] = {\n        -- Data\n        \"Archivable\",\n        \"Active\",\n        \"AnchorPoint\",\n        \"BackgroundColor3\",\n        \"BackgroundTransparency\",\n        \"BorderColor3\",\n        \"BorderMode\",\n        \"BorderSizePixel\",\n        \"Interactable\",\n        \"LayoutOrder\",\n        \"Name\",\n        \"Position\",\n        \"Rotation\",\n        \"Size\",\n        \"SizeConstraint\",\n        \"Visible\",\n        \"ZIndex\",\n        -- Behavior\n        \"ClipsDescendants\",\n        -- Image\n        \"Image\",\n        \"ImageColor3\",\n        \"ImageRectOffset\",\n        \"ImageRectSize\",\n        \"ImageTransparency\",\n        \"ResampleMode\",\n        \"ScaleType\"\n    },\n    [\"ImageButton\"] = {\n        -- Data\n        \"Archivable\",\n        \"Active\",\n        \"AnchorPoint\",\n        \"AutoButtonColor\",\n        \"BackgroundColor3\",\n        \"BackgroundTransparency\",\n        \"BorderColor3\",\n        \"BorderMode\",\n        \"BorderSizePixel\",\n        \"Interactable\",\n        \"LayoutOrder\",\n        \"Name\",\n        \"Position\",\n        \"Rotation\",\n        \"Size\",\n        \"SizeConstraint\",\n        \"Style\",\n        \"Visible\",\n        \"ZIndex\",\n        -- Behavior\n        \"ClipsDescendants\",\n        -- Image\n        \"Image\",\n        \"ImageColor3\",\n        \"ImageRectOffset\",\n        \"ImageRectSize\",\n        \"ImageTransparency\",\n        \"ResampleMode\",\n        \"ScaleType\"\n    },\n    [\"TextBox\"] = {\n        -- Data\n        \"Archivable\",\n        \"Active\",\n        \"AnchorPoint\",\n        \"AutoButtonColor\",\n        \"BackgroundColor3\",\n        \"BackgroundTransparency\",\n        \"BorderColor3\",\n        \"BorderMode\",\n        \"BorderSizePixel\",\n        \"ClearTextOnFocus\",\n        \"CursorPosition\",\n        \"Interactable\",\n        \"LayoutOrder\",\n        \"MultiLine\",\n        \"Name\",\n        \"Position\",\n        \"Rotation\",\n        \"SelectionStart\",\n        \"ShowNativeInput\",\n        \"Size\",\n        \"SizeConstraint\",\n        \"TextEditable\",\n        \"Visible\",\n        \"ZIndex\",\n        -- Behavior\n        \"ClipsDescendants\",\n        -- Text\n        \"Font\",\n        \"LineHeight\",\n        \"MaxVisibleGraphemes\",\n        \"PlaceholderColor3\",\n        \"PlaceholderText\",\n        \"RichText\",\n        \"Text\",\n        \"TextColor3\",\n        \"TextDirection\",\n        \"TextScaled\",\n        \"TextSize\",\n        \"TextStrokeColor3\",\n        \"TextStrokeTransparency\",\n        \"TextTransparency\",\n        \"TextTruncate\",\n        \"TextWrapped\",\n        \"TextXAlignment\",\n        \"TextYAlignment\"\n    },\n    -- UI Modifiers\n    [\"UIAspectRatioConstraint\"] = {\n        -- Data\n        \"Archivable\",\n        \"Name\",\n        -- Behavior\n        \"AspectRatio\",\n        \"AspectType\",\n        \"DominantAxis\"\n    },\n    [\"UISizeConstraint\"] = {\n        -- Data\n        \"Archivable\",\n        \"Name\",\n        -- Behavior\n        \"MaxSize\",\n        \"MinSize\"\n    },\n    [\"UITextSizeConstraint\"] = {\n        -- Data\n        \"Archivable\",\n        \"Name\",\n        -- Behavior\n        \"MaxTextSize\",\n        \"MinTextSize\"\n    },\n    [\"UICorner\"] = {\n        -- Appearance\n        \"CornerRadius\",\n        -- Data\n        \"Archivable\",\n        \"Name\"\n    },\n    [\"UIGridLayout\"] = {\n        -- Appearance\n        \"CellPadding\",\n        \"CellSize\",\n        -- Data\n        \"Archivable\",\n        \"Name\",\n        -- Finally! One with more than just 2!\n        -- Behavior\n        \"FillDirection\",\n        \"FillDirectionMaxCells\",\n        \"SortOrder\",\n        \"StartCorner\",\n        -- Alignment\n        \"HorizontalAlignment\",\n        \"VerticalAlignment\"\n    },\n    [\"UIListLayout\"] = {\n        -- Appearance\n        \"Padding\",\n        -- Data\n        \"Archivable\",\n        \"Name\",\n        -- Behavior\n        \"FillDirection\",\n        \"SortOrder\",\n        \"Wraps\",\n        -- Alignment\n        \"HorizontalAlignment\",\n        \"HorizontalFlex\",\n        \"ItemLineAlignment\",\n        \"VerticalAlignment\",\n        \"VerticalFlex\"\n    },\n    [\"UIPageLayout\"] = {\n        -- Appearance\n        \"Animated\",\n        \"Circular\",\n        \"EasingDirection\",\n        \"EasingStyle\",\n        \"Padding\",\n        \"TweenTime\",\n        -- Data\n        \"Archivable\",\n        \"Name\",\n        -- Behavior\n        \"FillDirection\",\n        \"SortOrder\",\n        -- Alignment\n        \"HorizontalAlignment\",\n        \"VerticalAlignment\",\n        -- Input\n        \"GamepadInputEnabled\",\n        \"ScrollWheelInputEnabled\",\n        \"TouchInputEnabled\"\n    },\n    [\"UITableLayout\"] = {\n        -- Appearance\n        \"FillEmptySpaceColumns\",\n        \"FillEmptySpaceRows\",\n        \"Padding\",\n        -- Data\n        \"Archivable\",\n        \"Name\",\n        -- Behavior\n        \"FillDirection\",\n        \"MajorAxis\",\n        \"SortOrder\",\n        -- Alignment\n        \"HorizontalAlignment\",\n        \"VerticalAlignment\"\n    },\n    [\"UIPadding\"] = {\n        -- Data\n        \"Archivable\",\n        \"Name\",\n        -- Behavior\n        \"PaddingBottom\",\n        \"PaddingLeft\",\n        \"PaddingRight\",\n        \"PaddingTop\"\n    },\n    [\"UIScale\"] = {\n        -- Data\n        \"Archivable\",\n        \"Name\",\n        -- Behavior\n        \"Scale\"\n    },\n    [\"UIStroke\"] = {\n        -- Appearance\n        \"ApplyStrokeMode\",\n        \"Color\",\n        \"LineJoinMode\",\n        \"Thickness\",\n        \"Transparency\",\n        -- Data\n        \"Archivable\",\n        \"Enabled\",\n        \"Name\"\n    }\n}",
                        "Children": [],
                        "Archivable": true
                    }
                ],
                "Archivable": true
            }
        ]
    },
    {
        "ID": "jkXiKCMGhq",
        "Name": "ClusteredDebugService",
        "Author": "DevCmb",
        "Description": "Seperates different debug functions into clusters, being able to turn them on and off.",
        "Downloads": 0,
        "Serialized": [
            {
                "Name": "ClusteredDebugService",
                "ClassName": "ModuleScript",
                "Source": "\n--[[\n\n\tCreated by DevCmb (@29ce)\n\t\n\t_________ ________    _________\n\t\\_   ___ \\\\______ \\  /   _____/\n\t/    \\  \\/ |    |  \\ \\_____  \\ \n\t\\     \\____|    `   \\/        \\\n\t \\______  /_______  /_______  /\n\t        \\/        \\/        \\/ \n\t\n\tDescription: Puts debug items into different clusters for developers to organize their errors and to not clog their consoles\n\tCreated: 5/5/24\n\tLast Modified: 5/25/24\n\t\n\tTypes:\n\t\tClusteredDebugService:\n\t\t\tClusters: {Cluster}\n\t\t\tActiveClusters: {string}\n\t\tCluster:\n\t\t\tClusterLog: {any}\n\t\t\t\n\tMethods:\n\t\tClusteredDebugService:\n\t\t\tnew(name) -> Cluster\n\t\t\t\tCreates a cluster or hooks into a new one\n\t\t\t\t\n\t\t\t\tname: string\n\t\t\tEnableAll(cds) -> nil\n\t\t\t\tEnable all clusters\n\t\t\t\t\n\t\t\t\tcds: ClusteredDebugService (self, call with a colon (:EnableAll))\n\t\t\tDisableAll(cds) -> nil\n\t\t\t\tDisable all clusters\n\t\t\t\t\n\t\t\t\tcds: ClusteredDebugService (self, call with a colon (:DisableAll))\n\t\tCluster:\n\t\t\tLog(cluster, ...) -> Cluster\n\t\t\t\tLog an item to the cluster log, if enabled, log it to console using print()\n\t\t\t\t\n\t\t\t\tcluster: Cluster (self, call with a colon (:Log))\n\t\t\t\t...: string (any amount of strings to pass, will print through spacing)\n\t\t\tWarn(cluster, ...) -> Cluster\n\t\t\t\tAdd a warning item to the cluster log, if enabled, log it to console using warn()\n\t\t\t\t\n\t\t\t\tcluster: Cluster (self, call with a colon (:Warn))\n\t\t\t\t...: string (any amount of strings to pass, will print through spacing)\n\t\t\tError(cluster, ...) -> Cluster\n\t\t\t\tAdd an error item to the cluster log, if enabled, log it to console using error()\n\t\t\t\t\n\t\t\t\tcluster: Cluster (self, call with a colon (:Error))\n\t\t\t\t...: string (any amount of strings to pass, will print through spacing)\n\t\t\tCustom(cluster, log, func) -> Cluster\n\t\t\t\tAppends an item through a custom function\n\t\t\t\t\n\t\t\t\tcluster: Cluster (self, call with a colon (:Custom))\n\t\t\t\tlog: string\n\t\t\t\tfunc: () -> any\n\t\t\tGet(cluster, query, method) -> Cluster\n\t\t\t\tRequests all items from a cluster that follow a specific query (will be printed to console)\n\t\t\t\t\n\t\t\t\tcluster: Cluster (self, call with a colon (:Get))\n\t\t\t\tquery: string? (can be nil to return all items)\n\t\t\t\tmethod: \"starts\" | \"contains\" | \"ends\" | nil (will only be used if query is not nil)\n\t\t\tClear(cluster) -> Cluster\n\t\t\t\tRemoves all logs from the cluster\n\t\t\t\t\n\t\t\t\tcluster: Cluster (self, call with a colon (:Clear))\n\t\t\tDelete(cluster) -> nil\n\t\t\t\tDeletes the cluster\n\t\t\t\t\n\t\t\t\tcluster: Cluster (self, call with a colon (:Delete))\n\t\t\tActivate(cluster) -> Cluster\n\t\t\t\tActivates the cluster for active logging\n\t\t\t\t\n\t\t\t\tcluster: Cluster (self, call with a colon (:Activate))\n\t\t\tDeactivate(cluster) -> Cluster\n\t\t\t\tDeactivate the cluster to disable active logging\n\t\t\t\t\n\t\t\t\tcluster: Cluster (self, call with a colon (:Deactivate))\n\t\n\tCommon use cases\n\t\tPlayer join tracker:\n\t\t\n\t\t\tlocal cds = require(game.ReplicatedStorage.Modules.ClusteredDebugService)\n\t\t\tlocal logger = cds.new(\"PlayerJoins\"):Activate()\n\t\t\t\n\t\t\tgame.Players.PlayerAdded:Connect(function(player)\n\t\t\t\tlogger:Log(player.Name .. \" joined the game!\")\n\t\t\tend)\n\t\t\t\n\t\t\tgame.Players.PlayerRemoved:Connect(function(player)\n\t\t\t\tlogger:Log(player.Name .. \" left the game.\")\n\t\t\tend)\n\t\t\t\n\t\tLow-priority error handling:\n\t\t\n\t\t\tlocal cds = require(game.ReplicatedStorage.Modules.ClusteredDebugService)\n\t\t\tlocal logger = cds.new(\"LowLevel\") -- Can be activated and fetched later if a developer needs to access it.\n\t\t\t\n\t\t\txpcall(function()\n\t\t\t\t-- some function\n\t\t\tend, function(err, stack)\n\t\t\t\tlogger:Error(err, stack)\n\t\t\tend)\n\t\t\t\n]]\nlocal Types = require(script.Types)\n\nlocal ClusteredDebugService = {} :: Types.ClusteredDebugService\nClusteredDebugService.Clusters = {}\nClusteredDebugService.ActiveClusters = {}\n\nfunction ClusteredDebugService.new(name: string) : Types.Cluster -- New cluster\n\tif ClusteredDebugService.Clusters[name] then\n\t\treturn ClusteredDebugService.Clusters[name]\n\tend\n\t\n\tlocal cluster  = {\n\t\tClusterLog = {}\n\t}\n\t\n\tfunction cluster:Log(...)\n\t\tlocal log = table.concat({...}, \" \")\n\t\t\n\t\tif table.find(ClusteredDebugService.ActiveClusters, name) then\n\t\t\tprint(log)\n\t\tend\n\t\tlocal Date = DateTime.now():ToLocalTime()\n\t\ttable.insert(ClusteredDebugService.Clusters[name].ClusterLog, {`{Date.Hour}:{Date.Minute}:{Date.Second}:{Date.Millisecond}  {log}`, print})\n\t\treturn cluster\n\tend\n\t\n\tfunction cluster:Warn(...)\n\t\tlocal log = table.concat({...}, \" \")\n\t\tif table.find(ClusteredDebugService.ActiveClusters, name) then\n\t\t\twarn(log)\n\t\tend\n\t\tlocal Date = DateTime.now():ToLocalTime()\n\t\ttable.insert(ClusteredDebugService.Clusters[name].ClusterLog, {`{Date.Hour}:{Date.Minute}:{Date.Second}:{Date.Millisecond}  {log}`, warn})\n\t\treturn cluster\n\tend\n\t\n\tfunction cluster:Error(...)\n\t\tlocal log = table.concat({...}, \" \")\n\t\tif table.find(ClusteredDebugService.ActiveClusters, name) then\n\t\t\terror(log)\n\t\tend\n\t\tlocal Date = DateTime.now():ToLocalTime()\n\t\ttable.insert(ClusteredDebugService.Clusters[name].ClusterLog, {`{Date.Hour}:{Date.Minute}:{Date.Second}:{Date.Millisecond}  {log}`, error})\n\t\treturn cluster\n\tend\n\t\n\tfunction cluster:Custom(log, func: (string) -> any)\n\t\tif table.find(ClusteredDebugService.ActiveClusters, name) then\n\t\t\tfunc(log)\n\t\tend\n\t\t\n\t\tlocal Date = DateTime.now():ToLocalTime()\n\t\ttable.insert(ClusteredDebugService.Clusters[name].ClusterLog, {`{Date.Hour}:{Date.Minute}:{Date.Second}:{Date.Millisecond}  {log}`, func})\n\t\treturn cluster\n\tend\n\t\n\tlocal function startsWith(str, start)\n\t\treturn string.sub(str, 1, string.len(start)) == start\n\tend\n\t\n\tlocal function endsWith(str, ending)\n\t\treturn ending == \"\" or str:sub(-#ending) == ending\n\tend\n\t\n\tfunction cluster:Get(query: string | nil, method: \"starts\" | \"contains\" | \"ends\" | nil)\n\t\tif (not method and query) then method = \"contains\" end\n\t\tprint(\"All logged messages will be sent in 2 seconds.\")\n\t\ttask.wait(2)\n\t\tfor l,log in pairs(cluster.ClusterLog) do\n\t\t\tif query then\n\t\t\t\tif method == \"starts\" then\n\t\t\t\t\tif startsWith(log[1], query) then\n\t\t\t\t\t\tlog[2](log[1])\n\t\t\t\t\tend\n\t\t\t\telseif method == \"contains\" then\n\t\t\t\t\tif string.find(log[1], query) then\n\t\t\t\t\t\tlog[2](log[1])\n\t\t\t\t\tend\n\t\t\t\telseif method == \"ends\" then\n\t\t\t\t\tif endsWith(log[1], query) then\n\t\t\t\t\t\tlog[2](log[1])\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tlog[2](log[1])\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tlog[2](log[1])\n\t\t\tend\n\t\tend\n\t\treturn cluster\n\tend\n\t\n\tfunction cluster:Clear()\n\t\ttable.clear(cluster.ClusterLog)\n\t\tcluster:Log(`Cluster {name} has been cleared.`)\n\t\treturn cluster\n\tend\n\t\n\tfunction cluster:Delete()\n\t\tprint(`Cluster {name} has been deleted.`)\n\t\tClusteredDebugService.Clusters[name] = nil\n\tend\n\t\n\tfunction cluster:Activate()\n\t\tif not table.find(ClusteredDebugService.ActiveClusters, name) then\n\t\t\ttable.insert(ClusteredDebugService.ActiveClusters, name)\n\t\tend\n\t\tprint(`Activated {name} cluster successfully.`)\n\t\t\n\t\treturn cluster\n\tend\n\t\n\tfunction cluster:Deactivate()\n\t\tif table.find(ClusteredDebugService.ActiveClusters, name) then\n\t\t\ttable.remove(ClusteredDebugService.ActiveClusters, table.find(ClusteredDebugService.ActiveClusters, name))\n\t\tend\n\t\tprint(`Deactivated {name} cluster successfully.`)\n\t\t\n\t\treturn cluster\n\tend\n\t\n\tClusteredDebugService.Clusters[name] = cluster\n\t\n\treturn cluster\nend\n\nfunction ClusteredDebugService:EnableAll()\n\tfor cluster,_ in pairs(ClusteredDebugService.Clusters) do\n\t\tif not table.find(ClusteredDebugService.ActiveClusters, cluster) then\n\t\t\ttable.insert(ClusteredDebugService.ActiveClusters, cluster)\n\t\tend\n\tend\nend\n\nfunction ClusteredDebugService:DisableAll()\n\ttable.clear(ClusteredDebugService.ActiveClusters)\nend\n\nreturn ClusteredDebugService",
                "Children": [
                    {
                        "Name": "Types",
                        "ClassName": "ModuleScript",
                        "Source": "--!nocheck\nlocal types = {}\n\nexport type Cluster = {\n\tClusterLog: {{any}},\n\t\n\tLog: (self: Cluster, any...) -> Cluster,\n\tWarn: (self: Cluster, any...) -> Cluster,\n\tError: (self: Cluster, any...) -> Cluster,\n\tCustom: (self: Cluster, log: string, () -> any) -> Cluster,\n\tGet: (self: Cluster, query: string | nil, method: \"starts\" | \"contains\" | \"ends\" | nil) -> Cluster,\n\tClear: (self: Cluster) -> Cluster,\n\tDelete: (self: Cluster) -> nil,\n\tActivate: (self: Cluster) -> Cluster,\n\tDeactivate: (self: Cluster) -> Cluster\n}\n\nexport type ClusteredDebugService = {\n\tClusters: {Cluster},\n\tActiveClusters: {string},\n\tnew: (name: string) -> Cluster,\n\tEnableAll: (self: ClusteredDebugService) -> nil,\n\tDisableAll: (self: ClusteredDebugService) -> nil\n}\n\nreturn types",
                        "Children": [],
                        "Archivable": true
                    }
                ],
                "Archivable": true
            }
        ]
    },
    {
        "ID": "EX5JNQoBjC",
        "Name": "FastCastRedux",
        "Author": "Xan_TheDragon",
        "Description": "A physics-independant weapons framework for raycast weapons",
        "Downloads": 0,
        "Serialized": [
            {
                "Name": "FastCastRedux",
                "ClassName": "ModuleScript",
                "Source": "--!nocheck\n--^ change to strict to crash studio c:\n\n--[[\n\tWritten by Eti the Spirit (18406183)\n\t\n\t\tThe latest patch notes can be located here (and do note, the version at the top of this script might be outdated. I have a thing for forgetting to change it):\n\t\t>\thttps://etithespirit.github.io/FastCastAPIDocs/changelog\n\t\t\n\t\t*** If anything is broken, please don't hesitate to message me! ***\n\t\t\n\t\tYOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs\n\t\tYOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs\n\t\tYOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs\n\t\t\n\t\tYOU SHOULD ONLY CREATE ONE CASTER PER GUN.\n\t\tYOU SHOULD >>>NEVER<<< CREATE A NEW CASTER EVERY TIME THE GUN NEEDS TO BE FIRED.\n\t\t\n\t\tA caster (created with FastCast.new()) represents a \"gun\".\n\t\tWhen you consider a gun, you think of stats like accuracy, bullet speed, etc. This is the info a caster stores. \n\t\n\t--\n\t\n\tThis is a library used to create hitscan-based guns that simulate projectile physics.\n\t\n\tThis means:\n\t\t- You don't have to worry about bullet lag / jittering\n\t\t- You don't have to worry about keeping bullets at a low speed due to physics being finnicky between clients\n\t\t- You don't have to worry about misfires in bullet's Touched event (e.g. where it may going so fast that it doesn't register)\n\t\t\n\tHitscan-based guns are commonly seen in the form of laser beams, among other things. Hitscan simply raycasts out to a target\n\tand says whether it hit or not.\n\t\n\tUnfortunately, while reliable in terms of saying if something got hit or not, this method alone cannot be used if you wish\n\tto implement bullet travel time into a weapon. As a result of that, I made this library - an excellent remedy to this dilemma.\n\t\n\tFastCast is intended to be require()'d once in a script, as you can create as many casters as you need with FastCast.new()\n\tThis is generally handy since you can store settings and information in these casters, and even send them out to other scripts via events\n\tfor use.\n\t\n\tRemember -- A \"Caster\" represents an entire gun (or whatever is launching your projectiles), *NOT* the individual bullets.\n\tMake the caster once, then use the caster to fire your bullets. Do not make a caster for each bullet.\n--]]\n\n-----------------------------------------------------------\n-------------------- MODULE DEFINITION --------------------\n-----------------------------------------------------------\n\nlocal FastCast = {}\nFastCast.DebugLogging = false\nFastCast.VisualizeCasts = false\nFastCast.__index = FastCast\nFastCast.__type = \"FastCast\" -- For compatibility with TypeMarshaller\n\n-- Extra stuff\nFastCast.HighFidelityBehavior = {\n\tDefault = 1,\n\tAlways = 3,\n}\n\n-----------------------------------------------------------\n----------------------- STATIC DATA -----------------------\n-----------------------------------------------------------\nlocal ActiveCastStatic = require(script.ActiveCast)\nlocal Signal = require(script.Signal)\nlocal table = require(script.Table)\n\n-- Format params: methodName, ctorName\nlocal ERR_NOT_INSTANCE =\n\t\"Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s\"\n\n-- Format params: paramName, expectedType, actualType\nlocal ERR_INVALID_TYPE = \"Invalid type for parameter '%s' (Expected %s, got %s)\"\n\n-- The name of the folder containing the 3D GUI elements for visualizing casts.\nlocal FC_VIS_OBJ_NAME = \"FastCastVisualizationObjects\"\n\n-- Format params: N/A\nlocal ERR_OBJECT_DISPOSED = \"This Caster has been disposed. It can no longer be used.\"\n\n-----------------------------------------------------------\n--------------------- TYPE DEFINITION ---------------------\n-----------------------------------------------------------\n\n-- This will inject all types into this context.\nlocal TypeDefs = require(script.TypeDefinitions)\ntype CanPierceFunction = TypeDefs.CanPierceFunction\ntype GenericTable = TypeDefs.GenericTable\ntype Caster = TypeDefs.Caster\ntype FastCastBehavior = TypeDefs.FastCastBehavior\ntype CastTrajectory = TypeDefs.CastTrajectory\ntype CastStateInfo = TypeDefs.CastStateInfo\ntype CastRayInfo = TypeDefs.CastRayInfo\ntype ActiveCast = TypeDefs.ActiveCast\n\n-----------------------------------------------------------\n----------------------- STATIC CODE -----------------------\n-----------------------------------------------------------\n\n-- Tell the ActiveCast factory module what FastCast actually *is*.\nActiveCastStatic.SetStaticFastCastReference(FastCast)\n\n-----------------------------------------------------------\n------------------------- EXPORTS -------------------------\n-----------------------------------------------------------\n\n-- Constructor.\nfunction FastCast.new()\n\treturn setmetatable({\n\t\tLengthChanged = Signal.new(\"LengthChanged\"),\n\t\tRayHit = Signal.new(\"RayHit\"),\n\t\tRayPierced = Signal.new(\"RayPierced\"),\n\t\tCastTerminating = Signal.new(\"CastTerminating\"),\n\t\tWorldRoot = workspace,\n\t}, FastCast)\nend\n\n-- Create a new ray info object.\n-- This is just a utility alias with some extra type checking.\nfunction FastCast.newBehavior(): FastCastBehavior\n\t-- raycastParams, maxDistance, acceleration, canPierceFunction, cosmeticBulletTemplate, cosmeticBulletContainer, autoIgnoreBulletContainer\n\treturn {\n\t\tRaycastParams = nil,\n\t\tAcceleration = Vector3.new(),\n\t\tMaxDistance = 1000,\n\t\tCanPierceFunction = nil,\n\t\tHighFidelityBehavior = FastCast.HighFidelityBehavior.Default,\n\t\tHighFidelitySegmentSize = 0.5,\n\t\tCosmeticBulletTemplate = nil,\n\t\tCosmeticBulletProvider = nil,\n\t\tCosmeticBulletContainer = nil,\n\t\tAutoIgnoreContainer = true,\n\t}\nend\n\nlocal DEFAULT_DATA_PACKET = FastCast.newBehavior()\nfunction FastCast:Fire(\n\torigin: Vector3,\n\tdirection: Vector3,\n\tvelocity: Vector3 | number,\n\tcastDataPacket: FastCastBehavior?\n): ActiveCast\n\tif castDataPacket == nil then\n\t\tcastDataPacket = DEFAULT_DATA_PACKET\n\tend\n\n\tlocal cast = ActiveCastStatic.new(self, origin, direction, velocity, castDataPacket)\n\tcast.RayInfo.WorldRoot = self.WorldRoot\n\treturn cast\nend\n\n-- Export\nreturn FastCast",
                "Children": [
                    {
                        "Name": "Table",
                        "ClassName": "ModuleScript",
                        "Source": "--!nocheck\n-- shut up jesser\n\n--[[\n\tTo use: local table = require(this)\n\t(Yes, override table.)\n\n\tWritten by EtiTheSpirit. Adds custom functions to the `table` value provided by roblox (in normal cases, this would simply modify `table`, but Roblox has disabled that so we need to use a proxy)\n\t\n\tCHANGES:\n\t\t3 December 2019 @ 11:07 PM CST:\n\t\t\t+ Added table.join\n\t\t\t\n\t\t\t\n\t\t21 November 2019 @ 6:50 PM CST:\n\t\t\t+ Added new method bodies to skip/take using Luau's new methods. Drastic speed increases achieved. CREDITS: Halalaluyafail3 (See https://devforum.roblox.com/t/sandboxed-table-system-add-custom-methods-to-table/391177/12?u=etithespirit)\n\t\t\t+ Added table.retrieve as proposed by ^ under the name \"table.range\" as this name relays what it does a bit better, I think.\n\t\t\t+ Added table.skipAndTake as an alias method.\n\n--]]\n\nlocal RNG = Random.new()\nlocal RobloxTable = table\nlocal Table = {}\n\n-- Returns true if the table contains the specified value.\nTable.contains = function(tbl, value)\n\treturn Table.indexOf(tbl, value) ~= nil -- This is kind of cheatsy but it promises the best performance.\nend\n\n-- A combo of table.find and table.keyOf -- This first attempts to find the ordinal index of your value, then attempts to find the lookup key if it can't find an ordinal index.\nTable.indexOf = function(tbl, value)\n\tlocal fromFind = table.find(tbl, value)\n\tif fromFind then\n\t\treturn fromFind\n\tend\n\n\treturn Table.keyOf(tbl, value)\nend\n\n-- Returns the key of the specified value, or nil if it could not be found. Unlike IndexOf, this searches every key in the table, not just ordinal indices (arrays)\n-- This is inherently slower due to how lookups work, so if your table is structured like an array, use table.find\nTable.keyOf = function(tbl, value)\n\tfor index, obj in pairs(tbl) do\n\t\tif obj == value then\n\t\t\treturn index\n\t\tend\n\tend\n\treturn nil\nend\n\n-- Only works on ordinal. yada yada.\nTable.insertAndGetIndexOf = function(tbl, value)\n\ttbl[#tbl + 1] = value\n\treturn #tbl\nend\n\n-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Skips *n* objects in the table, and returns a new table that contains indices (n + 1) to (end of table)\nTable.skip = function(tbl, n)\n\treturn table.move(tbl, n + 1, #tbl, 1, table.create(#tbl - n))\nend\n\n-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes *n* objects from a table and returns a new table only containing those objects.\nTable.take = function(tbl, n)\n\treturn table.move(tbl, 1, n, 1, table.create(n))\nend\n\n-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes the range of entries in this table in the range [start, finish] and returns that range as a table.\nTable.range = function(tbl, start, finish)\n\treturn table.move(tbl, start, finish, 1, table.create(finish - start + 1))\nend\n\n-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). An alias that calls table.skip(skip), and then takes [take] entries from the resulting table.\nTable.skipAndTake = function(tbl, skip, take)\n\treturn table.move(tbl, skip + 1, skip + take, 1, table.create(take))\nend\n\n-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Selects a random object out of tbl\nTable.random = function(tbl)\n\treturn tbl[RNG:NextInteger(1, #tbl)]\nend\n\n-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Merges tbl0 and tbl1 together.\nTable.join = function(tbl0, tbl1)\n\tlocal nt = table.create(#tbl0 + #tbl1)\n\tlocal t2 = table.move(tbl0, 1, #tbl0, 1, nt)\n\treturn table.move(tbl1, 1, #tbl1, #tbl0 + 1, nt)\nend\n\n-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Removes the specified object from this array.\nTable.removeObject = function(tbl, obj)\n\tlocal index = Table.indexOf(tbl, obj)\n\tif index then\n\t\ttable.remove(tbl, index)\n\tend\nend\n\nreturn setmetatable({}, {\n\t__index = function(tbl, index)\n\t\tif Table[index] ~= nil then\n\t\t\treturn Table[index]\n\t\telse\n\t\t\treturn RobloxTable[index]\n\t\tend\n\tend,\n\n\t__newindex = function(tbl, index, value)\n\t\terror(\"Add new table entries by editing the Module itself.\")\n\tend,\n})",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "ActiveCast",
                        "ClassName": "ModuleScript",
                        "Source": "--!nocheck\n-- ^ change to strict to crash studio c:\n-- ActiveCast class type.\n-- The ActiveCast type represents a currently running cast.\n\n-----------------------------------------------------------\n--------------------- TYPE DEFINITION ---------------------\n-----------------------------------------------------------\n\n-- This will inject all types into this context.\nlocal TypeDefs = require(script.Parent.TypeDefinitions)\n\ntype CanPierceFunction = TypeDefs.CanPierceFunction\ntype GenericTable = TypeDefs.GenericTable\ntype Caster = TypeDefs.Caster\ntype FastCastBehavior = TypeDefs.FastCastBehavior\ntype CastTrajectory = TypeDefs.CastTrajectory\ntype CastStateInfo = TypeDefs.CastStateInfo\ntype CastRayInfo = TypeDefs.CastRayInfo\ntype ActiveCast = TypeDefs.ActiveCast\n\nlocal typeof = require(script.Parent.TypeMarshaller)\n\n-----------------------------------------------------------\n-------------------- MODULE DEFINITION --------------------\n-----------------------------------------------------------\n\nlocal ActiveCastStatic = {}\nActiveCastStatic.__index = ActiveCastStatic\nActiveCastStatic.__type = \"ActiveCast\" -- For compatibility with TypeMarshaller\n\n-----------------------------------------------------------\n----------------------- STATIC DATA -----------------------\n-----------------------------------------------------------\nlocal RunService = game:GetService(\"RunService\")\nlocal table = require(script.Parent.Table)\nlocal FastCast = nil -- Static reference to the FastCast static module.\n\n-- Format params: methodName, ctorName\nlocal ERR_NOT_INSTANCE =\n\t\"Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s\"\n\n-- Format params: paramName, expectedType, actualType\nlocal ERR_INVALID_TYPE = \"Invalid type for parameter '%s' (Expected %s, got %s)\"\n\n-- The name of the folder containing the 3D GUI elements for visualizing casts in debug mode.\nlocal FC_VIS_OBJ_NAME = \"FastCastVisualizationObjects\"\n\n-- Format params: N/A\nlocal ERR_OBJECT_DISPOSED = \"This ActiveCast has been terminated. It can no longer be used.\"\n\n-- If pierce callback has to run more than this many times, it will register a hit and stop calculating pierces.\n-- This only applies for repeated piercings, e.g. the amount of parts that fit within the space of a single cast segment (NOT the whole bullet's trajectory over its entire lifetime)\nlocal MAX_PIERCE_TEST_COUNT = 100\n\n-----------------------------------------------------------\n------------------------ UTILITIES ------------------------\n-----------------------------------------------------------\n\n-- Looks for a folder within workspace.Terrain that contains elements to visualize casts.\nlocal function GetFastCastVisualizationContainer(): Instance\n\tlocal fcVisualizationObjects = workspace.Terrain:FindFirstChild(FC_VIS_OBJ_NAME)\n\tif fcVisualizationObjects ~= nil then\n\t\treturn fcVisualizationObjects\n\tend\n\n\tfcVisualizationObjects = Instance.new(\"Folder\")\n\tfcVisualizationObjects.Name = FC_VIS_OBJ_NAME\n\tfcVisualizationObjects.Archivable = false -- TODO: Keep this as-is? You can't copy/paste it if this is false. I have it false so that it doesn't linger in studio if you save with the debug data in there.\n\tfcVisualizationObjects.Parent = workspace.Terrain\n\treturn fcVisualizationObjects\nend\n\n-----------------------------------------------------------\n------------------------ DEBUGGING ------------------------\n-----------------------------------------------------------\n\n-- Print that runs only if debug mode is active.\nlocal function PrintDebug(message: string)\n\tif FastCast.DebugLogging == true then\n\t\tprint(message)\n\tend\nend\n\n-- Visualizes a ray. This will not run if FastCast.VisualizeCasts is false.\nfunction DbgVisualizeSegment(castStartCFrame: CFrame, castLength: number): ConeHandleAdornment?\n\tif FastCast.VisualizeCasts ~= true then\n\t\treturn nil\n\tend\n\tlocal adornment = Instance.new(\"ConeHandleAdornment\")\n\tadornment.Adornee = workspace.Terrain\n\tadornment.CFrame = castStartCFrame\n\tadornment.Height = castLength\n\tadornment.Color3 = Color3.new()\n\tadornment.Radius = 0.25\n\tadornment.Transparency = 0.5\n\tadornment.Parent = GetFastCastVisualizationContainer()\n\treturn adornment\nend\n\n-- Visualizes an impact. This will not run if FastCast.VisualizeCasts is false.\nfunction DbgVisualizeHit(atCF: CFrame, wasPierce: boolean): SphereHandleAdornment?\n\tif FastCast.VisualizeCasts ~= true then\n\t\treturn nil\n\tend\n\tlocal adornment = Instance.new(\"SphereHandleAdornment\")\n\tadornment.Adornee = workspace.Terrain\n\tadornment.CFrame = atCF\n\tadornment.Radius = 0.4\n\tadornment.Transparency = 0.25\n\tadornment.Color3 = (wasPierce == false) and Color3.new(0.2, 1, 0.5) or Color3.new(1, 0.2, 0.2)\n\tadornment.Parent = GetFastCastVisualizationContainer()\n\treturn adornment\nend\n\n-----------------------------------------------------------\n------------------------ CORE CODE ------------------------\n-----------------------------------------------------------\n\n-- Thanks to zoebasil for supplying the velocity and position functions below. (I've modified these functions)\n-- I was having a huge issue trying to get it to work and I had overcomplicated a bunch of stuff.\n-- GetPositionAtTime is used in physically simulated rays (Where Caster.HasPhysics == true or the specific Fire has a specified acceleration).\n-- This returns the location that the bullet will be at when you specify the amount of time the bullet has existed, the original location of the bullet, and the velocity it was launched with.\nlocal function GetPositionAtTime(\n\ttime: number,\n\torigin: Vector3,\n\tinitialVelocity: Vector3,\n\tacceleration: Vector3\n): Vector3\n\tlocal force =\n\t\tVector3.new((acceleration.X * time ^ 2) / 2, (acceleration.Y * time ^ 2) / 2, (acceleration.Z * time ^ 2) / 2)\n\treturn origin + (initialVelocity * time) + force\nend\n\n-- A variant of the function above that returns the velocity at a given point in time.\nlocal function GetVelocityAtTime(time: number, initialVelocity: Vector3, acceleration: Vector3): Vector3\n\treturn initialVelocity + acceleration * time\nend\n\nlocal function GetTrajectoryInfo(cast: ActiveCast, index: number): { [number]: Vector3 }\n\tassert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\tlocal trajectories = cast.StateInfo.Trajectories\n\tlocal trajectory = trajectories[index]\n\tlocal duration = trajectory.EndTime - trajectory.StartTime\n\n\tlocal origin = trajectory.Origin\n\tlocal vel = trajectory.InitialVelocity\n\tlocal accel = trajectory.Acceleration\n\n\treturn { GetPositionAtTime(duration, origin, vel, accel), GetVelocityAtTime(duration, vel, accel) }\nend\n\nlocal function GetLatestTrajectoryEndInfo(cast: ActiveCast): { [number]: Vector3 }\n\tassert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\treturn GetTrajectoryInfo(cast, #cast.StateInfo.Trajectories)\nend\n\nlocal function CloneCastParams(params: RaycastParams): RaycastParams\n\tlocal clone = RaycastParams.new()\n\tclone.CollisionGroup = params.CollisionGroup\n\tclone.FilterType = params.FilterType\n\tclone.FilterDescendantsInstances = params.FilterDescendantsInstances\n\tclone.IgnoreWater = params.IgnoreWater\n\treturn clone\nend\n\nlocal function SendRayHit(\n\tcast: ActiveCast,\n\tresultOfCast: RaycastResult,\n\tsegmentVelocity: Vector3,\n\tcosmeticBulletObject: Instance?\n)\n\t--cast.RayHit:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)\n\tcast.Caster.RayHit:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)\nend\n\nlocal function SendRayPierced(\n\tcast: ActiveCast,\n\tresultOfCast: RaycastResult,\n\tsegmentVelocity: Vector3,\n\tcosmeticBulletObject: Instance?\n)\n\t--cast.RayPierced:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)\n\tcast.Caster.RayPierced:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)\nend\n\nlocal function SendLengthChanged(\n\tcast: ActiveCast,\n\tlastPoint: Vector3,\n\trayDir: Vector3,\n\trayDisplacement: number,\n\tsegmentVelocity: Vector3,\n\tcosmeticBulletObject: Instance?\n)\n\t--cast.LengthChanged:Fire(cast, lastPoint, rayDir, rayDisplacement, segmentVelocity, cosmeticBulletObject)\n\tcast.Caster.LengthChanged:Fire(cast, lastPoint, rayDir, rayDisplacement, segmentVelocity, cosmeticBulletObject)\nend\n\n-- Simulate a raycast by one tick.\nlocal function SimulateCast(cast: ActiveCast, delta: number, expectingShortCall: boolean)\n\tassert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\tPrintDebug(\"Casting for frame.\")\n\tlocal latestTrajectory = cast.StateInfo.Trajectories[#cast.StateInfo.Trajectories]\n\n\tlocal origin = latestTrajectory.Origin\n\tlocal totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime\n\tlocal initialVelocity = latestTrajectory.InitialVelocity\n\tlocal acceleration = latestTrajectory.Acceleration\n\n\tlocal lastPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)\n\tlocal lastVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration)\n\tlocal lastDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime\n\n\tcast.StateInfo.TotalRuntime += delta\n\n\t-- Recalculate this.\n\ttotalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime\n\n\tlocal currentTarget = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)\n\tlocal segmentVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration)\n\tlocal totalDisplacement = currentTarget - lastPoint -- This is the displacement from where the ray was on the last from to where the ray is now.\n\n\tlocal rayDir = totalDisplacement.Unit * segmentVelocity.Magnitude * delta\n\tlocal targetWorldRoot = cast.RayInfo.WorldRoot\n\tlocal resultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, cast.RayInfo.Parameters)\n\n\tlocal point = currentTarget\n\tlocal part: Instance? = nil\n\tlocal material = Enum.Material.Air\n\tlocal normal = Vector3.new()\n\n\tif resultOfCast ~= nil then\n\t\tpoint = resultOfCast.Position\n\t\tpart = resultOfCast.Instance\n\t\tmaterial = resultOfCast.Material\n\t\tnormal = resultOfCast.Normal\n\tend\n\n\tlocal rayDisplacement = (point - lastPoint).Magnitude\n\t-- For clarity -- totalDisplacement is how far the ray would have traveled if it hit nothing,\n\t-- and rayDisplacement is how far the ray really traveled (which will be identical to totalDisplacement if it did indeed hit nothing)\n\n\tSendLengthChanged(cast, lastPoint, rayDir.Unit, rayDisplacement, segmentVelocity, cast.RayInfo.CosmeticBulletObject)\n\tcast.StateInfo.DistanceCovered += rayDisplacement\n\n\tlocal rayVisualization: ConeHandleAdornment? = nil\n\tif delta > 0 then\n\t\trayVisualization = DbgVisualizeSegment(CFrame.new(lastPoint, lastPoint + rayDir), rayDisplacement)\n\tend\n\n\t-- HIT DETECTED. Handle all that garbage, and also handle behaviors 1 and 2 (default behavior, go high res when hit) if applicable.\n\t-- CAST BEHAVIOR 2 IS HANDLED IN THE CODE THAT CALLS THIS FUNCTION.\n\n\tif part and part ~= cast.RayInfo.CosmeticBulletObject then\n\t\tlocal start = tick()\n\t\tPrintDebug(\"Hit something, testing now.\")\n\n\t\t-- SANITY CHECK: Don't allow the user to yield or run otherwise extensive code that takes longer than one frame/heartbeat to execute.\n\t\tif cast.RayInfo.CanPierceCallback ~= nil then\n\t\t\tif expectingShortCall == false then\n\t\t\t\tif cast.StateInfo.IsActivelySimulatingPierce then\n\t\t\t\t\tcast:Terminate()\n\t\t\t\t\terror(\n\t\t\t\t\t\t\"ERROR: The latest call to CanPierceCallback took too long to complete! This cast is going to suffer desyncs which WILL cause unexpected behavior and errors. Please fix your performance problems, or remove statements that yield (e.g. wait() calls)\"\n\t\t\t\t\t)\n\t\t\t\t\t-- Use error. This should absolutely abort the cast.\n\t\t\t\tend\n\t\t\tend\n\t\t\t-- expectingShortCall is used to determine if we are doing a forced resolution increase, in which case this will be called several times in a single frame, which throws this error.\n\t\t\tcast.StateInfo.IsActivelySimulatingPierce = true\n\t\tend\n\t\t------------------------------\n\n\t\tif\n\t\t\tcast.RayInfo.CanPierceCallback == nil\n\t\t\tor (\n\t\t\t\tcast.RayInfo.CanPierceCallback ~= nil\n\t\t\t\tand cast.RayInfo.CanPierceCallback(\n\t\t\t\t\t\tcast,\n\t\t\t\t\t\tresultOfCast,\n\t\t\t\t\t\tsegmentVelocity,\n\t\t\t\t\t\tcast.RayInfo.CosmeticBulletObject\n\t\t\t\t\t)\n\t\t\t\t\t== false\n\t\t\t)\n\t\tthen\n\t\t\tPrintDebug(\"Piercing function is nil or it returned FALSE to not pierce this hit.\")\n\t\t\tcast.StateInfo.IsActivelySimulatingPierce = false\n\n\t\t\tif\n\t\t\t\tcast.StateInfo.HighFidelityBehavior == 2\n\t\t\t\tand latestTrajectory.Acceleration ~= Vector3.new()\n\t\t\t\tand cast.StateInfo.HighFidelitySegmentSize ~= 0\n\t\t\tthen\n\t\t\t\tcast.StateInfo.CancelHighResCast = false -- Reset this here.\n\n\t\t\t\tif cast.StateInfo.IsActivelyResimulating then\n\t\t\t\t\tcast:Terminate()\n\t\t\t\t\terror(\n\t\t\t\t\t\t\"Cascading cast lag encountered! The caster attempted to perform a high fidelity cast before the previous one completed, resulting in exponential cast lag. Consider increasing HighFidelitySegmentSize.\"\n\t\t\t\t\t)\n\t\t\t\tend\n\n\t\t\t\tcast.StateInfo.IsActivelyResimulating = true\n\n\t\t\t\t-- This is a physics based cast and it needs to be recalculated.\n\t\t\t\tPrintDebug(\n\t\t\t\t\t\"Hit was registered, but recalculation is on for physics based casts. Recalculating to verify a real hit...\"\n\t\t\t\t)\n\n\t\t\t\t-- Split this ray segment into smaller segments of a given size.\n\t\t\t\t-- In 99% of cases, it won't divide evently (e.g. I have a distance of 1.25 and I want to divide into 0.1 -- that won't work)\n\t\t\t\t-- To fix this, the segments need to be stretched slightly to fill the space (rather than having a single shorter segment at the end)\n\n\t\t\t\tlocal numSegmentsDecimal = rayDisplacement / cast.StateInfo.HighFidelitySegmentSize -- say rayDisplacement is 5.1, segment size is 0.5 -- 10.2 segments\n\t\t\t\tlocal numSegmentsReal = math.floor(numSegmentsDecimal) -- 10 segments + 0.2 extra segments\n\t\t\t\tlocal realSegmentLength = rayDisplacement / numSegmentsReal -- this spits out 0.51, which isn't exact to the defined 0.5, but it's close\n\n\t\t\t\t-- Now the real hard part is converting this to time.\n\t\t\t\tlocal timeIncrement = delta / numSegmentsReal\n\t\t\t\tfor segmentIndex = 1, numSegmentsReal do\n\t\t\t\t\tif cast.StateInfo.CancelHighResCast then\n\t\t\t\t\t\tcast.StateInfo.CancelHighResCast = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\n\t\t\t\t\tlocal subPosition = GetPositionAtTime(\n\t\t\t\t\t\tlastDelta + (timeIncrement * segmentIndex),\n\t\t\t\t\t\torigin,\n\t\t\t\t\t\tinitialVelocity,\n\t\t\t\t\t\tacceleration\n\t\t\t\t\t)\n\t\t\t\t\tlocal subVelocity =\n\t\t\t\t\t\tGetVelocityAtTime(lastDelta + (timeIncrement * segmentIndex), initialVelocity, acceleration)\n\t\t\t\t\tlocal subRayDir = subVelocity * delta\n\t\t\t\t\tlocal subResult = targetWorldRoot:Raycast(subPosition, subRayDir, cast.RayInfo.Parameters)\n\n\t\t\t\t\tlocal subDisplacement = (subPosition - (subPosition + subVelocity)).Magnitude\n\n\t\t\t\t\tif subResult ~= nil then\n\t\t\t\t\t\tlocal subDisplacement = (subPosition - subResult.Position).Magnitude\n\t\t\t\t\t\tlocal dbgSeg =\n\t\t\t\t\t\t\tDbgVisualizeSegment(CFrame.new(subPosition, subPosition + subVelocity), subDisplacement)\n\t\t\t\t\t\tif dbgSeg ~= nil then\n\t\t\t\t\t\t\tdbgSeg.Color3 = Color3.new(0.286275, 0.329412, 0.247059)\n\t\t\t\t\t\tend\n\n\t\t\t\t\t\tif\n\t\t\t\t\t\t\tcast.RayInfo.CanPierceCallback == nil\n\t\t\t\t\t\t\tor (\n\t\t\t\t\t\t\t\tcast.RayInfo.CanPierceCallback ~= nil\n\t\t\t\t\t\t\t\tand cast.RayInfo.CanPierceCallback(\n\t\t\t\t\t\t\t\t\t\tcast,\n\t\t\t\t\t\t\t\t\t\tsubResult,\n\t\t\t\t\t\t\t\t\t\tsubVelocity,\n\t\t\t\t\t\t\t\t\t\tcast.RayInfo.CosmeticBulletObject\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t== false\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\tthen\n\t\t\t\t\t\t\t-- Still hit even at high res\n\t\t\t\t\t\t\tcast.StateInfo.IsActivelyResimulating = false\n\n\t\t\t\t\t\t\tSendRayHit(cast, subResult, subVelocity, cast.RayInfo.CosmeticBulletObject)\n\t\t\t\t\t\t\tcast:Terminate()\n\t\t\t\t\t\t\tlocal vis = DbgVisualizeHit(CFrame.new(point), false)\n\t\t\t\t\t\t\tif vis ~= nil then\n\t\t\t\t\t\t\t\tvis.Color3 = Color3.new(0.0588235, 0.87451, 1)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t-- Recalculating hit something pierceable instead.\n\t\t\t\t\t\t\tSendRayPierced(cast, subResult, subVelocity, cast.RayInfo.CosmeticBulletObject) -- This may result in CancelHighResCast being set to true.\n\t\t\t\t\t\t\tlocal vis = DbgVisualizeHit(CFrame.new(point), true)\n\t\t\t\t\t\t\tif vis ~= nil then\n\t\t\t\t\t\t\t\tvis.Color3 = Color3.new(1, 0.113725, 0.588235)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tif dbgSeg ~= nil then\n\t\t\t\t\t\t\t\tdbgSeg.Color3 = Color3.new(0.305882, 0.243137, 0.329412)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\tlocal dbgSeg =\n\t\t\t\t\t\t\tDbgVisualizeSegment(CFrame.new(subPosition, subPosition + subVelocity), subDisplacement)\n\t\t\t\t\t\tif dbgSeg ~= nil then\n\t\t\t\t\t\t\tdbgSeg.Color3 = Color3.new(0.286275, 0.329412, 0.247059)\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\t-- If the script makes it here, then it wasn't a real hit (higher resolution revealed that the low-res hit was faulty)\n\t\t\t\t-- Just let it keep going.\n\t\t\t\tcast.StateInfo.IsActivelyResimulating = false\n\t\t\telseif cast.StateInfo.HighFidelityBehavior ~= 1 and cast.StateInfo.HighFidelityBehavior ~= 3 then\n\t\t\t\tcast:Terminate()\n\t\t\t\terror(\"Invalid value \" .. cast.StateInfo.HighFidelityBehavior .. \" for HighFidelityBehavior.\")\n\t\t\telse\n\t\t\t\t-- This is not a physics cast, or recalculation is off.\n\t\t\t\tPrintDebug(\"Hit was successful. Terminating.\")\n\t\t\t\tSendRayHit(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)\n\t\t\t\tcast:Terminate()\n\t\t\t\tDbgVisualizeHit(CFrame.new(point), false)\n\t\t\t\treturn\n\t\t\tend\n\t\telse\n\t\t\tPrintDebug(\"Piercing function returned TRUE to pierce this part.\")\n\t\t\tif rayVisualization ~= nil then\n\t\t\t\trayVisualization.Color3 = Color3.new(0.4, 0.05, 0.05) -- Turn it red to signify that the cast was scrapped.\n\t\t\tend\n\t\t\tDbgVisualizeHit(CFrame.new(point), true)\n\n\t\t\tlocal params = cast.RayInfo.Parameters\n\t\t\tlocal alteredParts = {}\n\t\t\tlocal currentPierceTestCount = 0\n\t\t\tlocal originalFilter = params.FilterDescendantsInstances\n\t\t\tlocal brokeFromSolidObject = false\n\t\t\twhile true do\n\t\t\t\t-- So now what I need to do is redo this entire cast, just with the new filter list\n\n\t\t\t\t-- Catch case: Is it terrain?\n\t\t\t\tif resultOfCast.Instance:IsA(\"Terrain\") then\n\t\t\t\t\tif material == Enum.Material.Water then\n\t\t\t\t\t\t-- Special case: Pierced on water?\n\t\t\t\t\t\tcast:Terminate()\n\t\t\t\t\t\terror(\n\t\t\t\t\t\t\t\"Do not add Water as a piercable material. If you need to pierce water, set cast.RayInfo.Parameters.IgnoreWater = true instead\",\n\t\t\t\t\t\t\t0\n\t\t\t\t\t\t)\n\t\t\t\t\tend\n\t\t\t\t\twarn(\n\t\t\t\t\t\t\"WARNING: The pierce callback for this cast returned TRUE on Terrain! This can cause severely adverse effects.\"\n\t\t\t\t\t)\n\t\t\t\tend\n\n\t\t\t\tif params.FilterType == Enum.RaycastFilterType.Blacklist then\n\t\t\t\t\t-- blacklist\n\t\t\t\t\t-- DO NOT DIRECTLY TABLE.INSERT ON THE PROPERTY\n\t\t\t\t\tlocal filter = params.FilterDescendantsInstances\n\t\t\t\t\ttable.insert(filter, resultOfCast.Instance)\n\t\t\t\t\ttable.insert(alteredParts, resultOfCast.Instance)\n\t\t\t\t\tparams.FilterDescendantsInstances = filter\n\t\t\t\telse\n\t\t\t\t\t-- whitelist\n\t\t\t\t\t-- method implemeneted by custom table system\n\t\t\t\t\t-- DO NOT DIRECTLY TABLE.REMOVEOBJECT ON THE PROPERTY\n\t\t\t\t\tlocal filter = params.FilterDescendantsInstances\n\t\t\t\t\ttable.removeObject(filter, resultOfCast.Instance)\n\t\t\t\t\ttable.insert(alteredParts, resultOfCast.Instance)\n\t\t\t\t\tparams.FilterDescendantsInstances = filter\n\t\t\t\tend\n\n\t\t\t\tSendRayPierced(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)\n\n\t\t\t\t-- List has been updated, so let's cast again.\n\t\t\t\tresultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, params)\n\n\t\t\t\t-- No hit? No simulation. Break.\n\t\t\t\tif resultOfCast == nil then\n\t\t\t\t\tbreak\n\t\t\t\tend\n\n\t\t\t\tif currentPierceTestCount >= MAX_PIERCE_TEST_COUNT then\n\t\t\t\t\twarn(\n\t\t\t\t\t\t\"WARNING: Exceeded maximum pierce test budget for a single ray segment (attempted to test the same segment \"\n\t\t\t\t\t\t\t.. MAX_PIERCE_TEST_COUNT\n\t\t\t\t\t\t\t.. \" times!)\"\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\t\tcurrentPierceTestCount = currentPierceTestCount + 1\n\n\t\t\t\tif\n\t\t\t\t\tcast.RayInfo.CanPierceCallback(\n\t\t\t\t\t\tcast,\n\t\t\t\t\t\tresultOfCast,\n\t\t\t\t\t\tsegmentVelocity,\n\t\t\t\t\t\tcast.RayInfo.CosmeticBulletObject\n\t\t\t\t\t) == false\n\t\t\t\tthen\n\t\t\t\t\tbrokeFromSolidObject = true\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\n\t\t\t-- Restore the filter to its default state.\n\t\t\tcast.RayInfo.Parameters.FilterDescendantsInstances = originalFilter\n\t\t\tcast.StateInfo.IsActivelySimulatingPierce = false\n\n\t\t\tif brokeFromSolidObject then\n\t\t\t\t-- We actually hit something while testing.\n\t\t\t\tPrintDebug(\n\t\t\t\t\t\"Broke because the ray hit something solid (\"\n\t\t\t\t\t\t.. tostring(resultOfCast.Instance)\n\t\t\t\t\t\t.. \") while testing for a pierce. Terminating the cast.\"\n\t\t\t\t)\n\t\t\t\tSendRayHit(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)\n\t\t\t\tcast:Terminate()\n\t\t\t\tDbgVisualizeHit(CFrame.new(resultOfCast.Position), false)\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\t-- And exit the function here too.\n\t\tend\n\tend\n\n\tif cast.StateInfo.DistanceCovered >= cast.RayInfo.MaxDistance then\n\t\t-- SendRayHit(cast, nil, segmentVelocity, cast.RayInfo.CosmeticBulletObject)\n\t\tcast:Terminate()\n\t\tDbgVisualizeHit(CFrame.new(currentTarget), false)\n\tend\nend\n\n-----------------------------------------------------------\n------------------------- EXPORTS -------------------------\n-----------------------------------------------------------\n\n-- Ctor\nfunction ActiveCastStatic.new(\n\tcaster: Caster,\n\torigin: Vector3,\n\tdirection: Vector3,\n\tvelocity: Vector3 | number,\n\tcastDataPacket: FastCastBehavior\n): ActiveCast\n\tif typeof(velocity) == \"number\" then\n\t\tvelocity = direction.Unit * velocity\n\tend\n\n\tif castDataPacket.HighFidelitySegmentSize <= 0 then\n\t\terror(\"Cannot set FastCastBehavior.HighFidelitySegmentSize <= 0!\", 0)\n\tend\n\n\t-- Basic setup\n\tlocal cast = {\n\t\tCaster = caster,\n\n\t\t-- Data that keeps track of what's going on as well as edits we might make during runtime.\n\t\tStateInfo = {\n\t\t\tUpdateConnection = nil,\n\t\t\tPaused = false,\n\t\t\tTotalRuntime = 0,\n\t\t\tDistanceCovered = 0,\n\t\t\tHighFidelitySegmentSize = castDataPacket.HighFidelitySegmentSize,\n\t\t\tHighFidelityBehavior = castDataPacket.HighFidelityBehavior,\n\t\t\tIsActivelySimulatingPierce = false,\n\t\t\tIsActivelyResimulating = false,\n\t\t\tCancelHighResCast = false,\n\t\t\tTrajectories = {\n\t\t\t\t{\n\t\t\t\t\tStartTime = 0,\n\t\t\t\t\tEndTime = -1,\n\t\t\t\t\tOrigin = origin,\n\t\t\t\t\tInitialVelocity = velocity,\n\t\t\t\t\tAcceleration = castDataPacket.Acceleration,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\t-- Information pertaining to actual raycasting.\n\t\tRayInfo = {\n\t\t\tParameters = castDataPacket.RaycastParams,\n\t\t\tWorldRoot = workspace,\n\t\t\tMaxDistance = castDataPacket.MaxDistance or 1000,\n\t\t\tCosmeticBulletObject = castDataPacket.CosmeticBulletTemplate, -- This is intended. We clone it a smidge of the way down.\n\t\t\tCanPierceCallback = castDataPacket.CanPierceFunction,\n\t\t},\n\n\t\tUserData = {},\n\t}\n\n\tif cast.StateInfo.HighFidelityBehavior == 2 then\n\t\tcast.StateInfo.HighFidelityBehavior = 3\n\tend\n\n\tif cast.RayInfo.Parameters ~= nil then\n\t\tcast.RayInfo.Parameters = CloneCastParams(cast.RayInfo.Parameters)\n\telse\n\t\tcast.RayInfo.Parameters = RaycastParams.new()\n\tend\n\n\tlocal usingProvider = false\n\tif castDataPacket.CosmeticBulletProvider == nil then\n\t\t-- The provider is nil. Use a cosmetic object clone.\n\t\tif cast.RayInfo.CosmeticBulletObject ~= nil then\n\t\t\tcast.RayInfo.CosmeticBulletObject = cast.RayInfo.CosmeticBulletObject:Clone()\n\t\t\tcast.RayInfo.CosmeticBulletObject.CFrame = CFrame.new(origin, origin + direction)\n\t\t\tcast.RayInfo.CosmeticBulletObject.Parent = castDataPacket.CosmeticBulletContainer\n\t\tend\n\telse\n\t\t-- The provider is not nil.\n\t\t-- Is it what we want?\n\t\tif typeof(castDataPacket.CosmeticBulletProvider) == \"PartCache\" then\n\t\t\t-- this modded version of typeof is implemented up top.\n\t\t\t-- Aside from that, yes, it's a part cache. Good to go!\n\n\t\t\tif cast.RayInfo.CosmeticBulletObject ~= nil then\n\t\t\t\t-- They also set the template. Not good. Warn + clear this up.\n\t\t\t\twarn(\n\t\t\t\t\t\"Do not define FastCastBehavior.CosmeticBulletTemplate and FastCastBehavior.CosmeticBulletProvider at the same time! The provider will be used, and CosmeticBulletTemplate will be set to nil.\"\n\t\t\t\t)\n\t\t\t\tcast.RayInfo.CosmeticBulletObject = nil\n\t\t\t\tcastDataPacket.CosmeticBulletTemplate = nil\n\t\t\tend\n\n\t\t\tcast.RayInfo.CosmeticBulletObject = castDataPacket.CosmeticBulletProvider:GetPart()\n\t\t\tcast.RayInfo.CosmeticBulletObject.CFrame = CFrame.new(origin, origin + direction)\n\t\t\tusingProvider = true\n\t\telse\n\t\t\twarn(\n\t\t\t\t\"FastCastBehavior.CosmeticBulletProvider was not an instance of the PartCache module (an external/separate model)! Are you inputting an instance created via PartCache.new? If so, are you on the latest version of PartCache? Setting FastCastBehavior.CosmeticBulletProvider to nil.\"\n\t\t\t)\n\t\t\tcastDataPacket.CosmeticBulletProvider = nil\n\t\tend\n\tend\n\n\tlocal targetContainer: Instance\n\tif usingProvider then\n\t\ttargetContainer = castDataPacket.CosmeticBulletProvider.CurrentCacheParent\n\telse\n\t\ttargetContainer = castDataPacket.CosmeticBulletContainer\n\tend\n\n\tif castDataPacket.AutoIgnoreContainer == true and targetContainer ~= nil then\n\t\tlocal ignoreList = cast.RayInfo.Parameters.FilterDescendantsInstances\n\t\tif table.find(ignoreList, targetContainer) == nil then\n\t\t\ttable.insert(ignoreList, targetContainer)\n\t\t\tcast.RayInfo.Parameters.FilterDescendantsInstances = ignoreList\n\t\tend\n\tend\n\n\tlocal event\n\tif RunService:IsClient() then\n\t\tevent = RunService.RenderStepped\n\telse\n\t\tevent = RunService.Heartbeat\n\tend\n\n\tsetmetatable(cast, ActiveCastStatic)\n\n\tcast.StateInfo.UpdateConnection = event:Connect(function(delta)\n\t\tif cast.StateInfo.Paused then\n\t\t\treturn\n\t\tend\n\n\t\tPrintDebug(\"Casting for frame.\")\n\t\tlocal latestTrajectory = cast.StateInfo.Trajectories[#cast.StateInfo.Trajectories]\n\t\tif\n\t\t\tcast.StateInfo.HighFidelityBehavior == 3\n\t\t\tand latestTrajectory.Acceleration ~= Vector3.new()\n\t\t\tand cast.StateInfo.HighFidelitySegmentSize > 0\n\t\tthen\n\t\t\tlocal timeAtStart = tick()\n\n\t\t\tif cast.StateInfo.IsActivelyResimulating then\n\t\t\t\tcast:Terminate()\n\t\t\t\terror(\n\t\t\t\t\t\"Cascading cast lag encountered! The caster attempted to perform a high fidelity cast before the previous one completed, resulting in exponential cast lag. Consider increasing HighFidelitySegmentSize.\"\n\t\t\t\t)\n\t\t\tend\n\n\t\t\tcast.StateInfo.IsActivelyResimulating = true\n\n\t\t\t-- Actually want to calculate this early to find displacement\n\t\t\tlocal origin = latestTrajectory.Origin\n\t\t\tlocal totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime\n\t\t\tlocal initialVelocity = latestTrajectory.InitialVelocity\n\t\t\tlocal acceleration = latestTrajectory.Acceleration\n\n\t\t\tlocal lastPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)\n\t\t\tlocal lastVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration)\n\t\t\tlocal lastDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime\n\n\t\t\tcast.StateInfo.TotalRuntime += delta\n\n\t\t\t-- Recalculate this.\n\t\t\ttotalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime\n\n\t\t\tlocal currentPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)\n\t\t\tlocal currentVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration)\n\t\t\tlocal totalDisplacement = currentPoint - lastPoint -- This is the displacement from where the ray was on the last from to where the ray is now.\n\n\t\t\tlocal rayDir = totalDisplacement.Unit * currentVelocity.Magnitude * delta\n\t\t\tlocal targetWorldRoot = cast.RayInfo.WorldRoot\n\t\t\tlocal resultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, cast.RayInfo.Parameters)\n\n\t\t\tlocal point = currentPoint\n\n\t\t\tif resultOfCast ~= nil then\n\t\t\t\tpoint = resultOfCast.Position\n\t\t\tend\n\n\t\t\tlocal rayDisplacement = (point - lastPoint).Magnitude\n\n\t\t\t-- Now undo this. The line below in the for loop will add this time back gradually.\n\t\t\tcast.StateInfo.TotalRuntime -= delta\n\n\t\t\t-- And now that we have displacement, we can calculate segment size.\n\t\t\tlocal numSegmentsDecimal = rayDisplacement / cast.StateInfo.HighFidelitySegmentSize -- say rayDisplacement is 5.1, segment size is 0.5 -- 10.2 segments\n\t\t\tlocal numSegmentsReal = math.floor(numSegmentsDecimal) -- 10 segments + 0.2 extra segments\n\t\t\tif numSegmentsReal == 0 then\n\t\t\t\tnumSegmentsReal = 1\n\t\t\tend\n\n\t\t\tlocal timeIncrement = delta / numSegmentsReal\n\n\t\t\tfor segmentIndex = 1, numSegmentsReal do\n\t\t\t\tif getmetatable(cast) == nil then\n\t\t\t\t\treturn\n\t\t\t\tend -- Could have been disposed.\n\t\t\t\tif cast.StateInfo.CancelHighResCast then\n\t\t\t\t\tcast.StateInfo.CancelHighResCast = false\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\t\tPrintDebug(\"[\" .. segmentIndex .. \"] Subcast of time increment \" .. timeIncrement)\n\t\t\t\tSimulateCast(cast, timeIncrement, true)\n\t\t\tend\n\n\t\t\tif getmetatable(cast) == nil then\n\t\t\t\treturn\n\t\t\tend -- Could have been disposed.\n\t\t\tcast.StateInfo.IsActivelyResimulating = false\n\n\t\t\tif (tick() - timeAtStart) > 0.016 * 5 then\n\t\t\t\twarn(\"Extreme cast lag encountered! Consider increasing HighFidelitySegmentSize.\")\n\t\t\tend\n\t\telse\n\t\t\tSimulateCast(cast, delta, false)\n\t\tend\n\tend)\n\n\treturn cast\nend\n\nfunction ActiveCastStatic.SetStaticFastCastReference(ref)\n\tFastCast = ref\nend\n\n---- GETTERS AND SETTERS ----\n\nlocal function ModifyTransformation(cast: ActiveCast, velocity: Vector3?, acceleration: Vector3?, position: Vector3?)\n\tlocal trajectories = cast.StateInfo.Trajectories\n\tlocal lastTrajectory = trajectories[#trajectories]\n\n\t-- NEW BEHAVIOR: Don't create a new trajectory if we haven't even used the current one.\n\tif lastTrajectory.StartTime == cast.StateInfo.TotalRuntime then\n\t\t-- This trajectory is fresh out of the box. Let's just change it since it hasn't actually affected the cast yet, so changes won't have adverse effects.\n\t\tif velocity == nil then\n\t\t\tvelocity = lastTrajectory.InitialVelocity\n\t\tend\n\t\tif acceleration == nil then\n\t\t\tacceleration = lastTrajectory.Acceleration\n\t\tend\n\t\tif position == nil then\n\t\t\tposition = lastTrajectory.Origin\n\t\tend\n\n\t\tlastTrajectory.Origin = position\n\t\tlastTrajectory.InitialVelocity = velocity\n\t\tlastTrajectory.Acceleration = acceleration\n\telse\n\t\t-- The latest trajectory is done. Set its end time and get its location.\n\t\tlastTrajectory.EndTime = cast.StateInfo.TotalRuntime\n\n\t\tlocal point, velAtPoint = unpack(GetLatestTrajectoryEndInfo(cast))\n\n\t\tif velocity == nil then\n\t\t\tvelocity = velAtPoint\n\t\tend\n\t\tif acceleration == nil then\n\t\t\tacceleration = lastTrajectory.Acceleration\n\t\tend\n\t\tif position == nil then\n\t\t\tposition = point\n\t\tend\n\t\ttable.insert(cast.StateInfo.Trajectories, {\n\t\t\tStartTime = cast.StateInfo.TotalRuntime,\n\t\t\tEndTime = -1,\n\t\t\tOrigin = position,\n\t\t\tInitialVelocity = velocity,\n\t\t\tAcceleration = acceleration,\n\t\t})\n\t\tcast.StateInfo.CancelHighResCast = true\n\tend\nend\n\nfunction ActiveCastStatic:SetVelocity(velocity: Vector3)\n\tassert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format(\"SetVelocity\", \"ActiveCast.new(...)\"))\n\tassert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\tModifyTransformation(self, velocity, nil, nil)\nend\n\nfunction ActiveCastStatic:SetAcceleration(acceleration: Vector3)\n\tassert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format(\"SetAcceleration\", \"ActiveCast.new(...)\"))\n\tassert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\tModifyTransformation(self, nil, acceleration, nil)\nend\n\nfunction ActiveCastStatic:SetPosition(position: Vector3)\n\tassert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format(\"SetPosition\", \"ActiveCast.new(...)\"))\n\tassert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\tModifyTransformation(self, nil, nil, position)\nend\n\nfunction ActiveCastStatic:GetVelocity(): Vector3\n\tassert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format(\"GetVelocity\", \"ActiveCast.new(...)\"))\n\tassert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\tlocal currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]\n\treturn GetVelocityAtTime(\n\t\tself.StateInfo.TotalRuntime - currentTrajectory.StartTime,\n\t\tcurrentTrajectory.InitialVelocity,\n\t\tcurrentTrajectory.Acceleration\n\t)\nend\n\nfunction ActiveCastStatic:GetAcceleration(): Vector3\n\tassert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format(\"GetAcceleration\", \"ActiveCast.new(...)\"))\n\tassert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\tlocal currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]\n\treturn currentTrajectory.Acceleration\nend\n\nfunction ActiveCastStatic:GetPosition(): Vector3\n\tassert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format(\"GetPosition\", \"ActiveCast.new(...)\"))\n\tassert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\tlocal currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]\n\treturn GetPositionAtTime(\n\t\tself.StateInfo.TotalRuntime - currentTrajectory.StartTime,\n\t\tcurrentTrajectory.Origin,\n\t\tcurrentTrajectory.InitialVelocity,\n\t\tcurrentTrajectory.Acceleration\n\t)\nend\n\n---- ARITHMETIC ----\n\nfunction ActiveCastStatic:AddVelocity(velocity: Vector3)\n\tassert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format(\"AddVelocity\", \"ActiveCast.new(...)\"))\n\tassert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\tself:SetVelocity(self:GetVelocity() + velocity)\nend\n\nfunction ActiveCastStatic:AddAcceleration(acceleration: Vector3)\n\tassert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format(\"AddAcceleration\", \"ActiveCast.new(...)\"))\n\tassert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\tself:SetAcceleration(self:GetAcceleration() + acceleration)\nend\n\nfunction ActiveCastStatic:AddPosition(position: Vector3)\n\tassert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format(\"AddPosition\", \"ActiveCast.new(...)\"))\n\tassert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\tself:SetPosition(self:GetPosition() + position)\nend\n\n---- STATE MODIFICATION ----\n\nfunction ActiveCastStatic:Pause()\n\tassert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format(\"Pause\", \"ActiveCast.new(...)\"))\n\tassert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\tself.StateInfo.Paused = true\nend\n\nfunction ActiveCastStatic:Resume()\n\tassert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format(\"Resume\", \"ActiveCast.new(...)\"))\n\tassert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\tself.StateInfo.Paused = false\nend\n\nfunction ActiveCastStatic:Terminate()\n\tassert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format(\"Terminate\", \"ActiveCast.new(...)\"))\n\tassert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)\n\n\t-- First: Set EndTime on the latest trajectory since it is now done simulating.\n\tlocal trajectories = self.StateInfo.Trajectories\n\tlocal lastTrajectory = trajectories[#trajectories]\n\tlastTrajectory.EndTime = self.StateInfo.TotalRuntime\n\n\t-- Disconnect the update connection.\n\tself.StateInfo.UpdateConnection:Disconnect()\n\n\t-- Now fire CastTerminating\n\tself.Caster.CastTerminating:FireSync(self)\n\n\t-- And now set the update connection object to nil.\n\tself.StateInfo.UpdateConnection = nil\n\n\t-- And nuke everything in the table + clear the metatable.\n\tself.Caster = nil\n\tself.StateInfo = nil\n\tself.RayInfo = nil\n\tself.UserData = nil\n\tsetmetatable(self, nil)\nend\n\nreturn ActiveCastStatic",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Signal",
                        "ClassName": "ModuleScript",
                        "Source": "--!nocheck\n-- ^ change to strict to crash studio c:\n\n-- A new implementation of RBXScriptSignal that uses proper Lua OOP.\n-- This was explicitly made to transport other OOP objects.\n-- I would be using BindableEvents, but they don't like cyclic tables (part of OOP objects with __index)\n\n-- Inject types\nlocal TypeDefs = require(script.Parent.TypeDefinitions)\ntype CanPierceFunction = TypeDefs.CanPierceFunction\ntype GenericTable = TypeDefs.GenericTable\ntype Caster = TypeDefs.Caster\ntype FastCastBehavior = TypeDefs.FastCastBehavior\ntype CastTrajectory = TypeDefs.CastTrajectory\ntype CastStateInfo = TypeDefs.CastStateInfo\ntype CastRayInfo = TypeDefs.CastRayInfo\ntype ActiveCast = TypeDefs.ActiveCast\n\nlocal TestService = game:GetService(\"TestService\")\nlocal table = require(script.Parent.Table)\n\nlocal SignalStatic = {}\nSignalStatic.__index = SignalStatic\nSignalStatic.__type = \"Signal\" -- For compatibility with TypeMarshaller\nlocal ConnectionStatic = {}\nConnectionStatic.__index = ConnectionStatic\nConnectionStatic.__type = \"SignalConnection\" -- For compatibility with TypeMarshaller\n\nexport type Signal = {\n\tName: string,\n\tConnections: { [number]: Connection },\n\tYieldingThreads: { [number]: BindableEvent },\n}\n\nexport type Connection = {\n\tSignal: Signal?,\n\tDelegate: any,\n\tIndex: number,\n}\n\n-- Format params: methodName, ctorName\nlocal ERR_NOT_INSTANCE =\n\t\"Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s\"\n\nfunction SignalStatic.new(signalName: string): Signal\n\tlocal signalObj: Signal = {\n\t\tName = signalName,\n\t\tConnections = {},\n\t\tYieldingThreads = {},\n\t}\n\treturn setmetatable(signalObj, SignalStatic)\nend\n\nlocal function NewConnection(sig: Signal, func: any): Connection\n\tlocal connectionObj: Connection = {\n\t\tSignal = sig,\n\t\tDelegate = func,\n\t\tIndex = -1,\n\t}\n\treturn setmetatable(connectionObj, ConnectionStatic)\nend\n\nlocal function ThreadAndReportError(delegate: any, args: GenericTable, handlerName: string)\n\tlocal thread = coroutine.create(function()\n\t\tdelegate(unpack(args))\n\tend)\n\tlocal success, msg = coroutine.resume(thread)\n\tif not success then\n\t\t-- For the love of god roblox PLEASE add the ability to customize message type in output statements.\n\t\t-- This \"testservice\" garbage at the start of my message is annoying as all hell.\n\t\tTestService:Error(string.format(\"Exception thrown in your %s event handler: %s\", handlerName, msg))\n\t\tTestService:Checkpoint(debug.traceback(thread))\n\tend\nend\n\nfunction SignalStatic:Connect(func)\n\tassert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format(\"Connect\", \"Signal.new()\"))\n\tlocal connection = NewConnection(self, func)\n\tconnection.Index = #self.Connections + 1\n\ttable.insert(self.Connections, connection.Index, connection)\n\treturn connection\nend\n\nfunction SignalStatic:Fire(...)\n\tassert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format(\"Fire\", \"Signal.new()\"))\n\tlocal args = table.pack(...)\n\tlocal allCons = self.Connections\n\tlocal yieldingThreads = self.YieldingThreads\n\tfor index = 1, #allCons do\n\t\tlocal connection = allCons[index]\n\t\tif connection.Delegate ~= nil then\n\t\t\t-- Catch case for disposed signals.\n\t\t\tThreadAndReportError(connection.Delegate, args, connection.Signal.Name)\n\t\tend\n\tend\n\tfor index = 1, #yieldingThreads do\n\t\tlocal thread = yieldingThreads[index]\n\t\tif thread ~= nil then\n\t\t\tcoroutine.resume(thread, ...)\n\t\tend\n\tend\nend\n\nfunction SignalStatic:FireSync(...)\n\tassert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format(\"FireSync\", \"Signal.new()\"))\n\tlocal args = table.pack(...)\n\tlocal allCons = self.Connections\n\tlocal yieldingThreads = self.YieldingThreads\n\tfor index = 1, #allCons do\n\t\tlocal connection = allCons[index]\n\t\tif connection.Delegate ~= nil then\n\t\t\t-- Catch case for disposed signals.\n\t\t\tconnection.Delegate(unpack(args))\n\t\tend\n\tend\n\tfor index = 1, #yieldingThreads do\n\t\tlocal thread = yieldingThreads[index]\n\t\tif thread ~= nil then\n\t\t\tcoroutine.resume(thread, ...)\n\t\tend\n\tend\nend\n\nfunction SignalStatic:Wait()\n\tassert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format(\"Wait\", \"Signal.new()\"))\n\tlocal args = {}\n\tlocal thread = coroutine.running()\n\ttable.insert(self.YieldingThreads, thread)\n\targs = { coroutine.yield() }\n\ttable.removeObject(self.YieldingThreads, thread)\n\treturn unpack(args)\nend\n\nfunction SignalStatic:Dispose()\n\tassert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format(\"Dispose\", \"Signal.new()\"))\n\tlocal allCons = self.Connections\n\tfor index = 1, #allCons do\n\t\tallCons[index]:Disconnect()\n\tend\n\tself.Connections = {}\n\tsetmetatable(self, nil)\nend\n\nfunction ConnectionStatic:Disconnect()\n\tassert(\n\t\tgetmetatable(self) == ConnectionStatic,\n\t\tERR_NOT_INSTANCE:format(\"Disconnect\", \"private function NewConnection()\")\n\t)\n\ttable.remove(self.Signal.Connections, self.Index)\n\tself.SignalStatic = nil\n\tself.Delegate = nil\n\tself.YieldingThreads = {}\n\tself.Index = -1\n\tsetmetatable(self, nil)\nend\n\nreturn SignalStatic",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "TypeDefinitions",
                        "ClassName": "ModuleScript",
                        "Source": "--!nocheck\n-- ^ change to strict to crash studio c:\n\n-- Defines all FC types.\n-- Any script that requires this will have these types defined.\n\n--[[\nlocal TypeDefs = require(script.TypeDefinitions)\ntype CanPierceFunction = TypeDefs.CanPierceFunction\ntype GenericTable = TypeDefs.GenericTable\ntype Caster = TypeDefs.Caster\ntype FastCastBehavior = TypeDefs.FastCastBehavior\ntype CastTrajectory = TypeDefs.CastTrajectory\ntype CastStateInfo = TypeDefs.CastStateInfo\ntype CastRayInfo = TypeDefs.CastRayInfo\ntype ActiveCast = TypeDefs.ActiveCast\n--]]\n\n-- Represents the function to determine piercing.\nexport type CanPierceFunction = (ActiveCast, RaycastResult, Vector3) -> boolean\n\n-- Represents any table.\nexport type GenericTable = { [any]: any }\n\n-- Represents a Caster :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/caster/\nexport type Caster = {\n\tWorldRoot: WorldRoot,\n\tLengthChanged: RBXScriptSignal,\n\tRayHit: RBXScriptSignal,\n\tRayPierced: RBXScriptSignal,\n\tCastTerminating: RBXScriptSignal,\n\tFire: (Vector3, Vector3, Vector3 | number, FastCastBehavior) -> (),\n}\n\n-- Represents a FastCastBehavior :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/fcbehavior/\nexport type FastCastBehavior = {\n\tRaycastParams: RaycastParams?,\n\tMaxDistance: number,\n\tAcceleration: Vector3,\n\tHighFidelityBehavior: number,\n\tHighFidelitySegmentSize: number,\n\tCosmeticBulletTemplate: Instance?,\n\tCosmeticBulletProvider: any, -- Intended to be a PartCache. Dictated via TypeMarshaller.\n\tCosmeticBulletContainer: Instance?,\n\tAutoIgnoreContainer: boolean,\n\tCanPierceFunction: CanPierceFunction,\n}\n\n-- Represents a CastTrajectory :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/casttrajectory/\nexport type CastTrajectory = {\n\tStartTime: number,\n\tEndTime: number,\n\tOrigin: Vector3,\n\tInitialVelocity: Vector3,\n\tAcceleration: Vector3,\n}\n\n-- Represents a CastStateInfo :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/caststateinfo/\nexport type CastStateInfo = {\n\tUpdateConnection: RBXScriptSignal,\n\tHighFidelityBehavior: number,\n\tHighFidelitySegmentSize: number,\n\tPaused: boolean,\n\tTotalRuntime: number,\n\tDistanceCovered: number,\n\tIsActivelySimulatingPierce: boolean,\n\tIsActivelyResimulating: boolean,\n\tCancelHighResCast: boolean,\n\tTrajectories: { [number]: CastTrajectory },\n}\n\n-- Represents a CastRayInfo :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/castrayinfo/\nexport type CastRayInfo = {\n\tParameters: RaycastParams,\n\tWorldRoot: WorldRoot,\n\tMaxDistance: number,\n\tCosmeticBulletObject: Instance?,\n\tCanPierceCallback: CanPierceFunction,\n}\n\n-- Represents an ActiveCast :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/activecast/\nexport type ActiveCast = {\n\tCaster: Caster,\n\tStateInfo: CastStateInfo,\n\tRayInfo: CastRayInfo,\n\tUserData: { [any]: any },\n}\n\nreturn {}",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "TypeMarshaller",
                        "ClassName": "ModuleScript",
                        "Source": "--!nocheck\n-- ^ change to strict to crash studio c:\n\nlocal oldtypeof = typeof\nlocal function typeof(objIn: any): string\n\tlocal objType = oldtypeof(objIn)\n\tif objType ~= \"table\" then\n\t\treturn objType\n\tend\n\n\t-- Could be a custom type if it's a table.\n\tlocal meta = getmetatable(objIn)\n\tif oldtypeof(meta) ~= \"table\" then\n\t\treturn objType\n\tend\n\n\t-- Has a metatable that's an exposed table.\n\tlocal customType: string? = meta[\"__type\"] -- I want to mandate that this is a string.\n\tif customType == nil then\n\t\treturn objType\n\tend\n\n\t-- Has a type field\n\treturn customType\nend\n\nreturn typeof",
                        "Children": [],
                        "Archivable": true
                    }
                ],
                "Archivable": true
            }
        ]
    },
    {
        "ID": "qpCUnJbmxy",
        "Name": "TopbarPlus",
        "Author": "ForeverHD",
        "Description": "A topbar menu system that inhabits the roblox topbar with extensive console support",
        "Downloads": 0,
        "Serialized": [
            {
                "Name": "TopbarPlus",
                "Archivable": true,
                "Children": [
                    {
                        "Name": "Icon",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\t\n\tThe majority of this code is an interface designed to make it easy for you to\n\twork with TopbarPlus (most methods for instance reference :modifyTheme()).\n\tThe processing overhead mainly consists of applying themes and calculating \n\tappearance (such as size and width of labels) which is handled in about\n\t200 lines of code here and the Widget UI module. This has been achieved\n\tin v3 by outsourcing a majority of previous calculations to inbuilt Roblox\n\tfeatures like UIListLayouts.\n\n\n\tv3 provides inbuilt support for controllers (simply press DPadUp),\n\ttouch devices (phones, tablets , etc), localization (automatic resizing\n\tof widgets, autolocalize for relevant labels), backwards compatability\n\twith the old topbar, and more.\n\n\n\tMy primary goals for the v3 re-write have been to:\n\t\t\n\t1. Improve code readability and organisation (reduced lines of code within\n\t   Icon+IconController from 3200 to ~950, separated UI elements, etc)\n\t\t\n\t2. Improve ease-of-use (themes now actually make sense and can account\n\t   for any modifications you want, converted to a package for\n\t   quick installation and easy-comparisons of new updates, etc)\n\t\n\t3. Provide support for all key features of the new Roblox topbar\n\t   while improving performance of the module (deferring and collecting\n\t   changes then calling as a singular, utilizing inbuilt Roblox features\n\t   such as UILIstLayouts, etc)\n\n--]]\n\n\n\n-- SERVICES\nlocal LocalizationService = game:GetService(\"LocalizationService\")\nlocal UserInputService = game:GetService(\"UserInputService\")\nlocal RunService = game:GetService(\"RunService\")\nlocal TextService = game:GetService(\"TextService\")\nlocal StarterGui = game:GetService(\"StarterGui\")\nlocal GuiService = game:GetService(\"GuiService\")\nlocal Players = game:GetService(\"Players\")\n\n\n\n-- REFERENCE HANDLER\n-- Multiple Icons packages may exist at runtime (for instance if the developer additionally uses HD Admin)\n-- therefore this ensures that the first required package becomes the dominant and only functioning module\nlocal iconModule = script\nlocal Reference = require(iconModule.Reference)\nlocal referenceObject = Reference.getObject()\nlocal leadPackage = referenceObject and referenceObject.Value\nif leadPackage and leadPackage ~= iconModule then\n\treturn require(leadPackage)\nend\nif not referenceObject then\n\tReference.addToReplicatedStorage()\nend\n\n\n\n-- MODULES\nlocal Signal = require(iconModule.Packages.GoodSignal)\nlocal Janitor = require(iconModule.Packages.Janitor)\nlocal Utility = require(iconModule.Utility)\nlocal Attribute = require(iconModule.Attribute)\nlocal Themes = require(iconModule.Features.Themes)\nlocal Gamepad = require(iconModule.Features.Gamepad)\nlocal Overflow = require(iconModule.Features.Overflow)\nlocal Icon = {}\nIcon.__index = Icon\n\n\n\n--- LOCAL\nlocal localPlayer = Players.LocalPlayer\nlocal themes = iconModule.Features.Themes\nlocal playerGui = localPlayer:WaitForChild(\"PlayerGui\")\nlocal iconsDict = {}\nlocal anyIconSelected = Signal.new()\nlocal elements = iconModule.Elements\nlocal totalCreatedIcons = 0\n\n\n\n-- PRESETUP\n-- This is only used to determine if we need to apply the old topbar theme\n-- I'll be removing this and associated functions once all games have\n-- fully transitioned over to the new topbar\nif GuiService.TopbarInset.Height == 0 then\n\tGuiService:GetPropertyChangedSignal(\"TopbarInset\"):Wait()\nend\n\n\n\n-- PUBLIC VARIABLES\nIcon.baseDisplayOrderChanged = Signal.new()\nIcon.baseDisplayOrder = 10\nIcon.baseTheme = require(themes.Default)\nIcon.isOldTopbar = GuiService.TopbarInset.Height == 36\nIcon.iconsDictionary = iconsDict\nIcon.container = require(elements.Container)(Icon)\nIcon.topbarEnabled = true\nIcon.iconAdded = Signal.new()\nIcon.iconRemoved = Signal.new()\nIcon.iconChanged = Signal.new()\n\n\n\n-- PUBLIC FUNCTIONS\nfunction Icon.getIcons()\n\treturn Icon.iconsDictionary\nend\n\nfunction Icon.getIconByUID(UID)\n\tlocal match = Icon.iconsDictionary[UID]\n\tif match then\n\t\treturn match\n\tend\nend\n\nfunction Icon.getIcon(nameOrUID)\n\tlocal match = Icon.getIconByUID(nameOrUID)\n\tif match then\n\t\treturn match\n\tend\n\tfor _, icon in pairs(iconsDict) do\n\t\tif icon.name == nameOrUID then\n\t\t\treturn icon\n\t\tend\n\tend\nend\n\nfunction Icon.setTopbarEnabled(bool, isInternal)\n\tif typeof(bool) ~= \"boolean\" then\n\t\tbool = Icon.topbarEnabled\n\tend\n\tif not isInternal then\n\t\tIcon.topbarEnabled = bool\n\tend\n\tfor _, screenGui in pairs(Icon.container) do\n\t\tscreenGui.Enabled = bool\n\tend\nend\n\nfunction Icon.modifyBaseTheme(modifications)\n\tmodifications = Themes.getModifications(modifications)\n\tfor _, modification in pairs(modifications) do\n\t\tfor _, detail in pairs(Icon.baseTheme) do\n\t\t\tThemes.merge(detail, modification)\n\t\tend\n\tend\n\tfor _, icon in pairs(iconsDict) do\n\t\ticon:setTheme(Icon.baseTheme)\n\tend\nend\n\nfunction Icon.setDisplayOrder(int)\n\tIcon.baseDisplayOrder = int\n\tIcon.baseDisplayOrderChanged:Fire(int)\nend\n\n\n\n-- SETUP\ntask.defer(Gamepad.start, Icon)\ntask.defer(Overflow.start, Icon)\nfor _, screenGui in pairs(Icon.container) do\n\tscreenGui.Parent = playerGui\nend\nif Icon.isOldTopbar then\n\tIcon.modifyBaseTheme(require(themes.Classic))\nend\n\n\n\n-- CONSTRUCTOR\nfunction Icon.new()\n\tlocal self = {}\n\tsetmetatable(self, Icon)\n\n\t--- Janitors (for cleanup)\n\tlocal janitor = Janitor.new()\n\tself.janitor = janitor\n\tself.themesJanitor = janitor:add(Janitor.new())\n\tself.singleClickJanitor = janitor:add(Janitor.new())\n\tself.captionJanitor = janitor:add(Janitor.new())\n\tself.joinJanitor = janitor:add(Janitor.new())\n\tself.menuJanitor = janitor:add(Janitor.new())\n\tself.dropdownJanitor = janitor:add(Janitor.new())\n\n\t-- Register\n\tlocal iconUID = Utility.generateUID()\n\ticonsDict[iconUID] = self\n\tjanitor:add(function()\n\t\ticonsDict[iconUID] = nil\n\tend)\n\n\t-- Signals (events)\n\tself.selected = janitor:add(Signal.new())\n\tself.deselected = janitor:add(Signal.new())\n\tself.toggled = janitor:add(Signal.new())\n\tself.viewingStarted = janitor:add(Signal.new())\n\tself.viewingEnded = janitor:add(Signal.new())\n\tself.stateChanged = janitor:add(Signal.new())\n\tself.notified = janitor:add(Signal.new())\n\tself.noticeStarted = janitor:add(Signal.new())\n\tself.noticeChanged = janitor:add(Signal.new())\n\tself.endNotices = janitor:add(Signal.new())\n\tself.toggleKeyAdded = janitor:add(Signal.new())\n\tself.fakeToggleKeyChanged = janitor:add(Signal.new())\n\tself.alignmentChanged = janitor:add(Signal.new())\n\tself.updateSize = janitor:add(Signal.new())\n\tself.resizingComplete = janitor:add(Signal.new())\n\tself.joinedParent = janitor:add(Signal.new())\n\tself.menuSet = janitor:add(Signal.new())\n\tself.dropdownSet = janitor:add(Signal.new())\n\tself.updateMenu = janitor:add(Signal.new())\n\tself.startMenuUpdate = janitor:add(Signal.new())\n\tself.childThemeModified = janitor:add(Signal.new())\n\tself.indicatorSet = janitor:add(Signal.new())\n\tself.dropdownChildAdded = janitor:add(Signal.new())\n\tself.menuChildAdded = janitor:add(Signal.new())\n\n\t-- Properties\n\tself.iconModule = iconModule\n\tself.UID = iconUID\n\tself.isEnabled = true\n\tself.isSelected = false\n\tself.isViewing = false\n\tself.joinedFrame = false\n\tself.parentIconUID = false\n\tself.deselectWhenOtherIconSelected = true\n\tself.totalNotices = 0\n\tself.activeState = \"Deselected\"\n\tself.alignment = \"\"\n\tself.originalAlignment = \"\"\n\tself.appliedTheme = {}\n\tself.appearance = {}\n\tself.cachedInstances = {}\n\tself.cachedNamesToInstances = {}\n\tself.cachedCollectives = {}\n\tself.bindedToggleKeys = {}\n\tself.customBehaviours = {}\n\tself.toggleItems = {}\n\tself.bindedEvents = {}\n\tself.notices = {}\n\tself.menuIcons = {}\n\tself.dropdownIcons = {}\n\tself.childIconsDict = {}\n\tself.isOldTopbar = Icon.isOldTopbar\n\tself.creationTime = os.clock()\n\n\t-- Widget is the new name for an icon\n\tlocal widget = janitor:add(require(elements.Widget)(self, Icon))\n\tself.widget = widget\n\tself:setAlignment()\n\t\n\t-- It's important we set an order otherwise icons will not align\n\t-- correctly within menus\n\ttotalCreatedIcons += 1\n\tlocal ourOrder = totalCreatedIcons\n\tself:setOrder(ourOrder)\n\n\t-- This applies the default them\n\tself:setTheme(Icon.baseTheme)\n\n\t-- Button Clicked (for states \"Selected\" and \"Deselected\")\n\tlocal clickRegion = self:getInstance(\"ClickRegion\")\n\tlocal function handleToggle()\n\t\tif self.locked then\n\t\t\treturn\n\t\tend\n\t\tif self.isSelected then\n\t\t\tself:deselect(\"User\", self)\n\t\telse\n\t\t\tself:select(\"User\", self)\n\t\tend\n\tend\n\tlocal isTouchTapping = false\n\tlocal isClicking = false\n\tclickRegion.MouseButton1Click:Connect(function()\n\t\tif isTouchTapping then\n\t\t\treturn\n\t\tend\n\t\tisClicking = true\n\t\ttask.delay(0.01, function()\n\t\t\tisClicking = false\n\t\tend)\n\t\thandleToggle()\n\tend)\n\tclickRegion.TouchTap:Connect(function()\n\t\t-- This resolves the bug report by @28Pixels:\n\t\t-- https://devforum.roblox.com/t/topbarplus/1017485/1104\n\t\tif isClicking then\n\t\t\treturn\n\t\tend\n\t\tisTouchTapping = true\n\t\ttask.delay(0.01, function()\n\t\t\tisTouchTapping = false\n\t\tend)\n\t\thandleToggle()\n\tend)\n\n\t-- Keys can be bound to toggle between Selected and Deselected\n\tjanitor:add(UserInputService.InputBegan:Connect(function(input, touchingAnObject)\n\t\tif self.locked then\n\t\t\treturn\n\t\tend\n\t\tif self.bindedToggleKeys[input.KeyCode] and not touchingAnObject then\n\t\t\thandleToggle()\n\t\tend\n\tend))\n\n\t-- Button Hovering (for state \"Viewing\")\n\t-- Hovering is a state only for devices with keyboards\n\t-- and controllers (not touchpads)\n\tlocal function viewingStarted(dontSetState)\n\t\tif self.locked then\n\t\t\treturn\n\t\tend\n\t\tself.isViewing = true\n\t\tself.viewingStarted:Fire(true)\n\t\tif not dontSetState then\n\t\t\tself:setState(\"Viewing\", \"User\", self)\n\t\tend\n\tend\n\tlocal function viewingEnded()\n\t\tif self.locked then\n\t\t\treturn\n\t\tend\n\t\tself.isViewing = false\n\t\tself.viewingEnded:Fire(true)\n\t\tself:setState(nil, \"User\", self)\n\tend\n\tself.joinedParent:Connect(function()\n\t\tif self.isViewing then\n\t\t\tviewingEnded()\n\t\tend\n\tend)\n\tclickRegion.MouseEnter:Connect(function()\n\t\tlocal dontSetState = not UserInputService.KeyboardEnabled\n\t\tviewingStarted(dontSetState)\n\tend)\n\tlocal touchCount = 0\n\tjanitor:add(UserInputService.TouchEnded:Connect(viewingEnded))\n\tclickRegion.MouseLeave:Connect(viewingEnded)\n\tclickRegion.SelectionGained:Connect(viewingStarted)\n\tclickRegion.SelectionLost:Connect(viewingEnded)\n\tclickRegion.MouseButton1Down:Connect(function()\n\t\tif not self.locked and UserInputService.TouchEnabled then\n\t\t\ttouchCount += 1\n\t\t\tlocal myTouchCount = touchCount\n\t\t\ttask.delay(0.2, function()\n\t\t\t\tif myTouchCount == touchCount then\n\t\t\t\t\tviewingStarted()\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\tend)\n\tclickRegion.MouseButton1Up:Connect(function()\n\t\ttouchCount += 1\n\tend)\n\n\t-- Handle overlay on viewing\n\tlocal iconOverlay = self:getInstance(\"IconOverlay\")\n\tself.viewingStarted:Connect(function()\n\t\ticonOverlay.Visible = not self.overlayDisabled\n\tend)\n\tself.viewingEnded:Connect(function()\n\t\ticonOverlay.Visible = false\n\tend)\n\n\t-- Deselect when another icon is selected\n\tjanitor:add(anyIconSelected:Connect(function(incomingIcon)\n\t\tif incomingIcon ~= self and self.deselectWhenOtherIconSelected and incomingIcon.deselectWhenOtherIconSelected then\n\t\t\tself:deselect(\"AutoDeselect\", incomingIcon)\n\t\tend\n\tend))\n\n\t-- This checks if the script calling this module is a descendant of a ScreenGui\n\t-- with 'ResetOnSpawn' set to true. If it is, then we destroy the icon the\n\t-- client respawns. This solves one of the most asked about questions on the post\n\t-- The only caveat this may not work if the player doesn't uniquely name their ScreenGui and the frames\n\t-- the LocalScript rests within\n\tlocal source =  debug.info(2, \"s\")\n\tlocal sourcePath = string.split(source, \".\")\n\tlocal origin = game\n\tlocal originsScreenGui\n\tfor i, sourceName in pairs(sourcePath) do\n\t\torigin = origin:FindFirstChild(sourceName)\n\t\tif not origin then\n\t\t\tbreak\n\t\tend\n\t\tif origin:IsA(\"ScreenGui\") then\n\t\t\toriginsScreenGui = origin\n\t\tend\n\tend\n\tif origin and originsScreenGui and originsScreenGui.ResetOnSpawn == true then\n\t\tUtility.localPlayerRespawned(function()\n\t\t\tself:destroy()\n\t\tend)\n\tend\n\n\t-- Additional children behaviour when toggled (mostly notices)\n\tlocal noticeLabel = self:getInstance(\"NoticeLabel\")\n\tself.toggled:Connect(function(isSelected)\n\t\tself.noticeChanged:Fire(self.totalNotices)\n\t\tfor childIconUID, _ in pairs(self.childIconsDict) do\n\t\t\tlocal childIcon = Icon.getIconByUID(childIconUID)\n\t\t\tchildIcon.noticeChanged:Fire(childIcon.totalNotices)\n\t\t\tif not isSelected and childIcon.isSelected then\n\t\t\t\t-- If an icon within a menu or dropdown is also\n\t\t\t\t-- a dropdown or menu, then close it\n\t\t\t\tfor _, _ in pairs(childIcon.childIconsDict) do\n\t\t\t\t\tchildIcon:deselect(\"HideParentFeature\", self)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend)\n\t\n\t-- This closes/reopens the chat or playerlist if the icon is a dropdown\n\t-- In the future I'd prefer to use the position+size of the chat\n\t-- to determine whether to close dropdown (instead of non-right-set)\n\t-- but for reasons mentioned here it's unreliable at the time of\n\t-- writing this: https://devforum.roblox.com/t/here/2794915\n\t-- I could also make this better by accounting for multiple\n\t-- dropdowns being open (not just this one) but this will work\n\t-- fine for almost every use case for now.\n\tself.selected:Connect(function()\n\t\tlocal isDropdown = #self.dropdownIcons > 0\n\t\tif isDropdown then\n\t\t\tif StarterGui:GetCore(\"ChatActive\") and self.alignment ~= \"Right\" then\n\t\t\t\tself.chatWasPreviouslyActive = true\n\t\t\t\tStarterGui:SetCore(\"ChatActive\", false)\n\t\t\tend\n\t\t\tif StarterGui:GetCoreGuiEnabled(\"PlayerList\") and self.alignment ~= \"Left\" then\n\t\t\t\tself.playerlistWasPreviouslyActive = true\n\t\t\t\tStarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)\n\t\t\tend\n\t\tend\n\tend)\n\tself.deselected:Connect(function()\n\t\tif self.chatWasPreviouslyActive then\n\t\t\tself.chatWasPreviouslyActive = nil\n\t\t\tStarterGui:SetCore(\"ChatActive\", true)\n\t\tend\n\t\tif self.playerlistWasPreviouslyActive then\n\t\t\tself.playerlistWasPreviouslyActive = nil\n\t\t\tStarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)\n\t\tend\n\tend)\n\t\n\t-- There's a rare occassion where the appearance is not\n\t-- fully set to deselected so this ensures the icons\n\t-- appearance is fully as it should be\n\t--print(\"self.activeState =\", self.activeState)\n\ttask.delay(0.1, function()\n\t\tif self.activeState == \"Deselected\" then\n\t\t\tself.stateChanged:Fire(\"Deselected\")\n\t\t\tself:refresh()\n\t\tend\n\tend)\n\t\n\t-- Call icon added\n\tIcon.iconAdded:Fire(self)\n\n\treturn self\nend\n\n\n\n-- METHODS\nfunction Icon:setName(name)\n\tself.widget.Name = name\n\tself.name = name\n\treturn self\nend\n\nfunction Icon:setState(incomingStateName, fromSource, sourceIcon)\n\t-- This is responsible for acknowleding a change in stage (such as from \"Deselected\" to \"Viewing\" when\n\t-- a users mouse enters the widget), then informing other systems of this state change to then act upon\n\t-- (such as the theme handler applying the theme which corresponds to that state).\n\tif not incomingStateName then\n\t\tincomingStateName = (self.isSelected and \"Selected\") or \"Deselected\"\n\tend\n\tlocal stateName = Utility.formatStateName(incomingStateName)\n\tlocal previousStateName = self.activeState\n\tif previousStateName == stateName then\n\t\treturn\n\tend\n\tlocal currentIsSelected = self.isSelected\n\tself.activeState = stateName\n\tif stateName == \"Deselected\" then\n\t\tself.isSelected = false\n\t\tif currentIsSelected then\n\t\t\tself.toggled:Fire(false, fromSource, sourceIcon)\n\t\t\tself.deselected:Fire(fromSource, sourceIcon)\n\t\tend\n\t\tself:_setToggleItemsVisible(false, fromSource, sourceIcon)\n\telseif stateName == \"Selected\" then\n\t\tself.isSelected = true\n\t\tif not currentIsSelected then\n\t\t\tself.toggled:Fire(true, fromSource, sourceIcon)\n\t\t\tself.selected:Fire(fromSource, sourceIcon)\n\t\t\tanyIconSelected:Fire(self, fromSource, sourceIcon)\n\t\tend\n\t\tself:_setToggleItemsVisible(true, fromSource, sourceIcon)\n\tend\n\tself.stateChanged:Fire(stateName, fromSource, sourceIcon)\nend\n\nfunction Icon:getInstance(name)\n\t-- This enables us to easily retrieve instances located within the icon simply by passing its name.\n\t-- Every important/significant instance is named uniquely therefore this is no worry of overlap.\n\t-- We cache the result for more performant retrieval in the future.\n\tlocal instance = self.cachedNamesToInstances[name]\n\tif instance then\n\t\treturn instance\n\tend\n\tlocal function cacheInstance(childName, child)\n\t\tlocal currentCache = self.cachedInstances[child]\n\t\tif not currentCache then\n\t\t\tlocal collectiveName = child:GetAttribute(\"Collective\")\n\t\t\tlocal cachedCollective = collectiveName and self.cachedCollectives[collectiveName]\n\t\t\tif cachedCollective then\n\t\t\t\ttable.insert(cachedCollective, child)\n\t\t\tend\n\t\t\tself.cachedNamesToInstances[childName] = child\n\t\t\tself.cachedInstances[child] = true\n\t\t\tchild.Destroying:Once(function()\n\t\t\t\tself.cachedNamesToInstances[childName] = nil\n\t\t\t\tself.cachedInstances[child] = nil\n\t\t\tend)\n\t\tend\n\tend\n\tlocal widget = self.widget\n\tcacheInstance(\"Widget\", widget)\n\tif name == \"Widget\" then\n\t\treturn widget\n\tend\n\n\tlocal returnChild\n\tlocal function scanChildren(parentInstance)\n\t\tfor _, child in pairs(parentInstance:GetChildren()) do\n\t\t\tlocal widgetUID = child:GetAttribute(\"WidgetUID\")\n\t\t\tif widgetUID and widgetUID ~= self.UID then\n\t\t\t\t-- This prevents instances within other icons from being recorded\n\t\t\t\t-- (for instance when other icons are added to this icons menu)\n\t\t\t\tcontinue\n\t\t\tend\n\t\t\t-- If the child is a fake placeholder instance (such as dropdowns, notices, etc)\n\t\t\t-- then its important we scan the real original instance instead of this clone\n\t\t\tlocal previousChild = child\n\t\t\tlocal realChild = Themes.getRealInstance(child)\n\t\t\tif realChild then\n\t\t\t\tchild = realChild\n\t\t\tend\n\t\t\t-- Finally scan its children\n\t\t\tscanChildren(child)\n\t\t\tif child:IsA(\"GuiBase\") or child:IsA(\"UIBase\") or child:IsA(\"ValueBase\") then\n\t\t\t\tlocal childName = child.Name\n\t\t\t\tcacheInstance(childName, child)\n\t\t\t\tif childName == name then\n\t\t\t\t\treturnChild = child\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tscanChildren(widget)\n\treturn returnChild\nend\n\nfunction Icon:getCollective(name)\n\t-- A collective is an array of instances within the Widget that have been\n\t-- grouped together based on a given name. This just makes it easy\n\t-- to act on multiple instances at once which share similar behaviours.\n\t-- For instance, if we want to change the icons corner size, all corner instances\n\t-- with the attribute \"Collective\" and value \"WidgetCorner\" could be updated\n\t-- instantly by doing Themes.apply(icon, \"WidgetCorner\", newSize)\n\tlocal collective = self.cachedCollectives[name]\n\tif collective then\n\t\treturn collective\n\tend\n\tcollective = {}\n\tfor instance, _ in pairs(self.cachedInstances) do\n\t\tif instance:GetAttribute(\"Collective\") == name then\n\t\t\ttable.insert(collective, instance)\n\t\tend\n\tend\n\tself.cachedCollectives[name] = collective\n\treturn collective\nend\n\nfunction Icon:getInstanceOrCollective(collectiveOrInstanceName)\n\t-- Similar to :getInstance but also accounts for 'Collectives', such as UICorners and returns\n\t-- an array of instances instead of a single instance\n\tlocal instances = {}\n\tlocal instance = self:getInstance(collectiveOrInstanceName)\n\tif instance then\n\t\ttable.insert(instances, instance)\n\tend\n\tif #instances == 0 then\n\t\tinstances = self:getCollective(collectiveOrInstanceName)\n\tend\n\treturn instances\nend\n\nfunction Icon:getStateGroup(iconState)\n\tlocal chosenState = iconState or self.activeState\n\tlocal stateGroup = self.appearance[chosenState]\n\tif not stateGroup then\n\t\tstateGroup = {}\n\t\tself.appearance[chosenState] = stateGroup\n\tend\n\treturn stateGroup\nend\n\nfunction Icon:refreshAppearance(instance, specificProperty)\n\tThemes.refresh(self, instance, specificProperty)\n\treturn self\nend\n\nfunction Icon:refresh()\n\tself:refreshAppearance(self.widget)\n\tself.updateSize:Fire()\n\treturn self\nend\n\nfunction Icon:updateParent()\n\tlocal parentIcon = Icon.getIconByUID(self.parentIconUID)\n\tif parentIcon then\n\t\tparentIcon.updateSize:Fire()\n\tend\nend\n\nfunction Icon:setBehaviour(collectiveOrInstanceName, property, callback, refreshAppearance)\n\t-- You can specify your own custom callback to handle custom logic just before\n\t-- an instances property is changed by using :setBehaviour()\n\tlocal key = collectiveOrInstanceName..\"-\"..property\n\tself.customBehaviours[key] = callback\n\tif refreshAppearance then\n\t\tlocal instances = self:getInstanceOrCollective(collectiveOrInstanceName)\n\t\tfor _, instance in pairs(instances) do\n\t\t\tself:refreshAppearance(instance, property)\n\t\tend\n\tend\nend\n\nfunction Icon:modifyTheme(modifications, modificationUID)\n\tlocal modificationUID = Themes.modify(self, modifications, modificationUID)\n\treturn self, modificationUID\nend\n\nfunction Icon:modifyChildTheme(modifications, modificationUID)\n\t-- Same as modifyTheme except for its children (i.e. icons\n\t-- within its dropdown or menu)\n\tself.childModifications = modifications\n\tself.childModificationsUID = modificationUID\n\tfor childIconUID, _ in pairs(self.childIconsDict) do\n\t\tlocal childIcon = Icon.getIconByUID(childIconUID)\n\t\tchildIcon:modifyTheme(modifications, modificationUID)\n\tend\n\tself.childThemeModified:Fire()\n\treturn self\nend\n\nfunction Icon:removeModification(modificationUID)\n\tThemes.remove(self, modificationUID)\n\treturn self\nend\n\nfunction Icon:removeModificationWith(instanceName, property, state)\n\tThemes.removeWith(self, instanceName, property, state)\n\treturn self\nend\n\nfunction Icon:setTheme(theme)\n\tThemes.set(self, theme)\n\treturn self\nend\n\nfunction Icon:setEnabled(bool)\n\tself.isEnabled = bool\n\tself.widget.Visible = bool\n\tself:updateParent()\n\treturn self\nend\n\nfunction Icon:select(fromSource, sourceIcon)\n\tself:setState(\"Selected\", fromSource, sourceIcon)\n\treturn self\nend\n\nfunction Icon:deselect(fromSource, sourceIcon)\n\tself:setState(\"Deselected\", fromSource, sourceIcon)\n\treturn self\nend\n\nfunction Icon:notify(customClearSignal, noticeId)\n\t-- Generates a notification which appears in the top right of the icon. Useful for example for prompting\n\t-- users of changes/updates within your UI such as a Catalog\n\t-- 'customClearSignal' is a signal object (e.g. icon.deselected) or\n\t-- Roblox event (e.g. Instance.new(\"BindableEvent\").Event)\n\tlocal notice = self.notice\n\tif not notice then\n\t\tnotice = require(elements.Notice)(self, Icon)\n\t\tself.notice = notice\n\tend\n\tself.noticeStarted:Fire(customClearSignal, noticeId)\n\treturn self\nend\n\nfunction Icon:clearNotices()\n\tself.endNotices:Fire()\n\treturn self\nend\n\nfunction Icon:disableOverlay(bool)\n\tself.overlayDisabled = bool\n\treturn self\nend\nIcon.disableStateOverlay = Icon.disableOverlay\n\nfunction Icon:setImage(imageId, iconState)\n\tself:modifyTheme({\"IconImage\", \"Image\", imageId, iconState})\n\treturn self\nend\n\nfunction Icon:setLabel(text, iconState)\n\tself:modifyTheme({\"IconLabel\", \"Text\", text, iconState})\n\treturn self\nend\n\nfunction Icon:setOrder(int, iconState)\n\tself:modifyTheme({\"Widget\", \"LayoutOrder\", int, iconState})\n\treturn self\nend\n\nfunction Icon:setCornerRadius(udim, iconState)\n\tself:modifyTheme({\"IconCorners\", \"CornerRadius\", udim, iconState})\n\treturn self\nend\n\nfunction Icon:align(leftCenterOrRight, isFromParentIcon)\n\t-- Determines the side of the screen the icon will be ordered\n\tlocal direction = tostring(leftCenterOrRight):lower()\n\tif direction == \"mid\" or direction == \"centre\" then\n\t\tdirection = \"center\"\n\tend\n\tif direction ~= \"left\" and direction ~= \"center\" and direction ~= \"right\" then\n\t\tdirection = \"left\"\n\tend\n\tlocal screenGui = (direction == \"center\" and Icon.container.TopbarCentered) or Icon.container.TopbarStandard\n\tlocal holders = screenGui.Holders\n\tlocal finalDirection = string.upper(string.sub(direction, 1, 1))..string.sub(direction, 2)\n\tif not isFromParentIcon then\n\t\tself.originalAlignment = finalDirection\n\tend\n\tlocal joinedFrame = self.joinedFrame\n\tlocal alignmentHolder = holders[finalDirection]\n\tself.screenGui = screenGui\n\tself.alignmentHolder = alignmentHolder\n\tif not self.isDestroyed then\n\t\tself.widget.Parent = joinedFrame or alignmentHolder\n\tend\n\tself.alignment = finalDirection\n\tself.alignmentChanged:Fire(finalDirection)\n\tIcon.iconChanged:Fire(self)\n\treturn self\nend\nIcon.setAlignment = Icon.align\n\nfunction Icon:setLeft()\n\tself:setAlignment(\"Left\")\n\treturn self\nend\n\nfunction Icon:setMid()\n\tself:setAlignment(\"Center\")\n\treturn self\nend\n\nfunction Icon:setRight()\n\tself:setAlignment(\"Right\")\n\treturn self\nend\n\nfunction Icon:setWidth(offsetMinimum, iconState)\n\t-- This sets a minimum X offset size for the widget, useful\n\t-- for example if you're constantly changing the label\n\t-- but don't want the icon to resize every time\n\tlocal newSize = UDim2.fromOffset(offsetMinimum, self.widget.Size.Y.Offset)\n\tself:modifyTheme({\"Widget\", \"Size\", newSize, iconState})\n\tself:modifyTheme({\"Widget\", \"DesiredWidth\", offsetMinimum, iconState})\n\treturn self\nend\n\nfunction Icon:setImageScale(number, iconState)\n\tself:modifyTheme({\"IconImageScale\", \"Value\", number, iconState})\n\treturn self\nend\n\nfunction Icon:setImageRatio(number, iconState)\n\tself:modifyTheme({\"IconImageRatio\", \"AspectRatio\", number, iconState})\n\treturn self\nend\n\nfunction Icon:setTextSize(number, iconState)\n\tself:modifyTheme({\"IconLabel\", \"TextSize\", number, iconState})\n\treturn self\nend\n\nfunction Icon:setTextFont(font, fontWeight, fontStyle, iconState)\n\tfontWeight = fontWeight or Enum.FontWeight.Regular\n\tfontStyle = fontStyle or Enum.FontStyle.Normal\n\tlocal fontFace\n\tlocal fontType = typeof(font)\n\tif fontType == \"number\" then\n\t\tfontFace = Font.fromId(font, fontWeight, fontStyle)\n\telseif fontType == \"EnumItem\" then\n\t\tfontFace = Font.fromEnum(font)\n\telseif fontType == \"string\" then\n\t\tif not font:match(\"rbxasset\") then\n\t\t\tfontFace = Font.fromName(font, fontWeight, fontStyle)\n\t\tend\n\tend\n\tif not fontFace then\n\t\tfontFace = Font.new(font, fontWeight, fontStyle)\n\tend\n\tself:modifyTheme({\"IconLabel\", \"FontFace\", fontFace, iconState})\n\treturn self\nend\n\nfunction Icon:bindToggleItem(guiObjectOrLayerCollector)\n\tif not guiObjectOrLayerCollector:IsA(\"GuiObject\") and not guiObjectOrLayerCollector:IsA(\"LayerCollector\") then\n\t\terror(\"Toggle item must be a GuiObject or LayerCollector!\")\n\tend\n\tself.toggleItems[guiObjectOrLayerCollector] = true\n\tself:_updateSelectionInstances()\n\treturn self\nend\n\nfunction Icon:unbindToggleItem(guiObjectOrLayerCollector)\n\tself.toggleItems[guiObjectOrLayerCollector] = nil\n\tself:_updateSelectionInstances()\n\treturn self\nend\n\nfunction Icon:_updateSelectionInstances()\n\t-- This is to assist with controller navigation and selection\n\t-- It converts the value true to an array\n\tfor guiObjectOrLayerCollector, _ in pairs(self.toggleItems) do\n\t\tlocal buttonInstancesArray = {}\n\t\tfor _, instance in pairs(guiObjectOrLayerCollector:GetDescendants()) do\n\t\t\tif (instance:IsA(\"TextButton\") or instance:IsA(\"ImageButton\")) and instance.Active then\n\t\t\t\ttable.insert(buttonInstancesArray, instance)\n\t\t\tend\n\t\tend\n\t\tself.toggleItems[guiObjectOrLayerCollector] = buttonInstancesArray\n\tend\nend\n\nfunction Icon:_setToggleItemsVisible(bool, fromSource, sourceIcon)\n\tfor toggleItem, _ in pairs(self.toggleItems) do\n\t\tif not sourceIcon or sourceIcon == self or sourceIcon.toggleItems[toggleItem] == nil then\n\t\t\tlocal property = \"Visible\"\n\t\t\tif toggleItem:IsA(\"LayerCollector\") then\n\t\t\t\tproperty = \"Enabled\"\n\t\t\tend\n\t\t\ttoggleItem[property] = bool\n\t\tend\n\tend\nend\n\nfunction Icon:bindEvent(iconEventName, eventFunction)\n\tlocal event = self[iconEventName]\n\tassert(event and typeof(event) == \"table\" and event.Connect, \"argument[1] must be a valid topbarplus icon event name!\")\n\tassert(typeof(eventFunction) == \"function\", \"argument[2] must be a function!\")\n\tself.bindedEvents[iconEventName] = event:Connect(function(...)\n\t\teventFunction(self, ...)\n\tend)\n\treturn self\nend\n\nfunction Icon:unbindEvent(iconEventName)\n\tlocal eventConnection = self.bindedEvents[iconEventName]\n\tif eventConnection then\n\t\teventConnection:Disconnect()\n\t\tself.bindedEvents[iconEventName] = nil\n\tend\n\treturn self\nend\n\nfunction Icon:bindToggleKey(keyCodeEnum)\n\tassert(typeof(keyCodeEnum) == \"EnumItem\", \"argument[1] must be a KeyCode EnumItem!\")\n\tself.bindedToggleKeys[keyCodeEnum] = true\n\tself.toggleKeyAdded:Fire(keyCodeEnum)\n\tself:setCaption(\"_hotkey_\")\n\treturn self\nend\n\nfunction Icon:unbindToggleKey(keyCodeEnum)\n\tassert(typeof(keyCodeEnum) == \"EnumItem\", \"argument[1] must be a KeyCode EnumItem!\")\n\tself.bindedToggleKeys[keyCodeEnum] = nil\n\treturn self\nend\n\nfunction Icon:call(callback, ...)\n\tlocal packedArgs = table.pack(...)\n\ttask.spawn(function()\n\t\tcallback(self, table.unpack(packedArgs))\n\tend)\n\treturn self\nend\n\nfunction Icon:addToJanitor(callback)\n\tself.janitor:add(callback)\n\treturn self\nend\n\nfunction Icon:lock()\n\t-- This disables all user inputs related to the icon (such as clicking buttons, pressing keys, etc)\n\tlocal clickRegion = self:getInstance(\"ClickRegion\")\n\tclickRegion.Visible = false\n\tself.locked = true\n\treturn self\nend\n\nfunction Icon:unlock()\n\tlocal clickRegion = self:getInstance(\"ClickRegion\")\n\tclickRegion.Visible = true\n\tself.locked = false\n\treturn self\nend\n\nfunction Icon:debounce(seconds)\n\tself:lock()\n\ttask.wait(seconds)\n\tself:unlock()\n\treturn self\nend\n\nfunction Icon:autoDeselect(bool)\n\t-- When set to true the icon will deselect itself automatically whenever\n\t-- another icon is selected\n\tif bool == nil then\n\t\tbool = true\n\tend\n\tself.deselectWhenOtherIconSelected = bool\n\treturn self\nend\n\nfunction Icon:oneClick(bool)\n\t-- When set to true the icon will automatically deselect when selected, this creates\n\t-- the effect of a single click button\n\tlocal singleClickJanitor = self.singleClickJanitor\n\tsingleClickJanitor:clean()\n\tif bool or bool == nil then\n\t\tsingleClickJanitor:add(self.selected:Connect(function()\n\t\t\tself:deselect(\"OneClick\", self)\n\t\tend))\n\tend\n\tself.oneClickEnabled = true\n\treturn self\nend\n\nfunction Icon:setCaption(text)\n\tif text == \"_hotkey_\" and (self.captionText) then\n\t\treturn self\n\tend\n\tlocal captionJanitor = self.captionJanitor\n\tself.captionJanitor:clean()\n\tif not text or text == \"\" then\n\t\tself.caption = nil\n\t\tself.captionText = nil\n\t\treturn self\n\tend\n\tlocal caption = captionJanitor:add(require(elements.Caption)(self))\n\tcaption:SetAttribute(\"CaptionText\", text)\n\tself.caption = caption\n\tself.captionText = text\n\treturn self\nend\n\nfunction Icon:setCaptionHint(keyCodeEnum)\n\tassert(typeof(keyCodeEnum) == \"EnumItem\", \"argument[1] must be a KeyCode EnumItem!\")\n\tself.fakeToggleKey = keyCodeEnum\n\tself.fakeToggleKeyChanged:Fire(keyCodeEnum)\n\tself:setCaption(\"_hotkey_\")\n\treturn self\nend\n\nfunction Icon:leave()\n\tlocal joinJanitor = self.joinJanitor\n\tjoinJanitor:clean()\n\treturn self\nend\n\nfunction Icon:joinMenu(parentIcon)\n\tUtility.joinFeature(self, parentIcon, parentIcon.menuIcons, parentIcon:getInstance(\"Menu\"))\n\tparentIcon.menuChildAdded:Fire(self)\n\treturn self\nend\n\nfunction Icon:setMenu(arrayOfIcons)\n\tself.menuSet:Fire(arrayOfIcons)\n\treturn self\nend\n\nfunction Icon:setFrozenMenu(arrayOfIcons)\n\tself:freezeMenu(arrayOfIcons)\n\tself:setMenu(arrayOfIcons)\nend\n\nfunction Icon:freezeMenu()\n\t-- A frozen menu is a menu which is permanently locked in the\n\t-- the selected state (with its toggle hidden)\n\tself:select(\"FrozenMenu\", self)\n\tself:bindEvent(\"deselected\", function(icon)\n\t\ticon:select(\"FrozenMenu\", self)\n\tend)\n\tself:modifyTheme({\"IconSpot\", \"Visible\", false})\nend\n\nfunction Icon:joinDropdown(parentIcon)\n\tparentIcon:getDropdown()\n\tUtility.joinFeature(self, parentIcon, parentIcon.dropdownIcons, parentIcon:getInstance(\"DropdownScroller\"))\n\tparentIcon.dropdownChildAdded:Fire(self)\n\treturn self\nend\n\nfunction Icon:getDropdown()\n\tlocal dropdown = self.dropdown\n\tif not dropdown then\n\t\tdropdown = require(elements.Dropdown)(self)\n\t\tself.dropdown = dropdown\n\t\tself:clipOutside(dropdown)\n\tend\n\treturn dropdown\nend\n\nfunction Icon:setDropdown(arrayOfIcons)\n\tself:getDropdown()\n\tself.dropdownSet:Fire(arrayOfIcons)\n\treturn self\nend\n\nfunction Icon:clipOutside(instance)\n\t-- This is essential for items such as notices and dropdowns which will exceed the bounds of the widget. This is an issue\n\t-- because the widget must have ClipsDescendents enabled to hide items for instance when the menu is closing or opening.\n\t-- This creates an invisible frame which matches the size and position of the instance, then the instance is parented outside of\n\t-- the widget and tracks the clone to match its size and position. In order for themes, etc to work the applying system checks\n\t-- to see if an instance is a clone, then if it is, it applies it to the original instance instead of the clone.\n\tlocal instanceClone = Utility.clipOutside(self, instance)\n\tself:refreshAppearance(instance)\n\treturn self, instanceClone\nend\n\nfunction Icon:setIndicator(keyCode)\n\t-- An indicator is a direction button prompt with an image of the given keycode. This is useful for instance\n\t-- with controllers to show the user what button to press to highlight the topbar. You don't need\n\t-- to set an indicator for controllers as this is handled internally within the Gamepad module\n\tlocal indicator = self.indicator\n\tif not indicator then\n\t\tindicator = self.janitor:add(require(elements.Indicator)(self, Icon))\n\t\tself.indicator = indicator\n\tend\n\tself.indicatorSet:Fire(keyCode)\nend\n\n\n\n-- DESTROY/CLEANUP\nfunction Icon:destroy()\n\tif self.isDestroyed then\n\t\treturn\n\tend\n\tself:clearNotices()\n\tif self.parentIconUID then\n\t\tself:leave()\n\tend\n\tself.isDestroyed = true\n\tself.janitor:clean()\n\tIcon.iconRemoved:Fire(self)\nend\nIcon.Destroy = Icon.destroy\n\n\n\nreturn Icon",
                        "Children": [
                            {
                                "Children": [],
                                "ClassName": "PackageLink"
                            },
                            {
                                "Name": "Elements",
                                "Archivable": true,
                                "Children": [
                                    {
                                        "Name": "Caption",
                                        "ClassName": "ModuleScript",
                                        "Source": "return function(icon)\n\n\t-- Credit to lolmansReturn and Canary Software for\n\t-- retrieving these values\n\tlocal clickRegion = icon:getInstance(\"ClickRegion\")\n\tlocal caption = Instance.new(\"CanvasGroup\")\n\tcaption.Name = \"Caption\"\n\tcaption.AnchorPoint = Vector2.new(0.5, 0)\n\tcaption.BackgroundTransparency = 1\n\tcaption.BorderSizePixel = 0\n\tcaption.GroupTransparency = 1\n\tcaption.Position = UDim2.fromOffset(0, 0)\n\tcaption.Visible = true\n\tcaption.ZIndex = 30\n\tcaption.Parent = clickRegion\n\n\tlocal box = Instance.new(\"Frame\")\n\tbox.Name = \"Box\"\n\tbox.AutomaticSize = Enum.AutomaticSize.XY\n\tbox.BackgroundColor3 = Color3.fromRGB(101, 102, 104)\n\tbox.Position = UDim2.fromOffset(4, 7)\n\tbox.ZIndex = 12\n\tbox.Parent = caption\n\n\tlocal header = Instance.new(\"TextLabel\")\n\theader.Name = \"Header\"\n\theader.FontFace = Font.new(\n\t\t\"rbxasset://fonts/families/GothamSSm.json\",\n\t\tEnum.FontWeight.Medium,\n\t\tEnum.FontStyle.Normal\n\t)\n\theader.Text = \"Caption\"\n\theader.TextColor3 = Color3.fromRGB(255, 255, 255)\n\theader.TextSize = 14\n\theader.TextTruncate = Enum.TextTruncate.None\n\theader.TextWrapped = false\n\theader.TextXAlignment = Enum.TextXAlignment.Left\n\theader.AutomaticSize = Enum.AutomaticSize.X\n\theader.BackgroundTransparency = 1\n\theader.LayoutOrder = 1\n\theader.Size = UDim2.fromOffset(0, 16)\n\theader.ZIndex = 18\n\theader.Parent = box\n\n\tlocal layout = Instance.new(\"UIListLayout\")\n\tlayout.Name = \"Layout\"\n\tlayout.Padding = UDim.new(0, 8)\n\tlayout.SortOrder = Enum.SortOrder.LayoutOrder\n\tlayout.Parent = box\n\n\tlocal UICorner = Instance.new(\"UICorner\")\n\tUICorner.Name = \"CaptionCorner\"\n\tUICorner.Parent = box\n\n\tlocal padding = Instance.new(\"UIPadding\")\n\tpadding.Name = \"Padding\"\n\tpadding.PaddingBottom = UDim.new(0, 12)\n\tpadding.PaddingLeft = UDim.new(0, 12)\n\tpadding.PaddingRight = UDim.new(0, 12)\n\tpadding.PaddingTop = UDim.new(0, 12)\n\tpadding.Parent = box\n\n\tlocal hotkeys = Instance.new(\"Frame\")\n\thotkeys.Name = \"Hotkeys\"\n\thotkeys.AutomaticSize = Enum.AutomaticSize.Y\n\thotkeys.BackgroundTransparency = 1\n\thotkeys.LayoutOrder = 3\n\thotkeys.Size = UDim2.fromScale(1, 0)\n\thotkeys.Visible = false\n\thotkeys.Parent = box\n\n\tlocal layout1 = Instance.new(\"UIListLayout\")\n\tlayout1.Name = \"Layout1\"\n\tlayout1.Padding = UDim.new(0, 6)\n\tlayout1.FillDirection = Enum.FillDirection.Vertical\n\tlayout1.HorizontalAlignment = Enum.HorizontalAlignment.Center\n\tlayout1.HorizontalFlex = Enum.UIFlexAlignment.None\n\tlayout1.ItemLineAlignment = Enum.ItemLineAlignment.Automatic\n\tlayout1.VerticalFlex = Enum.UIFlexAlignment.None\n\tlayout1.SortOrder = Enum.SortOrder.LayoutOrder\n\tlayout1.Parent = hotkeys\n\n\tlocal keyTag1 = Instance.new(\"ImageLabel\")\n\tkeyTag1.Name = \"Key1\"\n\tkeyTag1.Image = \"rbxasset://textures/ui/Controls/key_single.png\"\n\tkeyTag1.ImageTransparency = 0.7\n\tkeyTag1.ScaleType = Enum.ScaleType.Slice\n\tkeyTag1.SliceCenter = Rect.new(5, 5, 23, 24)\n\tkeyTag1.AutomaticSize = Enum.AutomaticSize.X\n\tkeyTag1.BackgroundTransparency = 1\n\tkeyTag1.LayoutOrder = 1\n\tkeyTag1.Size = UDim2.fromOffset(0, 30)\n\tkeyTag1.ZIndex = 15\n\tkeyTag1.Parent = hotkeys\n\n\tlocal inset = Instance.new(\"UIPadding\")\n\tinset.Name = \"Inset\"\n\tinset.PaddingLeft = UDim.new(0, 8)\n\tinset.PaddingRight = UDim.new(0, 8)\n\tinset.Parent = keyTag1\n\n\tlocal labelContent = Instance.new(\"TextLabel\")\n\tlabelContent.AutoLocalize = false\n\tlabelContent.Name = \"LabelContent\"\n\tlabelContent.FontFace = Font.new(\n\t\t\"rbxasset://fonts/families/GothamSSm.json\",\n\t\tEnum.FontWeight.Medium,\n\t\tEnum.FontStyle.Normal\n\t)\n\tlabelContent.Text = \"\"\n\tlabelContent.TextColor3 = Color3.fromRGB(189, 190, 190)\n\tlabelContent.TextSize = 14\n\tlabelContent.AutomaticSize = Enum.AutomaticSize.X\n\tlabelContent.BackgroundTransparency = 1\n\tlabelContent.Position = UDim2.fromOffset(0, -1)\n\tlabelContent.Size = UDim2.fromScale(1, 1)\n\tlabelContent.ZIndex = 16\n\tlabelContent.Parent = keyTag1\n\t\n\tlocal caret = Instance.new(\"ImageLabel\")\n\tcaret.Name = \"Caret\"\n\tcaret.Image = \"rbxasset://LuaPackages/Packages/_Index/UIBlox/UIBlox/AppImageAtlas/img_set_1x_1.png\"\n\tcaret.ImageColor3 = Color3.fromRGB(101, 102, 104)\n\tcaret.ImageRectOffset = Vector2.new(260, 440)\n\tcaret.ImageRectSize = Vector2.new(16, 8)\n\tcaret.AnchorPoint = Vector2.new(0, 0.5)\n\tcaret.BackgroundTransparency = 1\n\tcaret.Position = UDim2.new(0, 0, 0, 4)\n\tcaret.Rotation = 180\n\tcaret.Size = UDim2.fromOffset(16, 8)\n\tcaret.ZIndex = 12\n\tcaret.Parent = caption\n\n\tlocal dropShadow = Instance.new(\"ImageLabel\")\n\tdropShadow.Name = \"DropShadow\"\n\tdropShadow.Image = \"rbxasset://LuaPackages/Packages/_Index/UIBlox/UIBlox/AppImageAtlas/img_set_1x_1.png\"\n\tdropShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)\n\tdropShadow.ImageRectOffset = Vector2.new(217, 486)\n\tdropShadow.ImageRectSize = Vector2.new(25, 25)\n\tdropShadow.ImageTransparency = 0.45\n\tdropShadow.ScaleType = Enum.ScaleType.Slice\n\tdropShadow.SliceCenter = Rect.new(12, 12, 13, 13)\n\tdropShadow.BackgroundTransparency = 1\n\tdropShadow.Position = UDim2.fromOffset(0, 5)\n\tdropShadow.Size = UDim2.new(1, 0, 0, 48)\n\tdropShadow.Parent = caption\n\tbox:GetPropertyChangedSignal(\"AbsoluteSize\"):Connect(function()\n\t\tdropShadow.Size = UDim2.new(1, 0, 0, box.AbsoluteSize.Y + 8)\n\tend)\n\t\n\t-- It's important we match the sizes as this is not\n\t-- handles within clipOutside (as it assumes the sizes\n\t-- are already the same)\n\tlocal captionJanitor = icon.captionJanitor\n\tlocal _, captionClone = icon:clipOutside(caption)\n\tcaptionClone.AutomaticSize = Enum.AutomaticSize.None\n\tlocal function matchSize()\n\t\tlocal absolute = caption.AbsoluteSize\n\t\tcaptionClone.Size = UDim2.fromOffset(absolute.X, absolute.Y)\n\tend\n\tcaptionJanitor:add(caption:GetPropertyChangedSignal(\"AbsoluteSize\"):Connect(matchSize))\n\tmatchSize()\n\t\n\t\n\t\n\tlocal isCompletelyEnabled = false\n\t-- This handles the appearing/disappearing/positioning of the caption\n\tlocal captionHeader = caption.Box.Header\n\tlocal UserInputService = game:GetService(\"UserInputService\")\n\tlocal function updateHotkey(keyCodeEnum)\n\t\tlocal hasKeyboard = UserInputService.KeyboardEnabled\n\t\tlocal text = caption:GetAttribute(\"CaptionText\") or \"\"\n\t\tlocal hideHeader = text == \"_hotkey_\"\n\t\tif not hasKeyboard and hideHeader then\n\t\t\ticon:setCaption()\n\t\t\treturn\n\t\tend\n\t\tcaptionHeader.Text = text\n\t\tcaptionHeader.Visible = not hideHeader\n\t\tif keyCodeEnum then\n\t\t\tlabelContent.Text = keyCodeEnum.Name\n\t\t\thotkeys.Visible = true\n\t\tend\n\t\tif not hasKeyboard then\n\t\t\thotkeys.Visible = false\n\t\tend\n\tend\n\tcaption:GetAttributeChangedSignal(\"CaptionText\"):Connect(updateHotkey)\n\n\tlocal EASING_STYLE = Enum.EasingStyle.Quad\n\tlocal TWEEN_SPEED = 0.2\n\tlocal TWEEN_INFO_IN = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.In)\n\tlocal TWEEN_INFO_OUT = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.Out)\n\tlocal TweenService = game:GetService(\"TweenService\")\n\tlocal RunService = game:GetService(\"RunService\")\n\tlocal function getCaptionPosition(customEnabled)\n\t\tlocal enabled = if customEnabled ~= nil then customEnabled else isCompletelyEnabled\n\t\tlocal yOut = 2\n\t\tlocal yIn = yOut + 8\n\t\tlocal yOffset = if enabled then yIn else yOut\n\t\treturn UDim2.new(0.5, 0, 1, yOffset)\n\tend\n\tlocal function updatePosition(forcedEnabled)\n\t\t\n\t\t-- Ignore changes if not enabled to reduce redundant calls\n\t\tif not isCompletelyEnabled then\n\t\t\treturn\n\t\tend\n\t\t\n\t\t-- Currently the one thing which isn't accounted for are the bounds of the screen\n\t\t-- This would be an issue if someone sets a long caption text for the left or\n\t\t-- right most icon\n\t\tlocal enabled = if forcedEnabled ~= nil then forcedEnabled else isCompletelyEnabled\n\t\tlocal startPosition = getCaptionPosition(not enabled)\n\t\tlocal endPosition = getCaptionPosition(enabled)\n\t\t\n\t\t-- It's essential we reset the carets position to prevent the x sizing bounds\n\t\t-- of the caption from infinitely scaling up\n\t\tif enabled then\n\t\t\tlocal caretY = caret.Position.Y.Offset\n\t\t\tcaret.Position = UDim2.fromOffset(0, caretY)\n\t\t\tcaption.AutomaticSize = Enum.AutomaticSize.XY\n\t\t\tcaption.Size = UDim2.fromOffset(32, 53)\n\t\telse\n\t\t\tlocal absolute = caption.AbsoluteSize\n\t\t\tcaption.AutomaticSize = Enum.AutomaticSize.Y\n\t\t\tcaption.Size = UDim2.fromOffset(absolute.X, absolute.Y)\n\t\tend\n\t\t\n\t\t-- We initially default to the opposite state\n\t\tlocal previousCaretX\n\t\tlocal function updateCaret()\n\t\t\tlocal caretX = clickRegion.AbsolutePosition.X - caption.AbsolutePosition.X + clickRegion.AbsoluteSize.X/2 - caret.AbsoluteSize.X/2\n\t\t\tlocal caretY = caret.Position.Y.Offset\n\t\t\tlocal newCaretPosition = UDim2.fromOffset(caretX, caretY)\n\t\t\tif previousCaretX ~= caretX then\n\t\t\t\t-- Again, it's essential we reset the caret if\n\t\t\t\t-- a difference in X position is detected otherwise\n\t\t\t\t-- a slight quirk with AutomaticCanvas can cause\n\t\t\t\t-- the caption to infinitely scale\n\t\t\t\tpreviousCaretX = caretX\n\t\t\t\tcaret.Position = UDim2.fromOffset(0, caretY)\n\t\t\t\ttask.wait()\n\t\t\tend\n\t\t\tcaret.Position = newCaretPosition\n\t\tend\n\t\tcaptionClone.Position = startPosition\n\t\tupdateCaret()\n\t\t\n\t\t-- Now we tween into the new state\n\t\tlocal tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT\n\t\tlocal tween = TweenService:Create(captionClone, tweenInfo, {Position = endPosition})\n\t\tlocal updateCaretConnection = RunService.Heartbeat:Connect(updateCaret)\n\t\ttween:Play()\n\t\ttween.Completed:Once(function()\n\t\t\tupdateCaretConnection:Disconnect()\n\t\tend)\n\t\t\n\tend\n\tcaptionJanitor:add(clickRegion:GetPropertyChangedSignal(\"AbsoluteSize\"):Connect(function()\n\t\tupdatePosition()\n\tend))\n\tupdatePosition(false)\n\t\n\tcaptionJanitor:add(icon.toggleKeyAdded:Connect(updateHotkey))\n\tfor keyCodeEnum, _ in pairs(icon.bindedToggleKeys) do\n\t\tupdateHotkey(keyCodeEnum)\n\t\tbreak\n\tend\n\tcaptionJanitor:add(icon.fakeToggleKeyChanged:Connect(updateHotkey))\n\tlocal fakeToggleKey = icon.fakeToggleKey\n\tif fakeToggleKey then\n\t\tupdateHotkey(fakeToggleKey)\n\tend\n\n\tlocal function setCaptionEnabled(enabled)\n\t\tif isCompletelyEnabled == enabled then\n\t\t\treturn\n\t\tend\n\t\tlocal joinedFrame = icon.joinedFrame\n\t\tif joinedFrame and string.match(joinedFrame.Name, \"Dropdown\") then\n\t\t\tenabled = false\n\t\tend\n\t\tisCompletelyEnabled = enabled\n\t\tlocal newTransparency = (enabled and 0) or 1\n\t\tlocal tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT\n\t\tlocal tweenTransparency = TweenService:Create(caption, tweenInfo, {\n\t\t\tGroupTransparency = newTransparency\n\t\t})\n\t\ttweenTransparency:Play()\n\t\tupdatePosition()\n\t\tupdateHotkey()\n\tend\n\t\n\tlocal WAIT_DURATION = 0.5\n\tlocal RECOVER_PERIOD = 0.3\n\tlocal Icon = require(icon.iconModule)\n\tcaptionJanitor:add(icon.stateChanged:Connect(function(stateName)\n\t\tif stateName == \"Viewing\" then\n\t\t\tlocal lastClock = Icon.captionLastClosedClock\n\t\t\tlocal clockDifference = (lastClock and os.clock() - lastClock) or 999\n\t\t\tlocal waitDuration = (clockDifference < RECOVER_PERIOD and 0) or WAIT_DURATION\n\t\t\ttask.delay(waitDuration, function()\n\t\t\t\tif icon.activeState == \"Viewing\" then\n\t\t\t\t\tsetCaptionEnabled(true)\n\t\t\t\tend\n\t\t\tend)\n\t\telse\n\t\t\tIcon.captionLastClosedClock = os.clock()\n\t\t\tsetCaptionEnabled(false)\n\t\tend\n\tend))\n\t\n\treturn caption\nend",
                                        "Children": [],
                                        "Archivable": true
                                    },
                                    {
                                        "Name": "Container",
                                        "ClassName": "ModuleScript",
                                        "Source": "return function(Icon)\n\t\n\tlocal GuiService = game:GetService(\"GuiService\")\n\tlocal isOldTopbar = Icon.isOldTopbar\n\tlocal container = {}\n\tlocal guiInset = GuiService:GetGuiInset()\n\tlocal isConsoleScreen = GuiService:IsTenFootInterface()\n\tlocal startInset = if isOldTopbar then 12 else guiInset.Y - (44 + 2)\n\tif isConsoleScreen then\n\t\tstartInset = 10\n\tend\n\tlocal screenGui = Instance.new(\"ScreenGui\")\n\tscreenGui:SetAttribute(\"StartInset\", startInset)\n\tscreenGui.Name = \"TopbarStandard\"\n\tscreenGui.Enabled = true\n\tscreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling\n\tscreenGui.IgnoreGuiInset = true\n\tscreenGui.ResetOnSpawn = false\n\tscreenGui.ScreenInsets = Enum.ScreenInsets.TopbarSafeInsets\n\tcontainer[screenGui.Name] = screenGui\n\tscreenGui.DisplayOrder = Icon.baseDisplayOrder\n\tIcon.baseDisplayOrderChanged:Connect(function()\n\t\tscreenGui.DisplayOrder = Icon.baseDisplayOrder\n\tend)\n\n\tlocal holders = Instance.new(\"Frame\")\n\tlocal yDownOffset = if isOldTopbar then 2 else 0\n\tlocal ySizeOffset = -2\n\tif isConsoleScreen then\n\t\tyDownOffset += 13\n\t\tySizeOffset = 50\n\tend\n\tholders.Name = \"Holders\"\n\tholders.BackgroundTransparency = 1\n\tholders.Position = UDim2.new(0, 0, 0, yDownOffset)\n\tholders.Size = UDim2.new(1, 0, 1, ySizeOffset)\n\tholders.Visible = true\n\tholders.ZIndex = 1\n\tholders.Parent = screenGui\n\t\n\tlocal screenGuiCenter = screenGui:Clone()\n\tlocal holdersCenter = screenGuiCenter.Holders\n\tlocal GuiService = game:GetService(\"GuiService\")\n\tlocal function updateCenteredHoldersHeight()\n\t\tholdersCenter.Size = UDim2.new(1, 0, 0, GuiService.TopbarInset.Height+ySizeOffset)\n\tend\n\tscreenGuiCenter.Name = \"TopbarCentered\"\n\tscreenGuiCenter.ScreenInsets = Enum.ScreenInsets.None\n\tIcon.baseDisplayOrderChanged:Connect(function()\n\t\tscreenGuiCenter.DisplayOrder = Icon.baseDisplayOrder\n\tend)\n\tcontainer[screenGuiCenter.Name] = screenGuiCenter\n\tGuiService:GetPropertyChangedSignal(\"TopbarInset\"):Connect(updateCenteredHoldersHeight)\n\tupdateCenteredHoldersHeight()\n\t\n\tlocal screenGuiClipped = screenGui:Clone()\n\tscreenGuiClipped.Name = screenGuiClipped.Name..\"Clipped\"\n\tscreenGuiClipped.DisplayOrder += 1\n\tIcon.baseDisplayOrderChanged:Connect(function()\n\t\tscreenGuiClipped.DisplayOrder = Icon.baseDisplayOrder + 1\n\tend)\n\tcontainer[screenGuiClipped.Name] = screenGuiClipped\n\t\n\tlocal screenGuiCenterClipped = screenGuiCenter:Clone()\n\tscreenGuiCenterClipped.Name = screenGuiCenterClipped.Name..\"Clipped\"\n\tscreenGuiCenterClipped.DisplayOrder += 1\n\tIcon.baseDisplayOrderChanged:Connect(function()\n\t\tscreenGuiCenterClipped.DisplayOrder = Icon.baseDisplayOrder + 1\n\tend)\n\tcontainer[screenGuiCenterClipped.Name] = screenGuiCenterClipped\n\t\n\tif isOldTopbar then\n\t\ttask.defer(function()\n\t\t\tlocal function decideToHideTopbar()\n\t\t\t\tif GuiService.MenuIsOpen then\n\t\t\t\t\tIcon.setTopbarEnabled(false, true)\n\t\t\t\telse\n\t\t\t\t\tIcon.setTopbarEnabled()\n\t\t\t\tend\n\t\t\tend\n\t\t\tGuiService:GetPropertyChangedSignal(\"MenuIsOpen\"):Connect(decideToHideTopbar)\n\t\t\tdecideToHideTopbar()\n\t\tend)\n\tend\n\t\n\tlocal holderReduction = -24\n\tlocal left = Instance.new(\"ScrollingFrame\")\n\tleft:SetAttribute(\"IsAHolder\", true)\n\tleft.Name = \"Left\"\n\tleft.Position = UDim2.fromOffset(startInset, 0)\n\tleft.Size = UDim2.new(1, holderReduction, 1, 0)\n\tleft.BackgroundTransparency = 1\n\tleft.Visible = true\n\tleft.ZIndex = 1\n\tleft.Active = false\n\tleft.ClipsDescendants = true\n\tleft.HorizontalScrollBarInset = Enum.ScrollBarInset.None\n\tleft.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug\n\tleft.AutomaticCanvasSize = Enum.AutomaticSize.X\n\tleft.ScrollingDirection = Enum.ScrollingDirection.X\n\tleft.ScrollBarThickness = 0\n\tleft.BorderSizePixel = 0\n\tleft.Selectable = false\n\tleft.ScrollingEnabled = false--true\n\tleft.ElasticBehavior = Enum.ElasticBehavior.Never\n\tleft.Parent = holders\n\t\n\tlocal UIListLayout = Instance.new(\"UIListLayout\")\n\tUIListLayout.Padding = UDim.new(0, startInset)\n\tUIListLayout.FillDirection = Enum.FillDirection.Horizontal\n\tUIListLayout.SortOrder = Enum.SortOrder.LayoutOrder\n\tUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom\n\tUIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left\n\tUIListLayout.Parent = left\n\t\n\tlocal center = left:Clone()\n\tcenter.ScrollingEnabled = false\n\tcenter.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center\n\tcenter.Name = \"Center\"\n\tcenter.Parent = holdersCenter\n\t\n\tlocal right = left:Clone()\n\tright.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right\n\tright.Name = \"Right\"\n\tright.AnchorPoint = Vector2.new(1, 0)\n\tright.Position = UDim2.new(1, -12, 0, 0)\n\tright.Parent = holders\n\n\treturn container\nend",
                                        "Children": [],
                                        "Archivable": true
                                    },
                                    {
                                        "Name": "Dropdown",
                                        "ClassName": "ModuleScript",
                                        "Source": "return function(icon)\n\t\n\tlocal dropdown = Instance.new(\"Frame\")\n\tdropdown.Name = \"Dropdown\"\n\tdropdown.AutomaticSize = Enum.AutomaticSize.XY\n\tdropdown.BackgroundTransparency = 1\n\tdropdown.BorderSizePixel = 0\n\tdropdown.AnchorPoint = Vector2.new(0.5, 0)\n\tdropdown.Position = UDim2.new(0.5, 0, 1, 10)\n\tdropdown.ZIndex = -2\n\tdropdown.ClipsDescendants = true\n\tdropdown.Parent = icon.widget\n\n\tlocal UICorner = Instance.new(\"UICorner\")\n\tUICorner.Name = \"DropdownCorner\"\n\tUICorner.CornerRadius = UDim.new(0, 10)\n\tUICorner.Parent = dropdown\n\n\tlocal dropdownScroller = Instance.new(\"ScrollingFrame\")\n\tdropdownScroller.Name = \"DropdownScroller\"\n\tdropdownScroller.AutomaticSize = Enum.AutomaticSize.X\n\tdropdownScroller.BackgroundTransparency = 1\n\tdropdownScroller.BorderSizePixel = 0\n\tdropdownScroller.AnchorPoint = Vector2.new(0, 0)\n\tdropdownScroller.Position = UDim2.new(0, 0, 0, 0)\n\tdropdownScroller.ZIndex = -1\n\tdropdownScroller.ClipsDescendants = true\n\tdropdownScroller.Visible = true\n\tdropdownScroller.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar\n\tdropdownScroller.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right\n\tdropdownScroller.Active = false\n\tdropdownScroller.ScrollingEnabled = true\n\tdropdownScroller.AutomaticCanvasSize = Enum.AutomaticSize.Y\n\tdropdownScroller.ScrollBarThickness = 5\n\tdropdownScroller.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)\n\tdropdownScroller.ScrollBarImageTransparency = 0.8\n\tdropdownScroller.CanvasSize = UDim2.new(0, 0, 0, 0)\n\tdropdownScroller.Selectable = false\n\tdropdownScroller.Active = true\n\tdropdownScroller.Parent = dropdown\n\t\n\tlocal dropdownPadding = Instance.new(\"UIPadding\")\n\tdropdownPadding.Name = \"DropdownPadding\"\n\tdropdownPadding.PaddingTop = UDim.new(0, 8)\n\tdropdownPadding.PaddingBottom = UDim.new(0, 8)\n\tdropdownPadding.Parent = dropdownScroller\n\n\tlocal dropdownList = Instance.new(\"UIListLayout\")\n\tdropdownList.Name = \"DropdownList\"\n\tdropdownList.FillDirection = Enum.FillDirection.Vertical\n\tdropdownList.SortOrder = Enum.SortOrder.LayoutOrder\n\tdropdownList.HorizontalAlignment = Enum.HorizontalAlignment.Center\n\tdropdownList.HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly\n\tdropdownList.Parent = dropdownScroller\n\t\n\tlocal dropdownJanitor = icon.dropdownJanitor\n\tlocal Icon = require(icon.iconModule)\n\ticon.dropdownChildAdded:Connect(function(childIcon)\n\t\t-- Modify appearance of child when joined\n\t\tlocal _, modificationUID = childIcon:modifyTheme({\n\t\t\t{\"Widget\", \"BorderSize\", 0},\n\t\t\t{\"IconCorners\", \"CornerRadius\", UDim.new(0, 4)},\n\t\t\t{\"Widget\", \"MinimumWidth\", 190},\n\t\t\t{\"Widget\", \"MinimumHeight\", 56},\n\t\t\t{\"IconLabel\", \"TextSize\", 19},\n\t\t\t{\"PaddingLeft\", \"Size\", UDim2.fromOffset(25, 0)},\n\t\t\t{\"Notice\", \"Position\", UDim2.new(1, -24, 0, 5)},\n\t\t\t{\"ContentsList\", \"HorizontalAlignment\", Enum.HorizontalAlignment.Left},\n\t\t\t{\"Selection\", \"Size\", UDim2.new(1, -8, 1, -8)},\n\t\t\t{\"Selection\", \"Position\", UDim2.new(0, 4, 0, 4)},\n\t\t})\n\t\ttask.defer(function()\n\t\t\tchildIcon.joinJanitor:add(function()\n\t\t\t\tchildIcon:removeModification(modificationUID)\n\t\t\tend)\n\t\tend)\n\tend)\n\ticon.dropdownSet:Connect(function(arrayOfIcons)\n\t\t-- Destroy any previous icons\n\t\tfor i, otherIconUID in pairs(icon.dropdownIcons) do\n\t\t\tlocal otherIcon = Icon.getIconByUID(otherIconUID)\n\t\t\totherIcon:destroy()\n\t\tend\n\t\t-- Add new icons\n\t\tlocal totalNewIcons = #arrayOfIcons\n\t\tif type(arrayOfIcons) == \"table\" then\n\t\t\tfor i, otherIcon in pairs(arrayOfIcons) do\n\t\t\t\totherIcon:joinDropdown(icon)\n\t\t\tend\n\t\tend\n\tend)\n\n\t-- Update visibiliy of dropdown\n\tlocal Utility = require(script.Parent.Parent.Utility)\n\tlocal function updateVisibility()\n\t\t--icon:modifyTheme({\"Dropdown\", \"Visible\", icon.isSelected})\n\t\tUtility.setVisible(dropdown, icon.isSelected, \"InternalDropdown\")\n\tend\n\tdropdownJanitor:add(icon.toggled:Connect(updateVisibility))\n\tupdateVisibility()\n\t--task.delay(0.2, updateVisibility)\n\t\n\t-- This updates the scrolling frame to only display a scroll\n\t-- length equal to the distance produced by its MaxIcons\n\tlocal updateCount = 0\n\tlocal isUpdating = false\n\tlocal function updateMaxIcons()\n\t\t\n\t\t-- This prevents more than 1 update occurring every frame\n\t\tupdateCount += 1\n\t\tif isUpdating then\n\t\t\treturn\n\t\tend\n\t\tlocal myUpdateCount = updateCount\n\t\tisUpdating = true\n\t\ttask.defer(function()\n\t\t\tisUpdating = false\n\t\t\tif updateCount ~= myUpdateCount then\n\t\t\t\tupdateMaxIcons()\n\t\t\tend\n\t\tend)\n\t\t\t\n\t\tlocal maxIcons = dropdown:GetAttribute(\"MaxIcons\")\n\t\tif not maxIcons then\n\t\t\treturn\n\t\tend\n\t\tlocal orderedInstances = {}\n\t\tfor _, child in pairs(dropdownScroller:GetChildren()) do\n\t\t\tif child:IsA(\"GuiObject\") then\n\t\t\t\ttable.insert(orderedInstances, {child, child.AbsolutePosition.Y})\n\t\t\tend\n\t\tend\n\t\ttable.sort(orderedInstances, function(groupA, groupB)\n\t\t\treturn groupA[2] < groupB[2]\n\t\tend)\n\t\tlocal totalHeight = 0\n\t\tlocal hasSetNextSelection = false\n\t\tfor i = 1, maxIcons do\n\t\t\tlocal group = orderedInstances[i]\n\t\t\tif not group then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tlocal child = group[1]\n\t\t\tlocal height = child.AbsoluteSize.Y\n\t\t\ttotalHeight += height\n\t\t\tlocal iconUID = child:GetAttribute(\"WidgetUID\")\n\t\t\tlocal childIcon = iconUID and Icon.getIconByUID(iconUID)\n\t\t\tif childIcon then\n\t\t\t\tlocal nextSelection = nil\n\t\t\t\tif not hasSetNextSelection then\n\t\t\t\t\thasSetNextSelection = true\n\t\t\t\t\tnextSelection = icon:getInstance(\"ClickRegion\")\n\t\t\t\tend\n\t\t\t\tchildIcon:getInstance(\"ClickRegion\").NextSelectionUp = nextSelection\n\t\t\tend\n\t\tend\n\t\ttotalHeight += dropdownPadding.PaddingTop.Offset\n\t\ttotalHeight += dropdownPadding.PaddingBottom.Offset\n\t\tdropdownScroller.Size = UDim2.fromOffset(0, totalHeight)\n\tend\n\tdropdownJanitor:add(dropdownScroller:GetPropertyChangedSignal(\"AbsoluteCanvasSize\"):Connect(updateMaxIcons))\n\tdropdownJanitor:add(dropdownScroller.ChildAdded:Connect(updateMaxIcons))\n\tdropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateMaxIcons))\n\tdropdownJanitor:add(dropdown:GetAttributeChangedSignal(\"MaxIcons\"):Connect(updateMaxIcons))\n\tdropdownJanitor:add(icon.childThemeModified:Connect(updateMaxIcons))\n\tupdateMaxIcons()\n\t\n\treturn dropdown\nend",
                                        "Children": [],
                                        "Archivable": true
                                    },
                                    {
                                        "Name": "Indicator",
                                        "ClassName": "ModuleScript",
                                        "Source": "return function(icon, Icon)\r\n\r\n\tlocal widget = icon.widget\r\n\tlocal contents = icon:getInstance(\"Contents\")\r\n\tlocal indicator = Instance.new(\"Frame\")\r\n\tindicator.Name = \"Indicator\"\r\n\tindicator.LayoutOrder = 9999999\r\n\tindicator.ZIndex = 6\r\n\tindicator.Size = UDim2.new(0, 42, 0, 42)\r\n\tindicator.BorderColor3 = Color3.fromRGB(0, 0, 0)\r\n\tindicator.BackgroundTransparency = 1\r\n\tindicator.Position = UDim2.new(1, 0, 0.5, 0)\r\n\tindicator.BorderSizePixel = 0\r\n\tindicator.BackgroundColor3 = Color3.fromRGB(0, 0, 0)\r\n\tindicator.Parent = contents\r\n\r\n\tlocal indicatorButton = Instance.new(\"Frame\")\r\n\tindicatorButton.Name = \"IndicatorButton\"\r\n\tindicatorButton.BorderColor3 = Color3.fromRGB(0, 0, 0)\r\n\tindicatorButton.AnchorPoint = Vector2.new(0.5, 0.5)\r\n\tindicatorButton.BorderSizePixel = 0\r\n\tindicatorButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)\r\n\tindicatorButton.Parent = indicator\r\n\t\r\n\tlocal GuiService = game:GetService(\"GuiService\")\r\n\tlocal GamepadService = game:GetService(\"GamepadService\")\r\n\tlocal ourClickRegion = icon:getInstance(\"ClickRegion\")\r\n\tlocal function selectionChanged()\r\n\t\tlocal selectedClickRegion = GuiService.SelectedObject\r\n\t\tif selectedClickRegion == ourClickRegion then\r\n\t\t\tindicatorButton.BackgroundTransparency = 1\r\n\t\t\tindicatorButton.Position = UDim2.new(0.5, -2, 0.5, 0)\r\n\t\t\tindicatorButton.Size = UDim2.fromScale(1.2, 1.2)\r\n\t\telse\r\n\t\t\tindicatorButton.BackgroundTransparency = 0.75\r\n\t\t\tindicatorButton.Position = UDim2.new(0.5, 2, 0.5, 0)\r\n\t\t\tindicatorButton.Size = UDim2.fromScale(1, 1)\r\n\t\tend\r\n\tend\r\n\ticon.janitor:add(GuiService:GetPropertyChangedSignal(\"SelectedObject\"):Connect(selectionChanged))\r\n\tselectionChanged()\r\n\r\n\tlocal imageLabel = Instance.new(\"ImageLabel\")\r\n\timageLabel.LayoutOrder = 2\r\n\timageLabel.ZIndex = 15\r\n\timageLabel.AnchorPoint = Vector2.new(0.5, 0.5)\r\n\timageLabel.Size = UDim2.new(0.5, 0, 0.5, 0)\r\n\timageLabel.BackgroundTransparency = 1\r\n\timageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)\r\n\timageLabel.Image = \"rbxasset://textures/ui/Controls/XboxController/DPadUp@2x.png\"\r\n\timageLabel.Parent = indicatorButton\r\n\r\n\tlocal UICorner = Instance.new(\"UICorner\")\r\n\tUICorner.CornerRadius = UDim.new(1, 0)\r\n\tUICorner.Parent = indicatorButton\r\n\r\n\tlocal UserInputService = game:GetService(\"UserInputService\")\r\n\tlocal function setIndicatorVisible(visibility)\r\n\t\tif visibility == nil then\r\n\t\t\tvisibility = indicator.Visible\r\n\t\tend\r\n\t\tif GamepadService.GamepadCursorEnabled then\r\n\t\t\tvisibility = false\r\n\t\tend\r\n\t\tif visibility then\r\n\t\t\ticon:modifyTheme({\"PaddingRight\", \"Size\", UDim2.new(0, 0, 1, 0)}, \"IndicatorPadding\")\r\n\t\telseif indicator.Visible then\r\n\t\t\ticon:removeModification(\"IndicatorPadding\")\r\n\t\tend\r\n\t\ticon:modifyTheme({\"Indicator\", \"Visible\", visibility})\r\n\t\ticon.updateSize:Fire()\r\n\tend\r\n\ticon.janitor:add(GamepadService:GetPropertyChangedSignal(\"GamepadCursorEnabled\"):Connect(setIndicatorVisible))\r\n\ticon.indicatorSet:Connect(function(keyCode)\r\n\t\tlocal visibility = false\r\n\t\tif keyCode then\r\n\t\t\timageLabel.Image = UserInputService:GetImageForKeyCode(keyCode)\r\n\t\t\tvisibility = true\r\n\t\tend\r\n\t\tsetIndicatorVisible(visibility)\r\n\tend)\r\n\r\n\tlocal function updateSize()\r\n\t\tlocal ySize = widget.AbsoluteSize.Y*0.96\r\n\t\tindicator.Size = UDim2.new(0, ySize, 0, ySize)\r\n\tend\r\n\twidget:GetPropertyChangedSignal(\"AbsoluteSize\"):Connect(updateSize)\r\n\tupdateSize()\r\n\r\n\treturn indicator\r\nend",
                                        "Children": [],
                                        "Archivable": true
                                    },
                                    {
                                        "Name": "Menu",
                                        "ClassName": "ModuleScript",
                                        "Source": "return function(icon)\n\n\tlocal menu = Instance.new(\"ScrollingFrame\")\n\tmenu.Name = \"Menu\"\n\tmenu.BackgroundTransparency = 1\n\tmenu.Visible = true\n\tmenu.ZIndex = 1\n\tmenu.Size = UDim2.fromScale(1, 1)\n\tmenu.ClipsDescendants = true\n\tmenu.TopImage = \"\"\n\tmenu.BottomImage = \"\"\n\tmenu.HorizontalScrollBarInset = Enum.ScrollBarInset.Always\n\tmenu.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug\n\tmenu.ScrollingEnabled = true\n\tmenu.ScrollingDirection = Enum.ScrollingDirection.X\n\tmenu.ZIndex = 20\n\tmenu.ScrollBarThickness = 3\n\tmenu.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)\n\tmenu.ScrollBarImageTransparency = 0.8\n\tmenu.BorderSizePixel = 0\n\tmenu.Selectable = false\n\t\n\tlocal Icon = require(icon.iconModule)\n\tlocal menuUIListLayout = Icon.container.TopbarStandard:FindFirstChild(\"UIListLayout\", true):Clone()\n\tmenuUIListLayout.Name = \"MenuUIListLayout\"\n\tmenuUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center\n\tmenuUIListLayout.Parent = menu\n\n\tlocal menuGap = Instance.new(\"Frame\")\n\tmenuGap.Name = \"MenuGap\"\n\tmenuGap.BackgroundTransparency = 1\n\tmenuGap.Visible = false\n\tmenuGap.AnchorPoint = Vector2.new(0, 0.5)\n\tmenuGap.ZIndex = 5\n\tmenuGap.Parent = menu\n\t\n\tlocal hasStartedMenu = false\n\tlocal Themes = require(script.Parent.Parent.Features.Themes)\n\tlocal function totalChildrenChanged()\n\t\t\n\t\tlocal menuJanitor = icon.menuJanitor\n\t\tlocal totalIcons = #icon.menuIcons\n\t\tif hasStartedMenu then\n\t\t\tif totalIcons <= 0 then\n\t\t\t\tmenuJanitor:clean()\n\t\t\t\thasStartedMenu = false\n\t\t\tend\n\t\t\treturn\n\t\tend\n\t\thasStartedMenu = true\n\t\t\n\t\t-- Listen for changes\n\t\tmenuJanitor:add(icon.toggled:Connect(function()\n\t\t\tif #icon.menuIcons > 0 then\n\t\t\t\ticon.updateSize:Fire()\n\t\t\tend\n\t\tend))\n\t\t\n\t\t-- Modify appearance of menu icon when joined\n\t\tlocal _, modificationUID = icon:modifyTheme({\n\t\t\t{\"Menu\", \"Active\", true},\n\t\t})\n\t\ttask.defer(function()\n\t\t\tmenuJanitor:add(function()\n\t\t\t\ticon:removeModification(modificationUID)\n\t\t\tend)\n\t\tend)\n\t\t\n\t\t-- For right-aligned icons, this ensures their menus\n\t\t-- close button appear instantly when selected (instead\n\t\t-- of partially hidden from view)\n\t\tlocal previousCanvasX = menu.AbsoluteCanvasSize.X\n\t\tlocal function rightAlignCanvas()\n\t\t\tif icon.alignment == \"Right\" then\n\t\t\t\tlocal newCanvasX = menu.AbsoluteCanvasSize.X\n\t\t\t\tlocal difference = previousCanvasX - newCanvasX\n\t\t\t\tpreviousCanvasX = newCanvasX\n\t\t\t\tmenu.CanvasPosition = Vector2.new(menu.CanvasPosition.X - difference, 0)\n\t\t\tend\n\t\tend\n\t\tmenuJanitor:add(icon.selected:Connect(rightAlignCanvas))\n\t\tmenuJanitor:add(menu:GetPropertyChangedSignal(\"AbsoluteCanvasSize\"):Connect(rightAlignCanvas))\n\t\t\n\t\t-- Apply a close selected image if the user hasn't applied thier own\n\t\tlocal stateGroup = icon:getStateGroup()\n\t\tlocal imageDeselected = Themes.getThemeValue(stateGroup, \"IconImage\", \"Image\", \"Deselected\")\n\t\tlocal imageSelected = Themes.getThemeValue(stateGroup, \"IconImage\", \"Image\", \"Selected\")\n\t\tif imageDeselected == imageSelected then\n\t\t\tlocal fontLink = \"rbxasset://fonts/families/FredokaOne.json\"\n\t\t\tlocal fontFace = Font.new(fontLink, Enum.FontWeight.Light, Enum.FontStyle.Normal)\n\t\t\ticon:removeModificationWith(\"IconLabel\", \"Text\", \"Viewing\")\n\t\t\ticon:removeModificationWith(\"IconLabel\", \"Image\", \"Viewing\")\n\t\t\ticon:modifyTheme({\n\t\t\t\t{\"IconLabel\", \"FontFace\", fontFace, \"Selected\"},\n\t\t\t\t{\"IconLabel\", \"Text\", \"X\", \"Selected\"},\n\t\t\t\t{\"IconLabel\", \"TextSize\", 20, \"Selected\"},\n\t\t\t\t{\"IconLabel\", \"TextStrokeTransparency\", 0.8, \"Selected\"},\n\t\t\t\t{\"IconImage\", \"Image\", \"\", \"Selected\"},\n\t\t\t})\n\t\tend\n\n\t\t-- Change order of spot when alignment changes\n\t\tlocal iconSpot = icon:getInstance(\"IconSpot\")\n\t\tlocal menuGap = icon:getInstance(\"MenuGap\")\n\t\tlocal function updateAlignent()\n\t\t\tlocal alignment = icon.alignment\n\t\t\tif alignment == \"Right\" then\n\t\t\t\ticonSpot.LayoutOrder = 99999\n\t\t\t\tmenuGap.LayoutOrder = 99998\n\t\t\telse\n\t\t\t\ticonSpot.LayoutOrder = -99999\n\t\t\t\tmenuGap.LayoutOrder = -99998\n\t\t\tend\n\t\tend\n\t\tmenuJanitor:add(icon.alignmentChanged:Connect(updateAlignent))\n\t\tupdateAlignent()\n\t\t\n\t\t-- This updates the scrolling frame to only display a scroll\n\t\t-- length equal to the distance produced by its MaxIcons\n\t\tmenu:GetAttributeChangedSignal(\"MenuCanvasWidth\"):Connect(function()\n\t\t\tlocal canvasWidth = menu:GetAttribute(\"MenuCanvasWidth\")\n\t\t\tlocal canvasY = menu.CanvasSize.Y\n\t\t\tmenu.CanvasSize = UDim2.new(0, canvasWidth, canvasY.Scale, canvasY.Offset)\n\t\tend)\n\t\tmenuJanitor:add(icon.updateMenu:Connect(function()\n\t\t\tlocal maxIcons = menu:GetAttribute(\"MaxIcons\")\n\t\t\tif not maxIcons then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tlocal orderedInstances = {}\n\t\t\tfor _, child in pairs(menu:GetChildren()) do\n\t\t\t\tlocal widgetUID = child:GetAttribute(\"WidgetUID\")\n\t\t\t\tif widgetUID and child.Visible then\n\t\t\t\t\ttable.insert(orderedInstances, {child, child.AbsolutePosition.X})\n\t\t\t\tend\n\t\t\tend\n\t\t\ttable.sort(orderedInstances, function(groupA, groupB)\n\t\t\t\treturn groupA[2] < groupB[2]\n\t\t\tend)\n\t\t\tlocal totalWidth = 0\n\t\t\tfor i = 1, maxIcons do\n\t\t\t\tlocal group = orderedInstances[i]\n\t\t\t\tif not group then\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\t\tlocal child = group[1]\n\t\t\t\tlocal width = child.AbsoluteSize.X + menuUIListLayout.Padding.Offset\n\t\t\t\ttotalWidth += width\n\t\t\tend\n\t\t\tmenu:SetAttribute(\"MenuWidth\", totalWidth)\n\t\tend))\n\t\tlocal function startMenuUpdate()\n\t\t\ttask.delay(0.1, function()\n\t\t\t\ticon.startMenuUpdate:Fire()\n\t\t\tend)\n\t\tend\n\t\tlocal iconButton = icon:getInstance(\"IconButton\")\n\t\tlocal previousButtonWidth = iconButton.AbsoluteSize.X\n\t\tmenuJanitor:add(menu.ChildAdded:Connect(startMenuUpdate))\n\t\tmenuJanitor:add(menu.ChildRemoved:Connect(startMenuUpdate))\n\t\tmenuJanitor:add(menu:GetAttributeChangedSignal(\"MaxIcons\"):Connect(startMenuUpdate))\n\t\tmenuJanitor:add(menu:GetAttributeChangedSignal(\"MaxWidth\"):Connect(startMenuUpdate))\n\t\tstartMenuUpdate()\n\tend\n\t\n\ticon.menuChildAdded:Connect(totalChildrenChanged)\n\ticon.menuSet:Connect(function(arrayOfIcons)\n\t\t-- Reset any previous icons\n\t\tfor i, otherIconUID in pairs(icon.menuIcons) do\n\t\t\tlocal otherIcon = Icon.getIconByUID(otherIconUID)\n\t\t\totherIcon:destroy()\n\t\tend\n\t\t-- Apply new icons\n\t\tlocal totalNewIcons = #arrayOfIcons\n\t\tif type(arrayOfIcons) == \"table\" then\n\t\t\tfor i, otherIcon in pairs(arrayOfIcons) do\n\t\t\t\totherIcon:joinMenu(icon)\n\t\t\tend\n\t\tend\n\tend)\n\t\n\treturn menu\nend",
                                        "Children": [],
                                        "Archivable": true
                                    },
                                    {
                                        "Name": "Selection",
                                        "ClassName": "ModuleScript",
                                        "Source": "return function(Icon)\r\n\r\n\t-- Credit to lolmansReturn and Canary Software for\r\n\t-- retrieving these values\r\n\tlocal selectionContainer = Instance.new(\"Frame\")\r\n\tselectionContainer.Name = \"SelectionContainer\"\r\n\tselectionContainer.Visible = false\r\n\t\r\n\tlocal selection = Instance.new(\"Frame\")\r\n\tselection.Name = \"Selection\"\r\n\tselection.BackgroundColor3 = Color3.fromRGB(255, 255, 255)\r\n\tselection.BackgroundTransparency = 1\r\n\tselection.BorderColor3 = Color3.fromRGB(0, 0, 0)\r\n\tselection.BorderSizePixel = 0\r\n\tselection.Parent = selectionContainer\r\n\r\n\tlocal UIStroke = Instance.new(\"UIStroke\")\r\n\tUIStroke.Name = \"UIStroke\"\r\n\tUIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border\r\n\tUIStroke.Color = Color3.fromRGB(255, 255, 255)\r\n\tUIStroke.Thickness = 3\r\n\tUIStroke.Parent = selection\r\n\r\n\tlocal selectionGradient = Instance.new(\"UIGradient\")\r\n\tselectionGradient.Name = \"SelectionGradient\"\r\n\tselectionGradient.Parent = UIStroke\r\n\r\n\tlocal UICorner = Instance.new(\"UICorner\")\r\n\tUICorner:SetAttribute(\"Collective\", \"IconCorners\")\r\n\tUICorner.Name = \"UICorner\"\r\n\tUICorner.CornerRadius = UDim.new(1, 0)\r\n\tUICorner.Parent = selection\r\n\t\r\n\tlocal RunService = game:GetService(\"RunService\")\r\n\tlocal GuiService = game:GetService(\"GuiService\")\r\n\tlocal rotationSpeed = 1\r\n\tselection:GetAttributeChangedSignal(\"RotationSpeed\"):Connect(function()\r\n\t\trotationSpeed = selection:GetAttribute(\"RotationSpeed\")\r\n\tend)\r\n\tRunService.Heartbeat:Connect(function()\r\n\t\tif not GuiService.SelectedObject then\r\n\t\t\treturn\r\n\t\tend\r\n\t\tselectionGradient.Rotation = (os.clock() * rotationSpeed * 100) % 360\r\n\tend)\r\n\r\n\treturn selectionContainer\r\n\t\r\nend",
                                        "Children": [],
                                        "Archivable": true
                                    },
                                    {
                                        "Name": "Widget",
                                        "ClassName": "ModuleScript",
                                        "Source": "-- I named this 'Widget' instead of 'Icon' to make a clear difference between the icon *object* and\n-- the icon (aka Widget) instance.\n-- This contains the core components of the icon such as the button, image, label and notice. It's\n-- also responsible for handling the automatic resizing of the widget (based upon image visibility and text length)\n\nreturn function(icon, Icon)\n\n\tlocal widget = Instance.new(\"Frame\")\n\twidget:SetAttribute(\"WidgetUID\", icon.UID)\n\twidget.Name = \"Widget\"\n\twidget.BackgroundTransparency = 1\n\twidget.Visible = true\n\twidget.ZIndex = 20\n\twidget.Active = false\n\twidget.ClipsDescendants = true\n\n\tlocal button = Instance.new(\"Frame\")\n\tbutton.Name = \"IconButton\"\n\tbutton.Visible = true\n\tbutton.ZIndex = 2\n\tbutton.BorderSizePixel = 0\n\tbutton.Parent = widget\n\tbutton.ClipsDescendants = true\n\tbutton.Active = false -- This is essential for mobile scrollers to work when dragging\n\ticon.deselected:Connect(function()\n\t\tbutton.ClipsDescendants = true\n\tend)\n\ticon.selected:Connect(function()\n\t\ttask.defer(function()\n\t\t\ticon.resizingComplete:Once(function()\n\t\t\t\tif icon.isSelected then\n\t\t\t\t\tbutton.ClipsDescendants = false\n\t\t\t\tend\n\t\t\tend)\n\t\tend)\n\tend)\n\n\tlocal iconCorner = Instance.new(\"UICorner\")\n\ticonCorner:SetAttribute(\"Collective\", \"IconCorners\")\n\ticonCorner.Parent = button\n\n\tlocal menu = require(script.Parent.Menu)(icon)\n\tlocal menuUIListLayout = menu.MenuUIListLayout\n\tlocal menuGap = menu.MenuGap\n\tmenu.Parent = button\n\n\tlocal iconSpot = Instance.new(\"Frame\")\n\ticonSpot.Name = \"IconSpot\"\n\ticonSpot.BackgroundColor3 = Color3.fromRGB(225, 225, 225)\n\ticonSpot.BackgroundTransparency = 0.9\n\ticonSpot.Visible = true\n\ticonSpot.AnchorPoint = Vector2.new(0, 0.5)\n\ticonSpot.ZIndex = 5\n\ticonSpot.Parent = menu\n\n\tlocal iconSpotCorner = iconCorner:Clone()\n\ticonSpotCorner.Parent = iconSpot\n\n\tlocal overlay = iconSpot:Clone()\n\toverlay.Name = \"IconOverlay\"\n\toverlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)\n\toverlay.ZIndex = iconSpot.ZIndex + 1\n\toverlay.Size = UDim2.new(1, 0, 1, 0)\n\toverlay.Position = UDim2.new(0, 0, 0, 0)\n\toverlay.AnchorPoint = Vector2.new(0, 0)\n\toverlay.Visible = false\n\toverlay.Parent = iconSpot\n\n\tlocal clickRegion = Instance.new(\"TextButton\")\n\tclickRegion:SetAttribute(\"CorrespondingIconUID\", icon.UID)\n\tclickRegion.Name = \"ClickRegion\"\n\tclickRegion.BackgroundTransparency = 1\n\tclickRegion.Visible = true\n\tclickRegion.Text = \"\"\n\tclickRegion.ZIndex = 20\n\tclickRegion.Selectable = true\n\tclickRegion.SelectionGroup = true\n\tclickRegion.Parent = iconSpot\n\t\n\tlocal Gamepad = require(script.Parent.Parent.Features.Gamepad)\n\tGamepad.registerButton(clickRegion)\n\n\tlocal clickRegionCorner = iconCorner:Clone()\n\tclickRegionCorner.Parent = clickRegion\n\n\tlocal contents = Instance.new(\"Frame\")\n\tcontents.Name = \"Contents\"\n\tcontents.BackgroundTransparency = 1\n\tcontents.Size = UDim2.fromScale(1, 1)\n\tcontents.Parent = iconSpot\n\n\tlocal contentsList = Instance.new(\"UIListLayout\")\n\tcontentsList.Name = \"ContentsList\"\n\tcontentsList.FillDirection = Enum.FillDirection.Horizontal\n\tcontentsList.VerticalAlignment = Enum.VerticalAlignment.Center\n\tcontentsList.SortOrder = Enum.SortOrder.LayoutOrder\n\tcontentsList.VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly\n\tcontentsList.Padding = UDim.new(0, 3)\n\tcontentsList.Parent = contents\n\n\tlocal paddingLeft = Instance.new(\"Frame\")\n\tpaddingLeft.Name = \"PaddingLeft\"\n\tpaddingLeft.LayoutOrder = 1\n\tpaddingLeft.ZIndex = 5\n\tpaddingLeft.BorderColor3 = Color3.fromRGB(0, 0, 0)\n\tpaddingLeft.BackgroundTransparency = 1\n\tpaddingLeft.BorderSizePixel = 0\n\tpaddingLeft.BackgroundColor3 = Color3.fromRGB(255, 255, 255)\n\tpaddingLeft.Parent = contents\n\n\tlocal paddingCenter = Instance.new(\"Frame\")\n\tpaddingCenter.Name = \"PaddingCenter\"\n\tpaddingCenter.LayoutOrder = 3\n\tpaddingCenter.ZIndex = 5\n\tpaddingCenter.Size = UDim2.new(0, 0, 1, 0)\n\tpaddingCenter.BorderColor3 = Color3.fromRGB(0, 0, 0)\n\tpaddingCenter.BackgroundTransparency = 1\n\tpaddingCenter.BorderSizePixel = 0\n\tpaddingCenter.BackgroundColor3 = Color3.fromRGB(255, 255, 255)\n\tpaddingCenter.Parent = contents\n\n\tlocal paddingRight = Instance.new(\"Frame\")\n\tpaddingRight.Name = \"PaddingRight\"\n\tpaddingRight.LayoutOrder = 5\n\tpaddingRight.ZIndex = 5\n\tpaddingRight.BorderColor3 = Color3.fromRGB(0, 0, 0)\n\tpaddingRight.BackgroundTransparency = 1\n\tpaddingRight.BorderSizePixel = 0\n\tpaddingRight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)\n\tpaddingRight.Parent = contents\n\n\tlocal iconLabelContainer = Instance.new(\"Frame\")\n\ticonLabelContainer.Name = \"IconLabelContainer\"\n\ticonLabelContainer.LayoutOrder = 4\n\ticonLabelContainer.ZIndex = 3\n\ticonLabelContainer.AnchorPoint = Vector2.new(0, 0.5)\n\ticonLabelContainer.Size = UDim2.new(0, 0, 0.5, 0)\n\ticonLabelContainer.BackgroundTransparency = 1\n\ticonLabelContainer.Position = UDim2.new(0.5, 0, 0.5, 0)\n\ticonLabelContainer.Parent = contents\n\n\tlocal iconLabel = Instance.new(\"TextLabel\")\n\tlocal viewportX = workspace.CurrentCamera.ViewportSize.X+200\n\ticonLabel.Name = \"IconLabel\"\n\ticonLabel.LayoutOrder = 4\n\ticonLabel.ZIndex = 15\n\ticonLabel.AnchorPoint = Vector2.new(0, 0)\n\ticonLabel.Size = UDim2.new(0, viewportX, 1, 0)\n\ticonLabel.ClipsDescendants = false\n\ticonLabel.BackgroundTransparency = 1\n\ticonLabel.Position = UDim2.fromScale(0, 0)\n\ticonLabel.RichText = true\n\ticonLabel.TextColor3 = Color3.fromRGB(255, 255, 255)\n\ticonLabel.TextXAlignment = Enum.TextXAlignment.Left\n\ticonLabel.Text = \"\"\n\ticonLabel.TextWrapped = true\n\ticonLabel.TextWrap = true\n\ticonLabel.TextScaled = false\n\ticonLabel.Active = false\n\ticonLabel.AutoLocalize = true\n\ticonLabel.Parent = iconLabelContainer\n\n\tlocal iconImage = Instance.new(\"ImageLabel\")\n\ticonImage.Name = \"IconImage\"\n\ticonImage.LayoutOrder = 2\n\ticonImage.ZIndex = 15\n\ticonImage.AnchorPoint = Vector2.new(0, 0.5)\n\ticonImage.Size = UDim2.new(0, 0, 0.5, 0)\n\ticonImage.BackgroundTransparency = 1\n\ticonImage.Position = UDim2.new(0, 11, 0.5, 0)\n\ticonImage.ScaleType = Enum.ScaleType.Stretch\n\ticonImage.Active = false\n\ticonImage.Parent = contents\n\n\tlocal iconImageCorner = iconCorner:Clone()\n\ticonImageCorner:SetAttribute(\"Collective\", nil)\n\ticonImageCorner.CornerRadius = UDim.new(0, 0)\n\ticonImageCorner.Name = \"IconImageCorner\"\n\ticonImageCorner.Parent = iconImage\n\n\tlocal TweenService = game:GetService(\"TweenService\")\n\tlocal resizingCount = 0\n\tlocal repeating = false\n\tlocal function handleLabelAndImageChangesUnstaggered(forceUpdateString)\n\n\t\t-- We defer changes by a frame to eliminate all but 1 requests which\n\t\t-- could otherwise stack up to 20+ requests in a single frame\n\t\t-- We then repeat again once to account for any final changes\n\t\t-- Deferring is also essential because properties are set immediately\n\t\t-- afterwards (therefore calculations will use the correct values)\n\t\ttask.defer(function()\n\t\t\tlocal indicator = icon.indicator\n\t\t\tlocal usingIndicator = indicator and indicator.Visible\n\t\t\tlocal usingText = usingIndicator or iconLabel.Text ~= \"\"\n\t\t\tlocal usingImage = iconImage.Image ~= \"\" and iconImage.Image ~= nil\n\t\t\tlocal alignment = Enum.HorizontalAlignment.Center\n\t\t\tlocal NORMAL_BUTTON_SIZE = UDim2.fromScale(1, 1)\n\t\t\tlocal buttonSize = NORMAL_BUTTON_SIZE\n\t\t\tif usingImage and not usingText then\n\t\t\t\ticonLabelContainer.Visible = false\n\t\t\t\ticonImage.Visible = true\n\t\t\t\tpaddingLeft.Visible = false\n\t\t\t\tpaddingCenter.Visible = false\n\t\t\t\tpaddingRight.Visible = false\n\t\t\telseif not usingImage and usingText then\n\t\t\t\ticonLabelContainer.Visible = true\n\t\t\t\ticonImage.Visible = false\n\t\t\t\tpaddingLeft.Visible = true\n\t\t\t\tpaddingCenter.Visible = false\n\t\t\t\tpaddingRight.Visible = true\n\t\t\telseif usingImage and usingText then\n\t\t\t\ticonLabelContainer.Visible = true\n\t\t\t\ticonImage.Visible = true\n\t\t\t\tpaddingLeft.Visible = true\n\t\t\t\tpaddingCenter.Visible = not usingIndicator\n\t\t\t\tpaddingRight.Visible = not usingIndicator\n\t\t\t\talignment = Enum.HorizontalAlignment.Left\n\t\t\tend\n\t\t\tbutton.Size = buttonSize\n\n\t\t\tlocal function getItemWidth(item)\n\t\t\t\tlocal targetWidth = item:GetAttribute(\"TargetWidth\") or item.AbsoluteSize.X\n\t\t\t\treturn targetWidth\n\t\t\tend\n\t\t\tlocal contentsPadding = contentsList.Padding.Offset\n\t\t\tlocal initialWidgetWidth = contentsPadding --0\n\t\t\tlocal textWidth = iconLabel.TextBounds.X\n\t\t\ticonLabelContainer.Size = UDim2.new(0, textWidth, iconLabel.Size.Y.Scale, 0)\n\t\t\tfor _, child in pairs(contents:GetChildren()) do\n\t\t\t\tif child:IsA(\"GuiObject\") and child.Visible == true then\n\t\t\t\t\tlocal itemWidth = getItemWidth(child)\n\t\t\t\t\tinitialWidgetWidth += itemWidth + contentsPadding\n\t\t\t\tend\n\t\t\tend\n\t\t\tlocal widgetMinimumWidth = widget:GetAttribute(\"MinimumWidth\")\n\t\t\tlocal widgetMinimumHeight = widget:GetAttribute(\"MinimumHeight\")\n\t\t\tlocal widgetBorderSize = widget:GetAttribute(\"BorderSize\")\n\t\t\tlocal widgetWidth = math.clamp(initialWidgetWidth, widgetMinimumWidth, viewportX)\n\t\t\tlocal menuIcons = icon.menuIcons\n\t\t\tlocal additionalWidth = 0\n\t\t\tlocal hasMenu = #menuIcons > 0\n\t\t\tlocal showMenu = hasMenu and icon.isSelected\n\t\t\tif showMenu then\n\t\t\t\tfor _, frame in pairs(menu:GetChildren()) do\n\t\t\t\t\tif frame ~= iconSpot and frame:IsA(\"GuiObject\") and frame.Visible then\n\t\t\t\t\t\tadditionalWidth += getItemWidth(frame) + menuUIListLayout.Padding.Offset\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif not iconSpot.Visible then\n\t\t\t\t\twidgetWidth -= (getItemWidth(iconSpot) + menuUIListLayout.Padding.Offset*2 + widgetBorderSize)\n\t\t\t\tend\n\t\t\t\tadditionalWidth -= (widgetBorderSize*0.5)\n\t\t\t\twidgetWidth += additionalWidth - (widgetBorderSize*0.75)\n\t\t\tend\n\t\t\tmenuGap.Visible = showMenu and iconSpot.Visible\n\t\t\tlocal desiredWidth = widget:GetAttribute(\"DesiredWidth\")\n\t\t\tif desiredWidth and widgetWidth < desiredWidth then\n\t\t\t\twidgetWidth = desiredWidth\n\t\t\tend\n\n\t\t\ticon.updateMenu:Fire()\n\t\t\tlocal preWidth = math.max(widgetWidth-additionalWidth, widgetMinimumWidth)\n\t\t\tlocal spotWidth = preWidth-(widgetBorderSize*2)\n\t\t\tlocal menuWidth = menu:GetAttribute(\"MenuWidth\")\n\t\t\tlocal totalMenuWidth = menuWidth and menuWidth + spotWidth + menuUIListLayout.Padding.Offset + 10\n\t\t\tif totalMenuWidth then\n\t\t\t\tlocal maxWidth = menu:GetAttribute(\"MaxWidth\")\n\t\t\t\tif maxWidth then\n\t\t\t\t\ttotalMenuWidth = math.max(maxWidth, widgetMinimumWidth)\n\t\t\t\tend\n\t\t\t\tmenu:SetAttribute(\"MenuCanvasWidth\", widgetWidth)\n\t\t\t\tif totalMenuWidth < widgetWidth then\n\t\t\t\t\twidgetWidth = totalMenuWidth\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tlocal style = Enum.EasingStyle.Quint\n\t\t\tlocal direction = Enum.EasingDirection.Out\n\t\t\tlocal spotWidthMax = math.max(spotWidth, getItemWidth(iconSpot), iconSpot.AbsoluteSize.X)\n\t\t\tlocal widgetWidthMax = math.max(widgetWidth, getItemWidth(widget), widget.AbsoluteSize.X)\n\t\t\tlocal SPEED = 750\n\t\t\tlocal spotTweenInfo = TweenInfo.new(spotWidthMax/SPEED, style, direction)\n\t\t\tlocal widgetTweenInfo = TweenInfo.new(widgetWidthMax/SPEED, style, direction)\n\t\t\tTweenService:Create(iconSpot, spotTweenInfo, {\n\t\t\t\tPosition = UDim2.new(0, widgetBorderSize, 0.5, 0),\n\t\t\t\tSize = UDim2.new(0, spotWidth, 1, -widgetBorderSize*2),\n\t\t\t}):Play()\n\t\t\tTweenService:Create(clickRegion, spotTweenInfo, {\n\t\t\t\tSize = UDim2.new(0, spotWidth, 1, 0),\n\t\t\t}):Play()\n\t\t\tlocal newWidgetSize = UDim2.fromOffset(widgetWidth, widgetMinimumHeight)\n\t\t\tlocal updateInstantly = widget.Size.Y.Offset ~= widgetMinimumHeight\n\t\t\tif updateInstantly then\n\t\t\t\twidget.Size = newWidgetSize\n\t\t\tend\n\t\t\twidget:SetAttribute(\"TargetWidth\", newWidgetSize.X.Offset)\n\t\t\tlocal movingTween = TweenService:Create(widget, widgetTweenInfo, {\n\t\t\t\tSize = newWidgetSize,\n\t\t\t})\n\t\t\tmovingTween:Play()\n\t\t\tresizingCount += 1\n\t\t\tfor i = 1, widgetTweenInfo.Time * 100 do\n\t\t\t\ttask.delay(i/100, function()\n\t\t\t\t\tIcon.iconChanged:Fire(icon)\n\t\t\t\tend)\n\t\t\tend\n\t\t\ttask.delay(widgetTweenInfo.Time-0.2, function()\n\t\t\t\tresizingCount -= 1\n\t\t\t\ttask.defer(function()\n\t\t\t\t\tif resizingCount == 0 then\n\t\t\t\t\t\ticon.resizingComplete:Fire()\n\t\t\t\t\tend\n\t\t\t\tend)\n\t\t\tend)\n\t\t\ticon:updateParent()\n\t\tend)\n\tend\n\tlocal Utility = require(script.Parent.Parent.Utility)\n\tlocal handleLabelAndImageChanges = Utility.createStagger(0.01, handleLabelAndImageChangesUnstaggered)\n\tlocal firstTimeSettingFontFace = true\n\ticon:setBehaviour(\"IconLabel\", \"Text\", handleLabelAndImageChanges)\n\ticon:setBehaviour(\"IconLabel\", \"FontFace\", function(value)\n\t\tlocal previousFontFace = iconLabel.FontFace\n\t\tif previousFontFace == value then\n\t\t\treturn\n\t\tend\n\t\ttask.spawn(function()\n\t\t\t--[[\n\t\t\tlocal fontLink = value.Family\n\t\t\tif string.match(fontLink, \"rbxassetid://\") then\n\t\t\t\tlocal ContentProvider = game:GetService(\"ContentProvider\")\n\t\t\t\tlocal assets = {fontLink}\n\t\t\t\tContentProvider:PreloadAsync(assets)\n\t\t\t\tprint(\"FONT LOADED!!!\")\n\t\t\tend--]]\n\n\t\t\t-- Afaik there's no way to determine when a Font Family has\n\t\t\t-- loaded (even with ContentProvider), so we just have to try\n\t\t\t-- a few times and hope it loads within the refresh period\n\t\t\thandleLabelAndImageChanges()\n\t\t\tif firstTimeSettingFontFace then\n\t\t\t\tfirstTimeSettingFontFace = false\n\t\t\t\tfor i = 1, 10 do\n\t\t\t\t\ttask.wait(1)\n\t\t\t\t\thandleLabelAndImageChanges()\n\t\t\t\tend\n\t\t\tend\n\t\tend)\n\tend)\n\tlocal function updateBorderSize()\n\t\ttask.defer(function()\n\t\t\tlocal borderOffset = widget:GetAttribute(\"BorderSize\")\n\t\t\tlocal alignment = icon.alignment\n\t\t\tlocal alignmentOffset = (iconSpot.Visible == false and 0) or (alignment == \"Right\" and -borderOffset) or borderOffset\n\t\t\tmenu.Position = UDim2.new(0, alignmentOffset, 0, 0)\n\t\t\tmenuGap.Size = UDim2.fromOffset(borderOffset, 0)\n\t\t\tmenuUIListLayout.Padding = UDim.new(0, 0)\n\t\t\thandleLabelAndImageChanges()\n\t\tend)\n\tend\n\ticon:setBehaviour(\"Widget\", \"BorderSize\", updateBorderSize)\n\ticon:setBehaviour(\"IconSpot\", \"Visible\", updateBorderSize)\n\ticon.startMenuUpdate:Connect(handleLabelAndImageChanges)\n\ticon.updateSize:Connect(handleLabelAndImageChanges)\n\ticon:setBehaviour(\"ContentsList\", \"HorizontalAlignment\", handleLabelAndImageChanges)\n\ticon:setBehaviour(\"Widget\", \"Visible\", handleLabelAndImageChanges)\n\ticon:setBehaviour(\"Widget\", \"DesiredWidth\", handleLabelAndImageChanges)\n\ticon:setBehaviour(\"Widget\", \"MinimumWidth\", handleLabelAndImageChanges)\n\ticon:setBehaviour(\"Widget\", \"MinimumHeight\", handleLabelAndImageChanges)\n\ticon:setBehaviour(\"Indicator\", \"Visible\", handleLabelAndImageChanges)\n\ticon:setBehaviour(\"IconImageRatio\", \"AspectRatio\", handleLabelAndImageChanges)\n\ticon:setBehaviour(\"IconImage\", \"Image\", function(value)\n\t\tlocal textureId = (tonumber(value) and \"http://www.roblox.com/asset/?id=\"..value) or value or \"\"\n\t\tif iconImage.Image ~= textureId then\n\t\t\thandleLabelAndImageChanges()\n\t\tend\n\t\treturn textureId\n\tend)\n\ticon.alignmentChanged:Connect(function(newAlignment)\n\t\tif newAlignment == \"Center\" then\n\t\t\tnewAlignment = \"Left\"\n\t\tend\n\t\tmenuUIListLayout.HorizontalAlignment = Enum.HorizontalAlignment[newAlignment]\n\t\tupdateBorderSize()\n\tend)\n\n\tlocal iconImageScale = Instance.new(\"NumberValue\")\n\ticonImageScale.Name = \"IconImageScale\"\n\ticonImageScale.Parent = iconImage\n\ticonImageScale:GetPropertyChangedSignal(\"Value\"):Connect(function()\n\t\ticonImage.Size = UDim2.new(iconImageScale.Value, 0, iconImageScale.Value, 0)\n\tend)\n\n\tlocal UIAspectRatioConstraint = Instance.new(\"UIAspectRatioConstraint\")\n\tUIAspectRatioConstraint.Name = \"IconImageRatio\"\n\tUIAspectRatioConstraint.AspectType = Enum.AspectType.FitWithinMaxSize\n\tUIAspectRatioConstraint.DominantAxis = Enum.DominantAxis.Height\n\tUIAspectRatioConstraint.Parent = iconImage\n\n\tlocal iconGradient = Instance.new(\"UIGradient\")\n\ticonGradient.Name = \"IconGradient\"\n\ticonGradient.Enabled = true\n\ticonGradient.Parent = button\n\n\tlocal iconSpotGradient = Instance.new(\"UIGradient\")\n\ticonSpotGradient.Name = \"IconSpotGradient\"\n\ticonSpotGradient.Enabled = true\n\ticonSpotGradient.Parent = iconSpot\n\n\treturn widget\nend",
                                        "Children": [],
                                        "Archivable": true
                                    },
                                    {
                                        "Name": "Notice",
                                        "ClassName": "ModuleScript",
                                        "Source": "return function(icon, Icon)\r\n\r\n\tlocal notice = Instance.new(\"Frame\")\r\n\tnotice.Name = \"Notice\"\r\n\tnotice.ZIndex = 25\r\n\tnotice.AutomaticSize = Enum.AutomaticSize.X\r\n\tnotice.BorderColor3 = Color3.fromRGB(0, 0, 0)\r\n\tnotice.BorderSizePixel = 0\r\n\tnotice.BackgroundTransparency = 0.1\r\n\tnotice.BackgroundColor3 = Color3.fromRGB(255, 255, 255)\r\n\tnotice.Visible = false\r\n\tnotice.Parent = icon.widget\r\n\r\n\tlocal UICorner = Instance.new(\"UICorner\")\r\n\tUICorner.CornerRadius = UDim.new(1, 0)\r\n\tUICorner.Parent = notice\r\n\r\n\tlocal UIStroke = Instance.new(\"UIStroke\")\r\n\tUIStroke.Parent = notice\r\n\r\n\tlocal noticeLabel = Instance.new(\"TextLabel\")\r\n\tnoticeLabel.Name = \"NoticeLabel\"\r\n\tnoticeLabel.ZIndex = 26\r\n\tnoticeLabel.AnchorPoint = Vector2.new(0.5, 0.5)\r\n\tnoticeLabel.AutomaticSize = Enum.AutomaticSize.X\r\n\tnoticeLabel.Size = UDim2.new(1, 0, 1, 0)\r\n\tnoticeLabel.BackgroundTransparency = 1\r\n\tnoticeLabel.Position = UDim2.new(0.5, 0, 0.515, 0)\r\n\tnoticeLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)\r\n\tnoticeLabel.FontSize = Enum.FontSize.Size14\r\n\tnoticeLabel.TextColor3 = Color3.fromRGB(0, 0, 0)\r\n\tnoticeLabel.Text = \"1\"\r\n\tnoticeLabel.TextWrapped = true\r\n\tnoticeLabel.TextWrap = true\r\n\tnoticeLabel.Font = Enum.Font.Arial\r\n\tnoticeLabel.Parent = notice\r\n\t\r\n\tlocal iconModule = script.Parent.Parent\r\n\tlocal packages = iconModule.Packages\r\n\tlocal Janitor = require(packages.Janitor)\r\n\tlocal Signal = require(packages.GoodSignal)\r\n\tlocal Utility = require(iconModule.Utility)\r\n\ticon.noticeChanged:Connect(function(totalNotices)\r\n\r\n\t\t-- Notice amount\r\n\t\tif not totalNotices then\r\n\t\t\treturn\r\n\t\tend\r\n\t\tlocal exceeded99 = totalNotices > 99\r\n\t\tlocal noticeDisplay = (exceeded99 and \"99+\") or totalNotices\r\n\t\tnoticeLabel.Text = noticeDisplay\r\n\t\tif exceeded99 then\r\n\t\t\tnoticeLabel.TextSize = 11\r\n\t\tend\r\n\r\n\t\t-- Should enable\r\n\t\tlocal enabled = true\r\n\t\tif totalNotices < 1 then\r\n\t\t\tenabled = false\r\n\t\tend\r\n\t\tlocal parentIcon = Icon.getIconByUID(icon.parentIconUID)\r\n\t\tlocal dropdownOrMenuActive = #icon.dropdownIcons > 0 or #icon.menuIcons > 0\r\n\t\tif icon.isSelected and dropdownOrMenuActive then\r\n\t\t\tenabled = false\r\n\t\telseif parentIcon and not parentIcon.isSelected then\r\n\t\t\tenabled = false\r\n\t\tend\r\n\t\tUtility.setVisible(notice, enabled, \"NoticeHandler\")\r\n\r\n\tend)\r\n\ticon.noticeStarted:Connect(function(customClearSignal, noticeId)\r\n\t\r\n\t\tif not customClearSignal then\r\n\t\t\tcustomClearSignal = icon.deselected\r\n\t\tend\r\n\t\tlocal parentIcon = Icon.getIconByUID(icon.parentIconUID)\r\n\t\tif parentIcon then\r\n\t\t\tparentIcon:notify(customClearSignal)\r\n\t\tend\r\n\t\t\r\n\t\tlocal noticeJanitor = icon.janitor:add(Janitor.new())\r\n\t\tlocal noticeComplete = noticeJanitor:add(Signal.new())\r\n\t\tnoticeJanitor:add(icon.endNotices:Connect(function()\r\n\t\t\tnoticeComplete:Fire()\r\n\t\tend))\r\n\t\tnoticeJanitor:add(customClearSignal:Connect(function()\r\n\t\t\tnoticeComplete:Fire()\r\n\t\tend))\r\n\t\tnoticeId = noticeId or Utility.generateUID()\r\n\t\ticon.notices[noticeId] = {\r\n\t\t\tcompleteSignal = noticeComplete,\r\n\t\t\tclearNoticeEvent = customClearSignal,\r\n\t\t}\r\n\t\tlocal noticeLabel = icon:getInstance(\"NoticeLabel\")\r\n\t\tlocal function updateNotice()\r\n\t\t\ticon.noticeChanged:Fire(icon.totalNotices)\r\n\t\tend\r\n\t\ticon.notified:Fire(noticeId)\r\n\t\ticon.totalNotices += 1\r\n\t\tupdateNotice()\r\n\t\tnoticeComplete:Once(function()\r\n\t\t\tnoticeJanitor:destroy()\r\n\t\t\ticon.totalNotices -= 1\r\n\t\t\ticon.notices[noticeId] = nil\r\n\t\t\tupdateNotice()\r\n\t\tend)\r\n\tend)\r\n\t\r\n\t-- Establish the notice\r\n\tnotice:SetAttribute(\"ClipToJoinedParent\", true)\r\n\ticon:clipOutside(notice)\r\n\t\r\n\treturn notice\r\nend",
                                        "Children": [],
                                        "Archivable": true
                                    }
                                ],
                                "ClassName": "Folder"
                            },
                            {
                                "Name": "Attribute",
                                "ClassName": "ModuleScript",
                                "Source": "-- v3 alone has taken 250+ hours so please consider keeping this\n-- required attribute and linking to TopbarPlus within your games\n-- description or devforum post. An in-game readable version also\n-- makes it easier for me to debug and compare differences betewen\n-- live places. Thanks! ~Ben\n\nlocal RunService = game:GetService(\"RunService\")\nlocal GroupService = game:GetService(\"GroupService\")\nlocal Players = game:GetService(\"Players\")\nif not RunService:IsStudio() then\n\tprint(` Running TopbarPlus {require(script.Parent.VERSION)} by ForeverHD`)\nend\n\nreturn {}",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "Features",
                                "Archivable": true,
                                "Children": [
                                    {
                                        "Name": "Gamepad",
                                        "ClassName": "ModuleScript",
                                        "Source": "-- As the name suggests, this handles everything related to gamepads\n-- (i.e. Xbox or Playstation controllers) and their navigation\n-- I created a separate module for gamepads (and not touchpads or\n-- keyboards) because gamepads are greatly more unqiue and require\n-- additional tailored programming\n\n\n\n-- SERVICES\nlocal GamepadService = game:GetService(\"GamepadService\")\nlocal UserInputService = game:GetService(\"UserInputService\")\nlocal GuiService = game:GetService(\"GuiService\")\n\n\n\n-- LOCAL\nlocal Gamepad = {}\nlocal Icon\n\n\n\n-- FUNCTIONS\n-- This is called upon the Icon initializing\nfunction Gamepad.start(incomingIcon)\n\t\n\t-- Public variables\n\tIcon = incomingIcon\n\tIcon.highlightKey = Enum.KeyCode.DPadUp -- What controller key to highlight the topbar (or set to false to disable)\n\tIcon.highlightIcon = false -- Change to a specific icon if you'd like to highlight a specific icon instead of the left-most\n\t\n\t-- We defer so the developer can make changes before the\n\t-- gamepad controls are initialized\n\ttask.delay(1, function()\n\t\t-- Some local utility\n\t\tlocal iconsDict = Icon.iconsDictionary\n\t\tlocal function getIconFromSelectedObject()\n\t\t\tlocal clickRegion = GuiService.SelectedObject\n\t\t\tlocal iconUID = clickRegion and clickRegion:GetAttribute(\"CorrespondingIconUID\")\n\t\t\tlocal icon = iconUID and iconsDict[iconUID]\n\t\t\treturn icon\n\t\tend\n\t\t\n\t\t-- This enables users to instantly open up their last selected icon\n\t\tlocal previousHighlightedIcon\n\t\tlocal iconDisplayingHighlightKey\n\t\tlocal usedIndicatorOnce = false\n\t\tlocal usedBOnce = false\n\t\tlocal Utility = require(script.Parent.Parent.Utility)\n\t\tlocal Selection = require(script.Parent.Parent.Elements.Selection)\n\t\tlocal function updateSelectedObject()\n\t\t\tlocal icon = getIconFromSelectedObject()\n\t\t\tlocal gamepadEnabled = UserInputService.GamepadEnabled\n\t\t\tif icon then\n\t\t\t\tif gamepadEnabled then\n\t\t\t\t\tlocal clickRegion = icon:getInstance(\"ClickRegion\")\n\t\t\t\t\tlocal selection = icon.selection\n\t\t\t\t\tif not selection then\n\t\t\t\t\t\tselection = icon.janitor:add(Selection(Icon))\n\t\t\t\t\t\tselection:SetAttribute(\"IgnoreVisibilityUpdater\", true)\n\t\t\t\t\t\tselection.Parent = icon.widget\n\t\t\t\t\t\ticon.selection = selection\n\t\t\t\t\t\ticon:refreshAppearance(selection) --icon:clipOutside(selection)\n\t\t\t\t\tend\n\t\t\t\t\tclickRegion.SelectionImageObject = selection.Selection\n\t\t\t\tend\n\t\t\t\tif previousHighlightedIcon and previousHighlightedIcon ~= icon then\n\t\t\t\t\tpreviousHighlightedIcon:setIndicator()\n\t\t\t\tend\n\t\t\t\tlocal newIndicator = if gamepadEnabled and not usedBOnce and not icon.parentIconUID then Enum.KeyCode.ButtonB else nil\n\t\t\t\tpreviousHighlightedIcon = icon\n\t\t\t\tIcon.lastHighlightedIcon = icon\n\t\t\t\ticon:setIndicator(newIndicator)\n\t\t\telse\n\t\t\t\tlocal newIndicator = if gamepadEnabled and not usedIndicatorOnce then Icon.highlightKey else nil\n\t\t\t\tif not previousHighlightedIcon then\n\t\t\t\t\tpreviousHighlightedIcon = Gamepad.getIconToHighlight()\n\t\t\t\tend\n\t\t\t\tif newIndicator == Icon.highlightKey then\n\t\t\t\t\t-- We only display the highlightKey once to show\n\t\t\t\t\t-- the user how to highlight the topbar icon\n\t\t\t\t\tusedIndicatorOnce = true\n\t\t\t\telse\n\t\t\t\t\t--usedBOnce = true\n\t\t\t\tend\n\t\t\t\tif previousHighlightedIcon then\n\t\t\t\t\tpreviousHighlightedIcon:setIndicator(newIndicator)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tGuiService:GetPropertyChangedSignal(\"SelectedObject\"):Connect(updateSelectedObject)\n\n\t\t-- This listens for a gamepad being present/added/removed\n\t\tlocal function checkGamepadEnabled()\n\t\t\tlocal gamepadEnabled = UserInputService.GamepadEnabled\n\t\t\tif not gamepadEnabled then\n\t\t\t\tusedIndicatorOnce = false\n\t\t\t\tusedBOnce = false\n\t\t\tend\n\t\t\tupdateSelectedObject()\n\t\tend\n\t\tUserInputService:GetPropertyChangedSignal(\"GamepadEnabled\"):Connect(checkGamepadEnabled)\n\t\tcheckGamepadEnabled()\n\n\t\t-- This allows for easy highlighting of the topbar when the\n\t\t-- when ``Icon.highlightKey`` (i.e. DPadUp) is pressed.\n\t\t-- If you'd like to disable, do ``Icon.highlightKey = false``\n\t\tUserInputService.InputBegan:Connect(function(input, touchingAnObject)\n\t\t\tif input.UserInputType == Enum.UserInputType.MouseButton1 then\n\t\t\t\t-- Sometimes the Roblox gamepad glitches when combined with a cursor\n\t\t\t\t-- This fixes that by unhighlighting if the cursor is pressed down\n\t\t\t\t-- (i.e. a mouse click)\n\t\t\t\tlocal icon = getIconFromSelectedObject()\n\t\t\t\tif icon then\n\t\t\t\t\tGuiService.SelectedObject = nil\n\t\t\t\tend\n\t\t\t\treturn\n\t\t\tend\n\t\t\tif input.KeyCode ~= Icon.highlightKey then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tlocal iconToHighlight = Gamepad.getIconToHighlight()\n\t\t\tif iconToHighlight then\n\t\t\t\tif GamepadService.GamepadCursorEnabled then\n\t\t\t\t\ttask.wait(0.2)\n\t\t\t\t\tGamepadService:DisableGamepadCursor()\n\t\t\t\tend\n\t\t\t\tlocal clickRegion = iconToHighlight:getInstance(\"ClickRegion\")\n\t\t\t\tGuiService.SelectedObject = clickRegion\n\t\t\tend\n\t\tend)\n\tend)\nend\n\nfunction Gamepad.getIconToHighlight()\n\t-- If an icon has already been selected, returns the last selected icon\n\t-- Else if more than 0 icons, it selects the left-most icon\n\tlocal iconsDict = Icon.iconsDictionary\n\tlocal iconToHighlight = Icon.highlightIcon or Icon.lastHighlightedIcon\n\tif not iconToHighlight then\n\t\tlocal currentX\n\t\tfor _, icon in pairs(iconsDict) do\n\t\t\tif icon.parentIconUID then\n\t\t\t\tcontinue\n\t\t\tend\n\t\t\tlocal thisX = icon.widget.AbsolutePosition.X\n\t\t\tif not currentX or thisX < currentX then\n\t\t\t\ticonToHighlight = icon\n\t\t\t\tcurrentX = iconToHighlight.widget.AbsolutePosition.X\n\t\t\tend\n\t\tend\n\tend\n\treturn iconToHighlight\nend\n\n-- This called when the icon's ClickRegion is created\nfunction Gamepad.registerButton(buttonInstance)\n\t-- This provides a basic level of support for controllers by making\n\t-- the icons easy to highlight via the virtual cursor, then\n\t-- when selected, focuses in on the selected icon and hops\n\t-- between other nearby icons simply by toggling the joystick\n\tlocal inputBegan = false\n\tbuttonInstance.InputBegan:Connect(function(input)\n\t\t-- Two wait frames required to ensure inputBegan is detected within\n\t\t-- UserInputService.InputBegan. We do this because object.InputBegan\n\t\t-- does not return the correct input objects (unlike the service)\n\t\tinputBegan = true\n\t\ttask.wait()\n\t\ttask.wait()\n\t\tinputBegan = false\n\tend)\n\tlocal connection = UserInputService.InputBegan:Connect(function(input)\n\t\ttask.wait()\n\t\tif input.KeyCode == Enum.KeyCode.ButtonA and inputBegan then\n\t\t\t-- We focus on an icon when selected via the virtual cursor\n\t\t\ttask.wait(0.2)\n\t\t\tGamepadService:DisableGamepadCursor()\n\t\t\tGuiService.SelectedObject = buttonInstance\n\t\t\treturn\n\t\tend\n\t\tlocal isSelected = GuiService.SelectedObject == buttonInstance\n\t\tlocal unselectKeyCodes = {\"ButtonB\", \"ButtonSelect\"}\n\t\tlocal keyName = input.KeyCode.Name\n\t\tif table.find(unselectKeyCodes, keyName) and isSelected then\n\t\t\t-- We unfocus when back button is pressed, but ignore\n\t\t\t-- if the virtual cursor is disabled otherwise it will be\n\t\t\t-- impossible to select the topbar\n\t\t\tif not(keyName == \"ButtonSelect\" and not GamepadService.GamepadCursorEnabled) then\n\t\t\t\tGuiService.SelectedObject = nil\n\t\t\tend\n\t\tend\n\tend)\n\tbuttonInstance.Destroying:Once(function()\n\t\tconnection:Disconnect()\n\tend)\nend\n\n\n\nreturn Gamepad",
                                        "Children": [],
                                        "Archivable": true
                                    },
                                    {
                                        "Name": "Overflow",
                                        "ClassName": "ModuleScript",
                                        "Source": "-- When designing your game for many devices and screen sizes, icons may occasionally\n-- particularly for smaller devices like phones, overlap with other icons or the bounds\n-- of the screen. The overflow handler solves this challenge by moving the out-of-bounds\n-- icon into an overflow menu (with a limited scrolling canvas) preventing overlaps occuring\n\n\n\n-- LOCAL\nlocal Overflow = {}\nlocal holders = {}\nlocal orderedAvailableIcons = {}\nlocal iconsDict\nlocal currentCamera = workspace.CurrentCamera\nlocal overflowIcons = {}\nlocal overflowIconUIDs = {}\nlocal Utility = require(script.Parent.Parent.Utility)\nlocal Icon\n\n\n\n-- FUNCTIONS\n-- This is called upon the Icon initializing\nfunction Overflow.start(incomingIcon)\n\tIcon = incomingIcon\n\ticonsDict = Icon.iconsDictionary\n\tlocal primaryScreenGui\n\tfor _, screenGui in pairs(Icon.container) do\n\t\tif primaryScreenGui == nil and screenGui.ScreenInsets == Enum.ScreenInsets.TopbarSafeInsets then\n\t\t\tprimaryScreenGui = screenGui\n\t\tend\n\t\tfor _, holder in pairs(screenGui.Holders:GetChildren()) do\n\t\t\tif holder:GetAttribute(\"IsAHolder\") then\n\t\t\t\tholders[holder.Name] = holder\n\t\t\tend\n\t\tend\n\tend\n\n\t-- We listen for changes in icons (such as them being added, removed,\n\t-- the setting of a different alignment, the widget size changing, etc)\n\tlocal beginOverflow = false\n\tlocal updateBoundaries = Utility.createStagger(0.1, function(ignoreAvailable)\n\t\tif not beginOverflow then\n\t\t\treturn\n\t\tend\n\t\tif not ignoreAvailable then\n\t\t\tOverflow.updateAvailableIcons(\"Center\")\n\t\tend\n\t\tOverflow.updateBoundary(\"Left\")\n\t\tOverflow.updateBoundary(\"Right\")\n\tend)\n\ttask.delay(1, function()\n\t\t-- This is essential to prevent central icons begin added\n\t\t-- left or right due to incomplete UIListLayout calculations\n\t\t-- within the first few frames\n\t\tbeginOverflow = true\n\t\tupdateBoundaries()\n\tend)\n\tIcon.iconAdded:Connect(updateBoundaries)\n\tIcon.iconRemoved:Connect(updateBoundaries)\n\tIcon.iconChanged:Connect(updateBoundaries)\n\tcurrentCamera:GetPropertyChangedSignal(\"ViewportSize\"):Connect(function()\n\t\tupdateBoundaries(true)\n\tend)\n\tprimaryScreenGui:GetPropertyChangedSignal(\"AbsoluteSize\"):Connect(function()\n\t\tupdateBoundaries(true)\n\tend)\nend\n\nfunction Overflow.getWidth(icon, getMaxWidth)\n\tlocal widget = icon.widget\n\treturn widget:GetAttribute(\"TargetWidth\") or widget.AbsoluteSize.X\nend\n\nfunction Overflow.getAvailableIcons(alignment)\n\tlocal ourOrderedIcons = orderedAvailableIcons[alignment]\n\tif not ourOrderedIcons then\n\t\tourOrderedIcons = Overflow.updateAvailableIcons(alignment)\n\tend\n\treturn ourOrderedIcons\nend\n\nfunction Overflow.updateAvailableIcons(alignment)\n\n\t-- We only track items that are directly on the topbar (i.e. not within a parent icon)\n\tlocal ourTotal = 0\n\tlocal holder = holders[alignment]\n\tlocal holderUIList = holder.UIListLayout\n\tlocal ourOrderedIcons = {}\n\tfor _, icon in pairs(iconsDict) do\n\t\tlocal parentUID = icon.parentIconUID\n\t\tlocal isDirectlyOnTopbar = not parentUID or overflowIconUIDs[parentUID]\n\t\tlocal isOverflow = overflowIconUIDs[icon.UID]\n\t\tif isDirectlyOnTopbar and icon.alignment == alignment and not isOverflow then\n\t\t\ttable.insert(ourOrderedIcons, icon)\n\t\t\tourTotal += 1\n\t\tend\n\tend\n\n\t-- Ignore if no icons are available\n\tif ourTotal <= 0 then\n\t\treturn {}\n\tend\n\n\t-- This sorts these icons by smallest order, or if equal, left-most position\n\t-- (even for the right alignment because all icons are sorted left-to-right)\n\ttable.sort(ourOrderedIcons, function(iconA, iconB)\n\t\tlocal orderA = iconA.widget.LayoutOrder\n\t\tlocal orderB = iconB.widget.LayoutOrder\n\t\tlocal hasParentA = iconA.parentIconUID\n\t\tlocal hasParentB = iconB.parentIconUID\n\t\tif hasParentA == hasParentB then\n\t\t\tif orderA < orderB then\n\t\t\t\treturn true\n\t\t\tend\n\t\t\tif orderA > orderB then\n\t\t\t\treturn false\n\t\t\tend\n\t\t\treturn iconA.widget.AbsolutePosition.X < iconB.widget.AbsolutePosition.X\n\t\telseif hasParentB then\n\t\t\treturn false\n\t\telseif hasParentA then\n\t\t\treturn true\n\t\tend\n\tend)\n\n\t-- Finish up\n\torderedAvailableIcons[alignment] = ourOrderedIcons\n\treturn ourOrderedIcons\n\nend\n\nfunction Overflow.getRealXPositions(alignment, orderedIcons)\n\t-- We calculate the the absolute position of icons instead of reading\n\t-- directly to determine where they would be if not within an overflow\n\tlocal joinOverflow = false\n\tlocal isLeft = alignment == \"Left\"\n\tlocal holder = holders[alignment]\n\tlocal holderXPos = holder.AbsolutePosition.X\n\tlocal holderXSize = holder.AbsoluteSize.X\n\tlocal holderUIList = holder.UIListLayout\n\tlocal topbarInset = holderUIList.Padding.Offset\n\tlocal absoluteX = (isLeft and holderXPos) or holderXPos + holderXSize\n\tlocal realXPositions = {}\n\tif isLeft then\n\t\tUtility.reverseTable(orderedIcons)\n\tend\n\tfor i = #orderedIcons, 1, -1 do\n\t\tlocal icon = orderedIcons[i]\n\t\tlocal sizeX = Overflow.getWidth(icon)\n\t\tif not isLeft then\n\t\t\tabsoluteX -= sizeX\n\t\tend\n\t\trealXPositions[icon.UID] = absoluteX\n\t\tif isLeft then\n\t\t\tabsoluteX += sizeX\n\t\tend\n\t\tabsoluteX += (isLeft and topbarInset) or -topbarInset\n\tend\n\treturn realXPositions\nend\n\nfunction Overflow.updateBoundary(alignment)\n\n\t-- We only track items that are directly on the topbar (i.e. not within a parent icon) or within an overflow\n\tlocal holder = holders[alignment]\n\tlocal holderUIList = holder.UIListLayout\n\tlocal holderXPos = holder.AbsolutePosition.X\n\tlocal holderXSize = holder.AbsoluteSize.X\n\tlocal topbarInset = holderUIList.Padding.Offset\n\tlocal topbarPadding = holderUIList.Padding.Offset\n\tlocal BOUNDARY_GAP = topbarInset\n\tlocal ourOrderedIcons = Overflow.updateAvailableIcons(alignment)\n\tlocal boundWidth = 0\n\tlocal ourTotal = 0\n\tfor _, icon in pairs(ourOrderedIcons) do\n\t\tboundWidth += Overflow.getWidth(icon) + topbarPadding\n\t\tourTotal += 1\n\tend\n\tif ourTotal <= 0 then\n\t\treturn\n\tend\n\t\n\t-- These are the icons with menus which icons will be moved into\n\t-- when overflowing\n\tlocal isCentral = alignment == \"Central\"\n\tlocal isLeft = alignment == \"Left\"\n\tlocal isRight = not isLeft\n\tlocal overflowIcon = overflowIcons[alignment]\n\tif not overflowIcon and not isCentral and #ourOrderedIcons > 0 then\n\t\tlocal order = (isLeft and -9999999) or 9999999\n\t\toverflowIcon = Icon.new()--:setLabel(`{alignment}`)\n\t\toverflowIcon:setImage(6069276526, \"Deselected\")\n\t\toverflowIcon:setName(\"Overflow\"..alignment)\n\t\toverflowIcon:setOrder(order)\n\t\toverflowIcon:setAlignment(alignment)\n\t\toverflowIcon:autoDeselect(false)\n\t\toverflowIcon.isAnOverflow = true\n\t\t--overflowIcon:freezeMenu()\n\t\toverflowIcon:select(\"OverflowStart\", overflowIcon)\n\t\toverflowIcon:setEnabled(false)\n\t\toverflowIcons[alignment] = overflowIcon\n\t\toverflowIconUIDs[overflowIcon.UID] = true\n\tend\n\n\t-- The default boundary is the point where both the left-most-right-icon\n\t-- and left-most-right-icon meet OR the opposite side of the screen\n\tlocal oppositeAlignment = (alignment == \"Left\" and \"Right\") or \"Left\"\n\tlocal oppositeOrderedIcons = Overflow.updateAvailableIcons(oppositeAlignment)\n\tlocal nearestOppositeIcon = (isLeft and oppositeOrderedIcons[1]) or (isRight and oppositeOrderedIcons[#oppositeOrderedIcons])\n\tlocal oppositeOverflowIcon = overflowIcons[oppositeAlignment]\n\tlocal boundary = (isLeft and holderXPos + holderXSize) or holderXPos\n\tif nearestOppositeIcon then\n\t\tlocal oppositeEndWidget = nearestOppositeIcon.widget\n\t\tlocal oppositeRealXPositions = Overflow.getRealXPositions(oppositeAlignment, oppositeOrderedIcons)\n\t\tlocal oppositeX = oppositeRealXPositions[nearestOppositeIcon.UID]\n\t\tlocal oppositeXSize = Overflow.getWidth(nearestOppositeIcon)\n\t\tboundary = (isLeft and oppositeX - BOUNDARY_GAP) or oppositeX + oppositeXSize + BOUNDARY_GAP\n\tend\n\t\n\t-- We get the left-most icon (if left alignment) or right-most-icon (if\n\t-- right alignment) of the central icons group to see if we need to change\n\t-- the boundary (if the central icon boundary is smaller than the alignment\n\t-- boundary then we use the central)\n\tlocal centerOrderedIcons = Overflow.getAvailableIcons(\"Center\")\n\tlocal centerPos = (isLeft and 1) or #centerOrderedIcons\n\tlocal nearestCenterIcon = centerOrderedIcons[centerPos]\n\tlocal usingNearestCenter = false\n\tif nearestCenterIcon and not nearestCenterIcon.hasRelocatedInOverflow then\n\t\tlocal ourNearestIcon = (isLeft and ourOrderedIcons[#ourOrderedIcons]) or (isRight and ourOrderedIcons[1])\n\t\tlocal centralNearestXPos = nearestCenterIcon.widget.AbsolutePosition.X\n\t\tlocal ourNearestXPos = ourNearestIcon.widget.AbsolutePosition.X\n\t\tlocal ourNearestXSize = Overflow.getWidth(ourNearestIcon)\n\t\tlocal centerBoundary = (isLeft and centralNearestXPos-BOUNDARY_GAP) or centralNearestXPos + Overflow.getWidth(nearestCenterIcon) + BOUNDARY_GAP\n\t\tlocal removeBoundary = (isLeft and ourNearestXPos + ourNearestXSize) or ourNearestXPos\n\t\tif isLeft then\n\t\t\tif centerBoundary < removeBoundary then\n\t\t\t\tnearestCenterIcon:align(\"Left\")\n\t\t\t\tnearestCenterIcon.hasRelocatedInOverflow = true\n\t\t\tend\n\t\telseif isRight then\n\t\t\tif centerBoundary > removeBoundary then\n\t\t\t\tnearestCenterIcon:align(\"Right\")\n\t\t\t\tnearestCenterIcon.hasRelocatedInOverflow = true\n\t\t\tend\n\t\tend\n\tend\n\t\n\t--[[\n\tThis updates the maximum size of the overflow menus\n\tThe menu determines its bounds from the smallest of either:\n\t \t1. The closest center-aligned icon (i.e. the boundary)\n\t \t2. The edge of the opposite overflow menu UNLESS...\n\t \t3. ... the edge exceeds more than half the screenGui\n\t--]]\n\tif overflowIcon then\n\t\tlocal menuBoundary = boundary\n\t\tlocal menu = overflowIcon:getInstance(\"Menu\")\n\t\tlocal holderXEndPos = holderXPos + holderXSize\n\t\tlocal menuWidth = holderXSize\n\t\tif menu and oppositeOverflowIcon then\n\t\t\tlocal oppositeWidget = oppositeOverflowIcon.widget\n\t\t\tlocal oppositeXPos = oppositeWidget.AbsolutePosition.X\n\t\t\tlocal oppositeXSize = Overflow.getWidth(oppositeOverflowIcon)\n\t\t\tlocal oppositeBoundary = (isLeft and oppositeXPos - BOUNDARY_GAP) or oppositeXPos + oppositeXSize + BOUNDARY_GAP\n\t\t\tlocal oppositeMenu = oppositeOverflowIcon:getInstance(\"Menu\")\n\t\t\tlocal isDominant = menu.AbsoluteCanvasSize.X >= oppositeMenu.AbsoluteCanvasSize.X\n\t\t\tif not usingNearestCenter then\n\t\t\t\tlocal halfwayXPos = holderXPos + holderXSize/2\n\t\t\t\tlocal halfwayBoundary = (isLeft and halfwayXPos - BOUNDARY_GAP/2) or halfwayXPos + BOUNDARY_GAP/2\n\t\t\t\tmenuBoundary = halfwayBoundary\n\t\t\t\tif isDominant then\n\t\t\t\t\tmenuBoundary = oppositeBoundary\n\t\t\t\tend\n\t\t\tend\n\t\t\tmenuWidth = (isLeft and menuBoundary - holderXPos) or (holderXEndPos - menuBoundary)\n\t\tend\n\t\tlocal currentMaxWidth = menu and menu:GetAttribute(\"MaxWidth\")\n\t\tmenuWidth = Utility.round(menuWidth)\n\t\tif menu and currentMaxWidth ~= menuWidth then\n\t\t\tmenu:SetAttribute(\"MaxWidth\", menuWidth)\n\t\tend\n\tend\n\n\t-- Parent ALL icons of that alignment into the overflow if at least on\n\t-- sibling exceeds the bounds.\n\t-- We calculate the the absolute position of icons instead of reading\n\t-- directly to determine where they would be if not within an overflow\n\tlocal joinOverflow = false\n\tlocal realXPositions = Overflow.getRealXPositions(alignment, ourOrderedIcons)\n\tfor i = #ourOrderedIcons, 1, -1 do\n\t\tlocal icon = ourOrderedIcons[i]\n\t\tlocal widgetX = Overflow.getWidth(icon)\n\t\tlocal xPos = realXPositions[icon.UID]\n\t\tif (isLeft and xPos + widgetX >= boundary) or (isRight and xPos <= boundary) then\n\t\t\tjoinOverflow = true\n\t\tend\n\tend\n\tfor i = #ourOrderedIcons, 1, -1 do\n\t\tlocal icon = ourOrderedIcons[i]\n\t\tlocal isOverflow = overflowIconUIDs[icon.UID]\n\t\tif not isOverflow then\n\t\t\tif joinOverflow and not icon.parentIconUID then\n\t\t\t\ticon:joinMenu(overflowIcon)\n\t\t\telseif not joinOverflow and icon.parentIconUID then\n\t\t\t\ticon:leave()\n\t\t\tend\n\t\tend\n\tend\n\t\n\t-- Hide the overflows when not in use\n\tif overflowIcon.isEnabled ~= joinOverflow then\n\t\toverflowIcon:setEnabled(joinOverflow)\n\tend\n\t\n\t-- Have the menus auto selected\n\tif overflowIcon.isEnabled and not overflowIcon.overflowAlreadyOpened then\n\t\toverflowIcon.overflowAlreadyOpened = true\n\t\toverflowIcon:select()\n\tend\n\nend\n\n\n\nreturn Overflow",
                                        "Children": [],
                                        "Archivable": true
                                    },
                                    {
                                        "Name": "Themes",
                                        "ClassName": "ModuleScript",
                                        "Source": "-- The functions here are dedicated solely to managing theme state\n-- and updating the appearance of instances to match that state.\n-- You don't need to use any of these functions, the useful ones\n-- have been abstracted as icon methods\n\n\n\n-- LOCAL\nlocal Themes = {}\nlocal Utility = require(script.Parent.Parent.Utility)\nlocal baseTheme = require(script.Default)\n\n\n\n-- FUNCTIONS\nfunction Themes.getThemeValue(stateGroup, instanceName, property, iconState)\n\tif stateGroup then\n\t\tfor _, detail in pairs(stateGroup) do\n\t\t\tlocal checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)\n\t\t\tif instanceName == checkingInstanceName and property == checkingPropertyName then\n\t\t\t\treturn checkingValue\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction Themes.getInstanceValue(instance, property)\n\tlocal success, value = pcall(function()\n\t\treturn instance[property]\n\tend)\n\tif not success then\n\t\tvalue = instance:GetAttribute(property)\n\tend\n\treturn value\nend\n\nfunction Themes.getRealInstance(instance)\n\tif not instance:GetAttribute(\"IsAClippedClone\") then\n\t\treturn\n\tend\n\tlocal originalInstance = instance:FindFirstChild(\"OriginalInstance\")\n\tif not originalInstance then\n\t\treturn\n\tend\n\treturn originalInstance.Value\nend\n\nfunction Themes.getClippedClone(instance)\n\tif not instance:GetAttribute(\"HasAClippedClone\") then\n\t\treturn\n\tend\n\tlocal clippedClone = instance:FindFirstChild(\"ClippedClone\")\n\tif not clippedClone then\n\t\treturn\n\tend\n\treturn clippedClone.Value\nend\n\nfunction Themes.refresh(icon, instance, specificProperty)\n\t-- Some instances such as notices need immediate refreshing upon creation as\n\t-- they're added in after the initial refresh period\n\tif specificProperty then\n\t\tlocal stateGroup = icon:getStateGroup()\n\t\tlocal value = Themes.getThemeValue(stateGroup, instance.Name, specificProperty) or Themes.getInstanceValue(instance, specificProperty)\n\t\tThemes.apply(icon, instance, specificProperty, value, true)\n\t\treturn\n\tend\n\t-- If no property is specified we update all properties that exist within\n\t-- the applied theme appearance\n\tlocal stateGroup = icon:getStateGroup()\n\tif not stateGroup then\n\t\treturn\n\tend\n\tlocal validInstances = {[instance.Name] = instance}\n\tfor _, child in pairs(instance:GetDescendants()) do\n\t\tlocal collective = child:GetAttribute(\"Collective\")\n\t\tif collective then\n\t\t\tvalidInstances[collective] = child\n\t\tend\n\t\tvalidInstances[child.Name] = child\n\tend\n\tfor _, detail in pairs(stateGroup) do\n\t\tlocal checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)\n\t\tlocal instanceToUpdate = validInstances[checkingInstanceName]\n\t\tif instanceToUpdate then\n\t\t\tThemes.apply(icon, instanceToUpdate.Name, checkingPropertyName, checkingValue, true)\n\t\tend\n\tend\n\treturn\nend\n\nfunction Themes.apply(icon, collectiveOrInstanceNameOrInstance, property, value, forceApply)\n\t-- This is responsible for **applying** appearance changes to instances within the icon\n\t-- however it IS NOT responsible for updating themes. Use :modifyTheme for that.\n\t-- This also calls callbacks given by :setBehaviour before applying these property changes\n\t-- to the given instances\n\tif icon.isDestroyed then\n\t\treturn\n\tend\n\tlocal instances\n\tlocal collectiveOrInstanceName = collectiveOrInstanceNameOrInstance\n\tif typeof(collectiveOrInstanceNameOrInstance) == \"Instance\" then\n\t\tinstances = {collectiveOrInstanceNameOrInstance}\n\t\tcollectiveOrInstanceName = collectiveOrInstanceNameOrInstance.Name\n\telse\n\t\tinstances = icon:getInstanceOrCollective(collectiveOrInstanceNameOrInstance)\n\tend\n\tlocal key = collectiveOrInstanceName..\"-\"..property\n\tlocal customBehaviour = icon.customBehaviours[key]\n\tfor _, instance in pairs(instances) do\n\t\tlocal clippedClone = Themes.getClippedClone(instance)\n\t\tif clippedClone then\n\t\t\t-- This means theme effects are applied to both the original\n\t\t\t-- instance and its clone (instead of just the instance).\n\t\t\t-- This is important for some properties such as position\n\t\t\t-- and size which might be dictated by the clone\n\t\t\ttable.insert(instances, clippedClone)\n\t\tend\n\tend\n\tfor _, instance in pairs(instances) do\n\t\tif property == \"Position\" and Themes.getClippedClone(instance) then\n\t\t\t-- The clone manages the position of the real instance so ignore\n\t\t\tcontinue\n\t\telseif property == \"Size\" and Themes.getRealInstance(instance) then\n\t\t\t-- The real instance manages the size of the clone so ignore\n\t\t\tcontinue\n\t\tend\n\t\tlocal currentValue = Themes.getInstanceValue(instance, property)\n\t\tif not forceApply and value == currentValue then\n\t\t\tcontinue\n\t\tend\n\t\tif customBehaviour then\n\t\t\tlocal newValue = customBehaviour(value, instance, property)\n\t\t\tif newValue ~= nil then\n\t\t\t\tvalue = newValue\n\t\t\tend\n\t\tend\n\t\tlocal success = pcall(function()\n\t\t\tinstance[property] = value\n\t\tend)\n\t\tif not success then\n\t\t\t-- If property is not a real property, we set\n\t\t\t-- the value as an attribute instead. This is useful\n\t\t\t-- for instance in :setWidth where we also want to\n\t\t\t-- specify a desired width for every state which can\n\t\t\t-- then be easily read by the widget element\n\t\t\tinstance:SetAttribute(property, value)\n\t\tend\n\tend\nend\n\nfunction Themes.getModifications(modifications)\n\tif typeof(modifications[1]) ~= \"table\" then\n\t\t-- This enables users to do :modifyTheme({a,b,c,d})\n\t\t-- in addition of :modifyTheme({{a,b,c,d}})\n\t\tmodifications = {modifications}\n\tend\n\treturn modifications\nend\n\nfunction Themes.merge(detail, modification, callback)\n\tlocal instanceName, property, value, stateName = table.unpack(modification)\n\tlocal checkingInstanceName, checkingPropertyName, _, checkingStateName = table.unpack(detail)\n\tif instanceName == checkingInstanceName and property == checkingPropertyName and Themes.statesMatch(stateName, checkingStateName) then\n\t\tdetail[3] = value\n\t\tif callback then\n\t\t\tcallback(detail)\n\t\tend\n\t\treturn true\n\tend\n\treturn false\nend\n\nfunction Themes.modify(icon, modifications, modificationsUID)\n\t-- This is what the 'old set' used to do (although for clarity that behaviour has now been\n\t-- split into two methods, .modifyTheme and .apply).\n\t-- modifyTheme is responsible for UPDATING the internal values within a theme for a particular\n\t-- state, then checking to see if the appearance of the icon needs to be updated.\n\t-- If no iconState is specified, the change is applied to both Deselected and Selected\n\t-- A modification can also be 'undone' using :removeModification and passing in\n\t-- the UID returned from this method\n\ttask.spawn(function()\n\t\tmodificationsUID = modificationsUID or Utility.generateUID()\n\t\tmodifications = Themes.getModifications(modifications)\n\t\tfor _, modification in pairs(modifications) do\n\t\t\tlocal instanceName, property, value, iconState = table.unpack(modification)\n\t\t\tif iconState == nil then\n\t\t\t\t-- If no state specified, apply to all states\n\t\t\t\tThemes.modify(icon, {instanceName, property, value, \"Selected\"}, modificationsUID)\n\t\t\t\tThemes.modify(icon, {instanceName, property, value, \"Viewing\"}, modificationsUID)\n\t\t\tend\n\t\t\tlocal chosenState = Utility.formatStateName(iconState or \"Deselected\")\n\t\t\tlocal stateGroup = icon:getStateGroup(chosenState)\n\t\t\tlocal function nowSetIt()\n\t\t\t\tif chosenState == icon.activeState then\n\t\t\t\t\tThemes.apply(icon, instanceName, property, value)\n\t\t\t\tend\n\t\t\tend\n\t\t\tlocal function updateRecord()\n\t\t\t\tfor stateName, detail in pairs(stateGroup) do\n\t\t\t\t\tlocal didMerge = Themes.merge(detail, modification, function(detail)\n\t\t\t\t\t\tdetail[5] = modificationsUID\n\t\t\t\t\t\tnowSetIt()\n\t\t\t\t\tend)\n\t\t\t\t\tif didMerge then\n\t\t\t\t\t\treturn\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tlocal detail = {instanceName, property, value, chosenState, modificationsUID}\n\t\t\t\ttable.insert(stateGroup, detail)\n\t\t\t\tnowSetIt()\n\t\t\tend\n\t\t\tupdateRecord()\n\t\tend\n\tend)\n\treturn modificationsUID\nend\n\nfunction Themes.remove(icon, modificationsUID)\n\tfor iconState, stateGroup in pairs(icon.appearance) do\n\t\tfor i = #stateGroup, 1, -1 do\n\t\t\tlocal detail = stateGroup[i]\n\t\t\tlocal checkingUID = detail[5]\n\t\t\tif checkingUID == modificationsUID then\n\t\t\t\ttable.remove(stateGroup, i)\n\t\t\tend\n\t\tend\n\tend\n\tThemes.rebuild(icon)\nend\n\nfunction Themes.removeWith(icon, instanceName, property, state)\n\tfor iconState, stateGroup in pairs(icon.appearance) do\n\t\tif state == iconState or not state then\n\t\t\tfor i = #stateGroup, 1, -1 do\n\t\t\t\tlocal detail = stateGroup[i]\n\t\t\t\tlocal detailName = detail[1]\n\t\t\t\tlocal detailProperty = detail[2]\n\t\t\t\tif detailName == instanceName and detailProperty == property then\n\t\t\t\t\ttable.remove(stateGroup, i)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tThemes.rebuild(icon)\nend\n\nfunction Themes.change(icon)\n\t-- This changes the theme to the appearance of whatever\n\t-- state is currently active\n\tlocal stateGroup = icon:getStateGroup()\n\tfor _, detail in pairs(stateGroup) do\n\t\tlocal instanceName, property, value = unpack(detail)\n\t\tThemes.apply(icon, instanceName, property, value)\n\tend\nend\n\nfunction Themes.set(icon, theme)\n\t-- This is responsible for processing the final appearance of a given theme (such as\n\t-- ensuring Deselected merge into missing Selected, saving that internal state,\n\t-- then checking to see if the appearance of the icon needs to be updated\n\tlocal themesJanitor = icon.themesJanitor\n\tthemesJanitor:clean()\n\tthemesJanitor:add(icon.stateChanged:Connect(function()\n\t\tThemes.change(icon)\n\tend))\n\tif typeof(theme) == \"Instance\" and theme:IsA(\"ModuleScript\") then\n\t\ttheme = require(theme)\n\tend\n\ticon.appliedTheme = theme\n\tThemes.rebuild(icon)\nend\n\nfunction Themes.statesMatch(state1, state2)\n\t-- States match if they have the same name OR if nil (because unspecified represents all states)\n\tlocal state1lower = (state1 and string.lower(state1))\n\tlocal state2lower = (state2 and string.lower(state2))\n\treturn state1lower == state2lower or not state1 or not state2\nend\n\nfunction Themes.rebuild(icon)\n\t-- A note for my future self: this code can be optimised further by\n\t-- converting appearance into a instanceName-property dictionary\n\t-- as apposed to an array of every potential change. When converting\n\t-- in the future, .modify and .apply would also have to be updated.\n\tlocal appliedTheme = icon.appliedTheme\n\tlocal statesArray = {\"Deselected\", \"Selected\", \"Viewing\"}\n\tlocal function generateTheme()\n\t\tfor _, stateName in pairs(statesArray) do\n\t\t\t-- This applies themes in layers\n\t\t\t-- The last layers take higher priority as they overwrite\n\t\t\t-- any duplicate earlier applied effects\n\t\t\tlocal stateAppearance = {}\n\t\t\tlocal function updateDetails(theme, incomingStateName)\n\t\t\t\t-- This ensures there's always a base 'default' layer\n\t\t\t\tif not theme then\n\t\t\t\t\treturn\n\t\t\t\tend\n\t\t\t\tfor _, detail in pairs(theme) do\n\t\t\t\t\tlocal modificationsUID = detail[5]\n\t\t\t\t\tlocal detailStateName = detail[4]\n\t\t\t\t\tif Themes.statesMatch(incomingStateName, detailStateName) then\n\t\t\t\t\t\tlocal key = detail[1]..\"-\"..detail[2]\n\t\t\t\t\t\tlocal newDetail = Utility.copyTable(detail)\n\t\t\t\t\t\tnewDetail[5] = modificationsUID\n\t\t\t\t\t\tstateAppearance[key] = newDetail\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\t-- First we apply the base theme (i.e. the Default module)\n\t\t\tif stateName == \"Selected\" then\n\t\t\t\tupdateDetails(baseTheme, \"Deselected\")\n\t\t\tend\n\t\t\tupdateDetails(baseTheme, \"Empty\")\n\t\t\tupdateDetails(baseTheme, stateName)\n\t\t\t-- Next we apply any custom themes by the games developer\n\t\t\tif appliedTheme ~= baseTheme then\n\t\t\t\tif stateName == \"Selected\" then\n\t\t\t\t\tupdateDetails(appliedTheme, \"Deselected\")\n\t\t\t\tend\n\t\t\t\tupdateDetails(baseTheme, \"Empty\")\n\t\t\t\tupdateDetails(appliedTheme, stateName)\n\t\t\tend\n\t\t\t-- Finally we apply any modifications that have already been made\n\t\t\t-- Modifiers are all the changes made using icon:modifyTheme(...)\n\t\t\tlocal alreadyAppliedTheme = {}\n\t\t\tlocal alreadyAppliedGroup = icon.appearance[stateName]\n\t\t\tif alreadyAppliedGroup then\n\t\t\t\tfor _, modifier in pairs(alreadyAppliedGroup) do\n\t\t\t\t\tlocal modificationsUID = modifier[5]\n\t\t\t\t\tif modificationsUID ~= nil then\n\t\t\t\t\t\tlocal modification = {modifier[1], modifier[2], modifier[3], stateName, modificationsUID}\n\t\t\t\t\t\ttable.insert(alreadyAppliedTheme, modification)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tupdateDetails(alreadyAppliedTheme, stateName)\n\t\t\t-- This now converts it into our final appearance\n\t\t\tlocal finalStateAppearance = {}\n\t\t\tfor _, detail in pairs(stateAppearance) do\n\t\t\t\ttable.insert(finalStateAppearance, detail)\n\t\t\tend\n\t\t\ticon.appearance[stateName] = finalStateAppearance\n\t\tend\n\t\tThemes.change(icon)\n\tend\n\tgenerateTheme()\nend\n\n\n\nreturn Themes",
                                        "Children": [
                                            {
                                                "Name": "Classic",
                                                "ClassName": "ModuleScript",
                                                "Source": "-- This is to provide backwards compatability with the old Roblox\n-- topbar while experiences transition over to the new topbar\n-- You don't need to apply this yourself, topbarplus automatically\n-- applies it if the old roblox topbar is detected\n\n\nreturn {\n\t{\"Selection\", \"Size\", UDim2.new(1, -6, 1, -5)},\n\t{\"Selection\", \"Position\", UDim2.new(0, 3, 0, 3)},\n\t\n\t{\"Widget\", \"MinimumWidth\", 32, \"Deselected\"},\n\t{\"Widget\", \"MinimumHeight\", 32, \"Deselected\"},\n\t{\"Widget\", \"BorderSize\", 0, \"Deselected\"},\n\t{\"IconCorners\", \"CornerRadius\", UDim.new(0, 9), \"Deselected\"},\n\t{\"IconButton\", \"BackgroundTransparency\", 0.5, \"Deselected\"},\n\t{\"IconLabel\", \"TextSize\", 14, \"Deselected\"},\n\t{\"Dropdown\", \"BackgroundTransparency\", 0.5, \"Deselected\"},\n\t{\"Notice\", \"Position\", UDim2.new(1, -12, 0, -3), \"Deselected\"},\n\t{\"Notice\", \"Size\", UDim2.new(0, 15, 0, 15), \"Deselected\"},\n\t{\"NoticeLabel\", \"TextSize\", 11, \"Deselected\"},\n\t\n\t{\"IconSpot\", \"BackgroundColor3\", Color3.fromRGB(0, 0, 0), \"Selected\"},\n\t{\"IconSpot\", \"BackgroundTransparency\", 0.702, \"Selected\"},\n\t{\"IconSpotGradient\", \"Enabled\", false, \"Selected\"},\n\t{\"IconOverlay\", \"BackgroundTransparency\", 0.97, \"Selected\"},\n\t\n}",
                                                "Children": [],
                                                "Archivable": true
                                            },
                                            {
                                                "Name": "Default",
                                                "ClassName": "ModuleScript",
                                                "Source": "-- Themes in v3 work simply by applying the value (agument[3])\n-- to the property (agument[2]) of an instance within the icon which\n-- matches the name of argument[1]. Argument[1] can also be used to\n-- specify a collection of instances with a corresponding 'collective'\n-- value. A colletive is simply an attribute applied to some instances\n-- within the icon to group them together (such as \"IconCorners\").\n-- If the property (argument[2]) does not exist within the instance,\n-- it will instead be applied as an attribute on the instance:\n-- (i.e. ``instance:SetAttribute(argument[2], [argument[3])``)\n-- Use argument[4] to specify a state: \"Deselected\", \"Selected\"\n-- or \"Viewing\". If argument[4] is empty the state will default\n-- to \"Deselected\".\n-- I've designed themes this way so you have full control over\n-- the appearance of the widget and its descendants\n\n\nreturn {\n\t\n\t-- When no state is specified the modification is applied to *all* states (Deselected, Selected and Viewing)\n\t{\"IconCorners\", \"CornerRadius\", UDim.new(1, 0)},\n\t{\"Selection\", \"RotationSpeed\", 1},\n\t{\"Selection\", \"Size\", UDim2.new(1, 0, 1, 1)},\n\t{\"Selection\", \"Position\", UDim2.new(0, 0, 0, 0)},\n\t{\"SelectionGradient\", \"Color\", ColorSequence.new({\n\t\tColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),\n\t\tColorSequenceKeypoint.new(1, Color3.fromRGB(86, 86, 86)),\n\t})},\n\t\n\t-- When the icon is deselected\n\t{\"IconImage\", \"Image\", \"\", \"Deselected\"},\n\t{\"IconLabel\", \"Text\", \"\", \"Deselected\"},\n\t{\"IconLabel\", \"Position\", UDim2.fromOffset(0, 0), \"Deselected\"}, -- 0, -1\n\t{\"Widget\", \"MinimumWidth\", 44, \"Deselected\"},\n\t{\"Widget\", \"MinimumHeight\", 44, \"Deselected\"},\n\t{\"Widget\", \"BorderSize\", 4, \"Deselected\"},\n\t{\"IconButton\", \"BackgroundColor3\", Color3.fromRGB(0, 0, 0), \"Deselected\"},\n\t{\"IconButton\", \"BackgroundTransparency\", 0.3, \"Deselected\"},\n\t{\"IconImageScale\", \"Value\", 0.5, \"Deselected\"},\n\t{\"IconImageCorner\", \"CornerRadius\", UDim.new(0, 0), \"Deselected\"},\n\t{\"IconImage\", \"ImageColor3\", Color3.fromRGB(255, 255, 255), \"Deselected\"},\n\t{\"IconImage\", \"ImageTransparency\", 0, \"Deselected\"},\n\t{\"IconLabel\", \"FontFace\", Font.new(\"rbxasset://fonts/families/GothamSSm.json\", Enum.FontWeight.Medium, Enum.FontStyle.Normal), \"Deselected\"},\n\t{\"IconLabel\", \"TextSize\", 16, \"Deselected\"},\n\t{\"IconSpot\", \"BackgroundTransparency\", 1, \"Deselected\"},\n\t{\"IconOverlay\", \"BackgroundTransparency\", 0.925, \"Deselected\"},\n\t{\"IconSpotGradient\", \"Enabled\", false, \"Deselected\"},\n\t{\"IconGradient\", \"Enabled\", false, \"Deselected\"},\n\t{\"ClickRegion\", \"Active\", true, \"Deselected\"},  -- This is set to false within scrollers to ensure scroller can be dragged on mobile\n\t{\"Menu\", \"Active\", false, \"Deselected\"},\n\t{\"ContentsList\", \"HorizontalAlignment\", Enum.HorizontalAlignment.Center, \"Deselected\"},\n\t{\"Dropdown\", \"BackgroundColor3\", Color3.fromRGB(0, 0, 0), \"Deselected\"},\n\t{\"Dropdown\", \"BackgroundTransparency\", 0.3, \"Deselected\"},\n\t{\"Dropdown\", \"MaxIcons\", 4, \"Deselected\"},\n\t{\"Menu\", \"MaxIcons\", 4, \"Deselected\"},\n\t{\"Notice\", \"Position\", UDim2.new(1, -12, 0, -1), \"Deselected\"},\n\t{\"Notice\", \"Size\", UDim2.new(0, 20, 0, 20), \"Deselected\"},\n\t{\"NoticeLabel\", \"TextSize\", 13, \"Deselected\"},\n\t{\"PaddingLeft\", \"Size\", UDim2.new(0, 9, 1, 0), \"Deselected\"},\n\t{\"PaddingRight\", \"Size\", UDim2.new(0, 11, 1, 0), \"Deselected\"},\n\t\n\t-- When the icon is selected\n\t-- Selected also inherits everything from Deselected if nothing is set\n\t{\"IconSpot\", \"BackgroundTransparency\", 0.7, \"Selected\"},\n\t{\"IconSpot\", \"BackgroundColor3\", Color3.fromRGB(255, 255, 255), \"Selected\"},\n\t{\"IconSpotGradient\", \"Enabled\", true, \"Selected\"},\n\t{\"IconSpotGradient\", \"Rotation\", 45, \"Selected\"},\n\t{\"IconSpotGradient\", \"Color\", ColorSequence.new(Color3.fromRGB(96, 98, 100), Color3.fromRGB(77, 78, 80)), \"Selected\"},\n\t\n\t\n\t-- When a cursor is hovering above, a controller highlighting, or touchpad (mobile) pressing (but not released)\n\t--{\"IconSpot\", \"BackgroundTransparency\", 0.75, \"Viewing\"},\n\t\n}",
                                                "Children": [],
                                                "Archivable": true
                                            }
                                        ],
                                        "Archivable": true
                                    }
                                ],
                                "ClassName": "Folder"
                            },
                            {
                                "Name": "Reference",
                                "ClassName": "ModuleScript",
                                "Source": "-- This module enables you to place Icon wherever you like within the data model while\r\n-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it\r\n-- This is necessary to prevent two TopbarPlus applications initiating at runtime which would\r\n-- cause icons to overlap with each other\r\n\r\nlocal replicatedStorage = game:GetService(\"ReplicatedStorage\")\r\nlocal Reference = {}\r\nReference.objectName = \"TopbarPlusReference\"\r\n\r\nfunction Reference.addToReplicatedStorage()\r\n\tlocal existingItem = replicatedStorage:FindFirstChild(Reference.objectName)\r\n    if existingItem then\r\n        return false\r\n    end\r\n    local objectValue = Instance.new(\"ObjectValue\")\r\n\tobjectValue.Name = Reference.objectName\r\n    objectValue.Value = script.Parent\r\n    objectValue.Parent = replicatedStorage\r\n    return objectValue\r\nend\r\n\r\nfunction Reference.getObject()\r\n\tlocal objectValue = replicatedStorage:FindFirstChild(Reference.objectName)\r\n    if objectValue then\r\n        return objectValue\r\n    end\r\n    return false\r\nend\r\n\r\nreturn Reference",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "VERSION",
                                "ClassName": "ModuleScript",
                                "Source": "return \"v3.0.2\"",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "Utility",
                                "ClassName": "ModuleScript",
                                "Source": "-- Just generic utility functions which I use and repeat across all my projects\n\n\n\n-- LOCAL\nlocal Utility = {}\nlocal Players = game:GetService(\"Players\")\nlocal localPlayer = Players.LocalPlayer\n\n\n\n-- FUNCTIONS\nfunction Utility.createStagger(delayTime, callback, delayInitially)\n\t-- This creates and returns a function which when called\n\t-- acts identically to callback, however will only be called\n\t-- for a maximum of once per delayTime. If the returned function\n\t-- is called more than once during the delayTime, then it will\n\t-- wait until the expiryTime then perform another recall.\n\t-- This is useful for visual interfaces and effects which may be\n\t-- triggered multiple times within a frame or short period, but which\n\t-- we don't necessary need to (for performance reasons).\n\tlocal staggerActive = false\n\tlocal multipleCalls = false\n\tif not delayTime or delayTime == 0 then\n\t\t-- We make 0.01 instead of 0 because devices can now run at\n\t\t-- different frame rates\n\t\tdelayTime = 0.01\n\tend\n\tlocal function staggeredCallback(...)\n\t\tif staggerActive then\n\t\t\tmultipleCalls = true\n\t\t\treturn\n\t\tend\n\t\tlocal packedArgs = table.pack(...)\n\t\tstaggerActive = true\n\t\tmultipleCalls = false\n\t\ttask.spawn(function()\n\t\t\tif delayInitially then\n\t\t\t\ttask.wait(delayTime)\n\t\t\tend\n\t\t\tcallback(table.unpack(packedArgs))\n\t\tend)\n\t\ttask.delay(delayTime, function()\n\t\t\tstaggerActive = false\n\t\t\tif multipleCalls then\n\t\t\t\t-- This means it has been called at least once during\n\t\t\t\t-- the stagger period, so call again\n\t\t\t\tstaggeredCallback(table.unpack(packedArgs))\n\t\t\tend\n\t\tend)\n\tend\n\treturn staggeredCallback\nend\n\nfunction Utility.round(n)\n\t-- Credit to Darkmist101 for this\n\treturn math.floor(n + 0.5)\nend\n\nfunction Utility.reverseTable(t)\n\tfor i = 1, math.floor(#t/2) do\n\t\tlocal j = #t - i + 1\n\t\tt[i], t[j] = t[j], t[i]\n\tend\nend\n\nfunction Utility.copyTable(t)\n\t-- Credit to Stephen Leitnick (September 13, 2017) for this function from TableUtil\n\tassert(type(t) == \"table\", \"First argument must be a table\")\n\tlocal tCopy = table.create(#t)\n\tfor k,v in pairs(t) do\n\t\tif (type(v) == \"table\") then\n\t\t\ttCopy[k] = Utility.copyTable(v)\n\t\telse\n\t\t\ttCopy[k] = v\n\t\tend\n\tend\n\treturn tCopy\nend\n\nlocal validCharacters = {\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"0\",\"<\",\">\",\"?\",\"@\",\"{\",\"}\",\"[\",\"]\",\"!\",\"(\",\")\",\"=\",\"+\",\"~\",\"#\"}\nfunction Utility.generateUID(length)\n\tlength = length or 8\n\tlocal UID = \"\"\n\tlocal list = validCharacters\n\tlocal total = #list\n\tfor i = 1, length do\n\t\tlocal randomCharacter = list[math.random(1, total)]\n\t\tUID = UID..randomCharacter\n\tend\n\treturn UID\nend\n\nlocal instanceTrackers = {}\nfunction Utility.setVisible(instance, bool, sourceUID)\n\t-- This effectively works like a buff object but\n\t-- incredibly simplified. It stacks false values\n\t-- so that if there is more than more than, the \n\t-- instance remains hidden even if set visible true\n\tlocal tracker = instanceTrackers[instance]\n\tif not tracker then\n\t\ttracker = {}\n\t\tinstanceTrackers[instance] = tracker\n\t\tinstance.Destroying:Once(function()\n\t\t\tinstanceTrackers[instance] = nil\n\t\tend)\n\tend\n\tif not bool then\n\t\ttracker[sourceUID] = true\n\telse\n\t\ttracker[sourceUID] = nil\n\tend\n\tlocal isVisible = bool\n\tif bool then\n\t\tfor sourceUID, _ in pairs(tracker) do\n\t\t\tisVisible = false\n\t\t\tbreak\n\t\tend\n\tend\n\tinstance.Visible = isVisible\nend\n\nfunction Utility.formatStateName(incomingStateName)\n\treturn string.upper(string.sub(incomingStateName, 1, 1))..string.lower(string.sub(incomingStateName, 2))\nend\n\nfunction Utility.localPlayerRespawned(callback)\n\t-- The client localscript may be located under a ScreenGui with ResetOnSpawn set to true\n\t-- In these scenarios, traditional methods like CharacterAdded won't be called by the\n\t-- time the localscript has been destroyed, therefore we listen for removing instead\n\t-- If humanoid and health == 0, then reset/died normally, else was\n\t-- forcefully reset via a method such as LoadCharacter\n\t-- We wrap this behaviour in case any additional quirks need to be accounted for\n\tlocalPlayer.CharacterRemoving:Connect(callback)\nend\n\nfunction Utility.getClippedContainer(screenGui)\n\t-- We always want clipped items to display in front hence\n\t-- why we have this\n\tlocal clippedContainer = screenGui:FindFirstChild(\"ClippedContainer\")\n\tif not clippedContainer then\n\t\tclippedContainer = Instance.new(\"Folder\")\n\t\tclippedContainer.Name = \"ClippedContainer\"\n\t\tclippedContainer.Parent = screenGui\n\tend\n\treturn clippedContainer\nend\n\nlocal Janitor = require(script.Parent.Packages.Janitor)\nlocal GuiService = game:GetService(\"GuiService\")\nfunction Utility.clipOutside(icon, instance)\n\tlocal cloneJanitor = icon.janitor:add(Janitor.new())\n\tinstance.Destroying:Once(function()\n\t\tcloneJanitor:Destroy()\n\tend)\n\ticon.janitor:add(instance)\n\n\tlocal originalParent = instance.Parent\n\tlocal clone = cloneJanitor:add(Instance.new(\"Frame\"))\n\tclone:SetAttribute(\"IsAClippedClone\", true)\n\tclone.Name = instance.Name\n\tclone.AnchorPoint = instance.AnchorPoint\n\tclone.Size = instance.Size\n\tclone.Position = instance.Position\n\tclone.BackgroundTransparency = 1\n\tclone.LayoutOrder = instance.LayoutOrder\n\tclone.Parent = originalParent\n\n\tlocal valueInstance = Instance.new(\"ObjectValue\")\n\tvalueInstance.Name = \"OriginalInstance\"\n\tvalueInstance.Value = instance\n\tvalueInstance.Parent = clone\n\n\tlocal valueInstanceCopy = valueInstance:Clone()\n\tinstance:SetAttribute(\"HasAClippedClone\", true)\n\tvalueInstanceCopy.Name = \"ClippedClone\"\n\tvalueInstanceCopy.Value = clone\n\tvalueInstanceCopy.Parent = instance\n\n\tlocal screenGui\n\tlocal function updateScreenGui()\n\t\tlocal originalScreenGui = originalParent:FindFirstAncestorWhichIsA(\"ScreenGui\")\n\t\tscreenGui = if string.match(originalScreenGui.Name, \"Clipped\") then originalScreenGui else originalScreenGui.Parent[originalScreenGui.Name..\"Clipped\"]\n\t\tinstance.AnchorPoint = Vector2.new(0, 0)\n\t\tinstance.Parent = Utility.getClippedContainer(screenGui)\n\tend\n\tcloneJanitor:add(icon.alignmentChanged:Connect(updateScreenGui))\n\tupdateScreenGui()\n\n\t-- Lets copy over children that modify size\n\tfor _, child in pairs(instance:GetChildren()) do\n\t\tif child:IsA(\"UIAspectRatioConstraint\") then\n\t\t\tchild:Clone().Parent = clone\n\t\tend\n\tend\n\n\t-- If the icon is hidden, its important we are too (as\n\t-- setting a parent to visible = false no longer makes\n\t-- this hidden)\n\tlocal widget = icon.widget\n\tlocal isOutsideParent = false\n\tlocal ignoreVisibilityUpdater = instance:GetAttribute(\"IgnoreVisibilityUpdater\")\n\tlocal function updateVisibility()\n\t\tif ignoreVisibilityUpdater then\n\t\t\treturn\n\t\tend\n\t\tlocal isVisible = widget.Visible\n\t\t\n\t\tif isOutsideParent then\n\t\t\tisVisible = false\n\t\tend\n\t\tUtility.setVisible(instance, isVisible, \"ClipHandler\")\n\tend\n\tcloneJanitor:add(widget:GetPropertyChangedSignal(\"Visible\"):Connect(updateVisibility))\n\n\tlocal previousScroller\n\tlocal Icon = require(icon.iconModule)\n\tlocal function checkIfOutsideParentXBounds()\n\t\t-- Defer so that roblox's properties reflect their true values\n\t\ttask.defer(function()\n\t\t\t-- If the instance is within a parent item (such as a dropdown or menu)\n\t\t\t-- then we hide it if it exceeds the bounds of that parent\n\t\t\tlocal parentInstance\n\t\t\tlocal ourUID = icon.UID\n\t\t\tlocal nextIconUID = ourUID\n\t\t\tlocal shouldClipToParent = instance:GetAttribute(\"ClipToJoinedParent\")\n\t\t\tif shouldClipToParent then\n\t\t\t\tfor i = 1, 10 do -- This is safer than while true do and should never be > 4 parents\n\t\t\t\t\tlocal nextIcon = Icon.getIconByUID(nextIconUID)\n\t\t\t\t\tif not nextIcon then\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\t\tlocal nextParentInstance = nextIcon.joinedFrame\n\t\t\t\t\tnextIconUID = nextIcon.parentIconUID\n\t\t\t\t\tif not nextParentInstance then\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\t\tparentInstance = nextParentInstance\n\t\t\t\tend\n\t\t\tend\n\t\t\tif not parentInstance then\n\t\t\t\tisOutsideParent = false\n\t\t\t\tupdateVisibility()\n\t\t\t\treturn\n\t\t\tend\n\t\t\tlocal pos = instance.AbsolutePosition\n\t\t\tlocal halfSize = instance.AbsoluteSize/2\n\t\t\tlocal parentPos = parentInstance.AbsolutePosition\n\t\t\tlocal parentSize = parentInstance.AbsoluteSize\n\t\t\tlocal posHalf = (pos + halfSize)\n\t\t\tlocal exceededLeft = posHalf.X < parentPos.X\n\t\t\tlocal exceededRight = posHalf.X > (parentPos.X + parentSize.X)\n\t\t\tlocal exceededTop = posHalf.Y < parentPos.Y\n\t\t\tlocal exceededBottom = posHalf.Y > (parentPos.Y + parentSize.Y)\n\t\t\tlocal hasExceeded = exceededLeft or exceededRight or exceededTop or exceededBottom\n\t\t\tif hasExceeded ~= isOutsideParent then\n\t\t\t\tisOutsideParent = hasExceeded\n\t\t\t\tupdateVisibility()\n\t\t\tend\n\t\t\tif parentInstance:IsA(\"ScrollingFrame\") and previousScroller ~= parentInstance then\n\t\t\t\tpreviousScroller = parentInstance\n\t\t\t\tlocal connection = parentInstance:GetPropertyChangedSignal(\"AbsoluteWindowSize\"):Connect(function()\n\t\t\t\t\tcheckIfOutsideParentXBounds()\n\t\t\t\tend)\n\t\t\t\tcloneJanitor:add(connection, \"Disconnect\", \"TrackUtilityScroller-\"..ourUID)\n\t\t\tend\n\t\tend)\n\tend\n\n\tlocal camera = workspace.CurrentCamera\n\tlocal additionalOffsetX = instance:GetAttribute(\"AdditionalOffsetX\") or 0\n\tlocal function trackProperty(property)\n\t\tlocal absoluteProperty = \"Absolute\"..property\n\t\tlocal function updateProperty()\n\t\t\tlocal cloneValue = clone[absoluteProperty]\n\t\t\tlocal absoluteValue = UDim2.fromOffset(cloneValue.X, cloneValue.Y)\n\t\t\tif property == \"Position\" then\n\n\t\t\t\t-- This binds the instances within the bounds of the screen\n\t\t\t\tlocal SIDE_PADDING = 4\n\t\t\t\tlocal limitX = camera.ViewportSize.X - instance.AbsoluteSize.X - SIDE_PADDING\n\t\t\t\tlocal inputX = absoluteValue.X.Offset\n\t\t\t\tif inputX < SIDE_PADDING then\n\t\t\t\t\tinputX = SIDE_PADDING\n\t\t\t\telseif inputX > limitX then\n\t\t\t\t\tinputX = limitX\n\t\t\t\tend\n\t\t\t\tabsoluteValue = UDim2.fromOffset(inputX, absoluteValue.Y.Offset)\n\n\t\t\t\t-- AbsolutePosition does not perfectly match with TopbarInsets enabled\n\t\t\t\t-- This corrects this\n\t\t\t\tlocal topbarInset = GuiService.TopbarInset\n\t\t\t\tlocal viewportWidth = workspace.CurrentCamera.ViewportSize.X\n\t\t\t\tlocal guiWidth = screenGui.AbsoluteSize.X\n\t\t\t\tlocal guiOffset = screenGui.AbsolutePosition.X\n\t\t\t\tlocal widthDifference = guiOffset - topbarInset.Min.X\n\t\t\t\tlocal oldTopbarCenterOffset = 0--widthDifference/30 -- I have no idea why this works, it just does\n\t\t\t\tlocal offsetX = if icon.isOldTopbar then guiOffset else viewportWidth - guiWidth - oldTopbarCenterOffset\n\t\t\t\t\n\t\t\t\t-- Also add additionalOffset\n\t\t\t\toffsetX -= additionalOffsetX\n\t\t\t\tabsoluteValue += UDim2.fromOffset(-offsetX, topbarInset.Height)\n\n\t\t\t\t-- Finally check if within its direct parents bounds\n\t\t\t\tcheckIfOutsideParentXBounds()\n\n\t\t\tend\n\t\t\tinstance[property] = absoluteValue\n\t\tend\n\t\t\n\t\t-- This defer is essential as the listener may be in a different screenGui to the actor\n\t\tlocal updatePropertyStaggered = Utility.createStagger(0.01, updateProperty)\n\t\tcloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyStaggered))\n\t\t\n\t\t-- This is to patch a weirddddd bug with ScreenGuis with SreenInsets set to\n\t\t-- 'TopbarSafeInsets'. For some reason the absolute position of gui instances\n\t\t-- within this type of screenGui DO NOT accurately update to match their new\n\t\t-- real world position; instead they jump around almost randomly for a few frames.\n\t\t-- I have spent way too many hours trying to solve this bug, I think the only way\n\t\t-- for the time being is to not use ScreenGuis with TopbarSafeInsets, but I don't\n\t\t-- have time to redesign the entire system around that at the moment.\n\t\t-- Here's a GIF of this bug: https://i.imgur.com/VitHdC1.gif\n\t\tlocal updatePropertyPatch = Utility.createStagger(0.5, updateProperty, true)\n\t\tcloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyPatch))\n\t\t\n\tend\n\ttask.delay(0.1, checkIfOutsideParentXBounds)\n\tcheckIfOutsideParentXBounds()\n\tupdateVisibility()\n\ttrackProperty(\"Position\")\n\t\n\t-- Track visiblity changes\n\tcloneJanitor:add(instance:GetPropertyChangedSignal(\"Visible\"):Connect(function()\n\t\t--print(\"Visiblity changed:\", instance, clone, instance.Visible)\n\t\t--clone.Visible = instance.Visible\n\tend))\n\n\t-- To ensure accurate positioning, it's important the clone also remains the same size as the instance\n\tlocal shouldTrackCloneSize = instance:GetAttribute(\"TrackCloneSize\")\n\tif shouldTrackCloneSize then\n\t\ttrackProperty(\"Size\")\n\telse\n\t\tcloneJanitor:add(instance:GetPropertyChangedSignal(\"AbsoluteSize\"):Connect(function()\n\t\t\tlocal absolute = instance.AbsoluteSize\n\t\t\tclone.Size = UDim2.fromOffset(absolute.X, absolute.Y)\n\t\tend))\n\tend\n\n\treturn clone\nend\n\nfunction Utility.joinFeature(originalIcon, parentIcon, iconsArray, scrollingFrameOrFrame)\n\n\t-- This is resonsible for moving the icon under a feature like a dropdown\n\tlocal joinJanitor = originalIcon.joinJanitor\n\tjoinJanitor:clean()\n\tif not scrollingFrameOrFrame then\n\t\toriginalIcon:leave()\n\t\treturn\n\tend\n\toriginalIcon.parentIconUID = parentIcon.UID\n\toriginalIcon.joinedFrame = scrollingFrameOrFrame\n\tlocal function updateAlignent()\n\t\tlocal parentAlignment = parentIcon.alignment\n\t\tif parentAlignment == \"Center\" then\n\t\t\tparentAlignment = \"Left\"\n\t\tend\n\t\toriginalIcon:setAlignment(parentAlignment, true)\n\tend\n\tjoinJanitor:add(parentIcon.alignmentChanged:Connect(updateAlignent))\n\tupdateAlignent()\n\toriginalIcon:modifyTheme({\"IconButton\", \"BackgroundTransparency\", 1}, \"JoinModification\")\n\toriginalIcon:modifyTheme({\"ClickRegion\", \"Active\", false}, \"JoinModification\")\n\tif parentIcon.childModifications then\n\t\t-- We defer so that the default values (such as dropdown\n\t\t-- minimum width can be applied before any custom\n\t\t-- child modifications from the user)\n\t\ttask.defer(function()\n\t\t\toriginalIcon:modifyTheme(parentIcon.childModifications, parentIcon.childModificationsUID)\n\t\tend)\n\tend\n\t--\n\tlocal clickRegion = originalIcon:getInstance(\"ClickRegion\")\n\tlocal function makeSelectable()\n\t\tclickRegion.Selectable = parentIcon.isSelected\n\tend\n\tjoinJanitor:add(parentIcon.toggled:Connect(makeSelectable))\n\ttask.defer(makeSelectable)\n\tjoinJanitor:add(function()\n\t\tclickRegion.Selectable = true\n\tend)\n\t--\n\n\t-- We track icons in arrays and dictionaries using their UID instead of the icon\n\t-- itself to prevent heavy cyclical tables when printing the icons\n\tlocal originalIconUID = originalIcon.UID\n\ttable.insert(iconsArray, originalIconUID)\n\tparentIcon:autoDeselect(false)\n\tparentIcon.childIconsDict[originalIconUID] = true\n\tif not parentIcon.isEnabled then\n\t\tparentIcon:setEnabled(true)\n\tend\n\toriginalIcon.joinedParent:Fire(parentIcon)\n\n\t-- This is responsible for removing it from that feature and updating\n\t-- their parent icon so its informed of the icon leaving it\n\tjoinJanitor:add(function()\n\t\tlocal joinedFrame = originalIcon.joinedFrame\n\t\tif not joinedFrame then\n\t\t\treturn\n\t\tend\n\t\tfor i, iconUID in pairs(iconsArray) do\n\t\t\tif iconUID == originalIconUID then\n\t\t\t\ttable.remove(iconsArray, i)\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tlocal Icon = require(originalIcon.iconModule)\n\t\tlocal parentIcon = Icon.getIconByUID(originalIcon.parentIconUID)\n\t\tif not parentIcon then\n\t\t\treturn\n\t\tend\n\t\toriginalIcon:setAlignment(originalIcon.originalAlignment)\n\t\toriginalIcon.parentIconUID = false\n\t\toriginalIcon.joinedFrame = false\n\t\toriginalIcon:setBehaviour(\"IconButton\", \"BackgroundTransparency\", nil, true)\n\t\toriginalIcon:removeModification(\"JoinModification\")\n\t\t\n\t\tlocal parentHasNoChildren = true\n\t\tlocal parentChildIcons = parentIcon.childIconsDict\n\t\tparentChildIcons[originalIconUID] = nil\n\t\tfor childIconUID, _ in pairs(parentChildIcons) do\n\t\t\tparentHasNoChildren = false\n\t\t\tbreak\n\t\tend\n\t\tif parentHasNoChildren and not parentIcon.isAnOverflow then\n\t\t\tparentIcon:setEnabled(false)\n\t\tend\n\t\tupdateAlignent()\n\n\tend)\n\nend\n\n\n\nreturn Utility",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "Packages",
                                "Archivable": true,
                                "Children": [
                                    {
                                        "Name": "GoodSignal",
                                        "ClassName": "ModuleScript",
                                        "Source": "--------------------------------------------------------------------------------\r\n--               Batched Yield-Safe Signal Implementation                     --\r\n-- This is a Signal class which has effectively identical behavior to a       --\r\n-- normal RBXScriptSignal, with the only difference being a couple extra      --\r\n-- stack frames at the bottom of the stack trace when an error is thrown.     --\r\n-- This implementation caches runner coroutines, so the ability to yield in   --\r\n-- the signal handlers comes at minimal extra cost over a naive signal        --\r\n-- implementation that either always or never spawns a thread.                --\r\n--                                                                            --\r\n-- API:                                                                       --\r\n--   local Signal = require(THIS MODULE)                                      --\r\n--   local sig = Signal.new()                                                 --\r\n--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --\r\n--   sig:Fire(arg1, arg2, ...)                                                --\r\n--   connection:Disconnect()                                                  --\r\n--   sig:DisconnectAll()                                                      --\r\n--   local arg1, arg2, ... = sig:Wait()                                       --\r\n--                                                                            --\r\n-- Licence:                                                                   --\r\n--   Licenced under the MIT licence.                                          --\r\n--                                                                            --\r\n-- Authors:                                                                   --\r\n--   stravant - July 31st, 2021 - Created the file.                           --\r\n--------------------------------------------------------------------------------\r\n\r\n-- The currently idle thread to run the next handler on\r\nlocal freeRunnerThread = nil\r\n\r\n-- Function which acquires the currently idle handler runner thread, runs the\r\n-- function fn on it, and then releases the thread, returning it to being the\r\n-- currently idle one.\r\n-- If there was a currently idle runner thread already, that's okay, that old\r\n-- one will just get thrown and eventually GCed.\r\nlocal function acquireRunnerThreadAndCallEventHandler(fn, ...)\r\n\tlocal acquiredRunnerThread = freeRunnerThread\r\n\tfreeRunnerThread = nil\r\n\tfn(...)\r\n\t-- The handler finished running, this runner thread is free again.\r\n\tfreeRunnerThread = acquiredRunnerThread\r\nend\r\n\r\n-- Coroutine runner that we create coroutines of. The coroutine can be \r\n-- repeatedly resumed with functions to run followed by the argument to run\r\n-- them with.\r\nlocal function runEventHandlerInFreeThread()\r\n\t-- Note: We cannot use the initial set of arguments passed to\r\n\t-- runEventHandlerInFreeThread for a call to the handler, because those\r\n\t-- arguments would stay on the stack for the duration of the thread's\r\n\t-- existence, temporarily leaking references. Without access to raw bytecode\r\n\t-- there's no way for us to clear the \"...\" references from the stack.\r\n\twhile true do\r\n\t\tacquireRunnerThreadAndCallEventHandler(coroutine.yield())\r\n\tend\r\nend\r\n\r\n-- Connection class\r\nlocal Connection = {}\r\nConnection.__index = Connection\r\n\r\nfunction Connection.new(signal, fn)\r\n\treturn setmetatable({\r\n\t\t_connected = true,\r\n\t\t_signal = signal,\r\n\t\t_fn = fn,\r\n\t\t_next = false,\r\n\t}, Connection)\r\nend\r\n\r\nfunction Connection:Disconnect()\r\n\tself._connected = false\r\n\r\n\t-- Unhook the node, but DON'T clear it. That way any fire calls that are\r\n\t-- currently sitting on this node will be able to iterate forwards off of\r\n\t-- it, but any subsequent fire calls will not hit it, and it will be GCed\r\n\t-- when no more fire calls are sitting on it.\r\n\tif self._signal._handlerListHead == self then\r\n\t\tself._signal._handlerListHead = self._next\r\n\telse\r\n\t\tlocal prev = self._signal._handlerListHead\r\n\t\twhile prev and prev._next ~= self do\r\n\t\t\tprev = prev._next\r\n\t\tend\r\n\t\tif prev then\r\n\t\t\tprev._next = self._next\r\n\t\tend\r\n\tend\r\nend\r\nConnection.Destroy = Connection.Disconnect\r\n\r\n-- Make Connection strict\r\nsetmetatable(Connection, {\r\n\t__index = function(tb, key)\r\n\t\terror((\"Attempt to get Connection::%s (not a valid member)\"):format(tostring(key)), 2)\r\n\tend,\r\n\t__newindex = function(tb, key, value)\r\n\t\terror((\"Attempt to set Connection::%s (not a valid member)\"):format(tostring(key)), 2)\r\n\tend\r\n})\r\n\r\n-- Signal class\r\nlocal Signal = {}\r\nSignal.__index = Signal\r\n\r\nfunction Signal.new()\r\n\treturn setmetatable({\r\n\t\t_handlerListHead = false,\r\n\t}, Signal)\r\nend\r\n\r\nfunction Signal:Connect(fn)\r\n\tlocal connection = Connection.new(self, fn)\r\n\tif self._handlerListHead then\r\n\t\tconnection._next = self._handlerListHead\r\n\t\tself._handlerListHead = connection\r\n\telse\r\n\t\tself._handlerListHead = connection\r\n\tend\r\n\treturn connection\r\nend\r\n\r\n-- Disconnect all handlers. Since we use a linked list it suffices to clear the\r\n-- reference to the head handler.\r\nfunction Signal:DisconnectAll()\r\n\tself._handlerListHead = false\r\nend\r\nSignal.Destroy = Signal.DisconnectAll\r\n\r\n-- Signal:Fire(...) implemented by running the handler functions on the\r\n-- coRunnerThread, and any time the resulting thread yielded without returning\r\n-- to us, that means that it yielded to the Roblox scheduler and has been taken\r\n-- over by Roblox scheduling, meaning we have to make a new coroutine runner.\r\nfunction Signal:Fire(...)\r\n\tlocal item = self._handlerListHead\r\n\twhile item do\r\n\t\tif item._connected then\r\n\t\t\tif not freeRunnerThread then\r\n\t\t\t\tfreeRunnerThread = coroutine.create(runEventHandlerInFreeThread)\r\n\t\t\t\t-- Get the freeRunnerThread to the first yield\r\n\t\t\t\tcoroutine.resume(freeRunnerThread)\r\n\t\t\tend\r\n\t\t\ttask.spawn(freeRunnerThread, item._fn, ...)\r\n\t\tend\r\n\t\titem = item._next\r\n\tend\r\nend\r\n\r\n-- Implement Signal:Wait() in terms of a temporary connection using\r\n-- a Signal:Connect() which disconnects itself.\r\nfunction Signal:Wait()\r\n\tlocal waitingCoroutine = coroutine.running()\r\n\tlocal cn;\r\n\tcn = self:Connect(function(...)\r\n\t\tcn:Disconnect()\r\n\t\ttask.spawn(waitingCoroutine, ...)\r\n\tend)\r\n\treturn coroutine.yield()\r\nend\r\n\r\n-- Implement Signal:Once() in terms of a connection which disconnects\r\n-- itself before running the handler.\r\nfunction Signal:Once(fn)\r\n\tlocal cn;\r\n\tcn = self:Connect(function(...)\r\n\t\tif cn._connected then\r\n\t\t\tcn:Disconnect()\r\n\t\tend\r\n\t\tfn(...)\r\n\tend)\r\n\treturn cn\r\nend\r\n\r\n-- Make signal strict\r\nsetmetatable(Signal, {\r\n\t__index = function(tb, key)\r\n\t\terror((\"Attempt to get Signal::%s (not a valid member)\"):format(tostring(key)), 2)\r\n\tend,\r\n\t__newindex = function(tb, key, value)\r\n\t\terror((\"Attempt to set Signal::%s (not a valid member)\"):format(tostring(key)), 2)\r\n\tend\r\n})\r\n\r\nreturn Signal",
                                        "Children": [],
                                        "Archivable": true
                                    },
                                    {
                                        "Name": "Janitor",
                                        "ClassName": "ModuleScript",
                                        "Source": "--[[\r\n-------------------------------------\r\nThis package was modified by ForeverHD.\r\n\r\nPACKAGE MODIFICATIONS:\r\n\t1. Added pascalCase aliases for all methods\r\n\t2. Modified behaviour of :add so that it takes both objects and promises (previously only objects)\r\n\t3. Slight change to how promises are tracked\r\n\t4. Added isAnInstanceBeingDestroyed check to line 228\r\n\t5. Added 'OriginalTraceback' to help determine where an error was added to the janitor\r\n\t6. Likely some additional changes which weren't record here\r\n-------------------------------------\r\n--]]\r\n\r\n\r\n\r\n-- Janitor\r\n-- Original by Validark\r\n-- Modifications by pobammer\r\n-- roblox-ts support by OverHash and Validark\r\n-- LinkToInstance fixed by Elttob.\r\n\r\nlocal RunService = game:GetService(\"RunService\")\r\nlocal Heartbeat = RunService.Heartbeat\r\nlocal function getPromiseReference()\r\n\tif RunService:IsRunning() then\r\n\t\tlocal main = require(game:GetService(\"ReplicatedStorage\").Framework)\r\n\t\treturn main.modules.Promise\r\n\tend\r\nend\r\n\r\nlocal IndicesReference = newproxy(true)\r\ngetmetatable(IndicesReference).__tostring = function()\r\n\treturn \"IndicesReference\"\r\nend\r\n\r\nlocal LinkToInstanceIndex = newproxy(true)\r\ngetmetatable(LinkToInstanceIndex).__tostring = function()\r\n\treturn \"LinkToInstanceIndex\"\r\nend\r\n\r\nlocal METHOD_NOT_FOUND_ERROR = \"Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s\"\r\nlocal NOT_A_PROMISE = \"Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))\"\r\n\r\nlocal Janitor = {\r\n\tIGNORE_MEMORY_DEBUG = true,\r\n\tClassName = \"Janitor\";\r\n\t__index = {\r\n\t\tCurrentlyCleaning = true;\r\n\t\t[IndicesReference] = nil;\r\n\t};\r\n}\r\n\r\nlocal TypeDefaults = {\r\n\t[\"function\"] = true;\r\n\t[\"Promise\"] = \"cancel\";\r\n\tRBXScriptConnection = \"Disconnect\";\r\n}\r\n\r\n--[[**\r\n\tInstantiates a new Janitor object.\r\n\t@returns [t:Janitor]\r\n**--]]\r\nfunction Janitor.new()\r\n\treturn setmetatable({\r\n\t\tCurrentlyCleaning = false;\r\n\t\t[IndicesReference] = nil;\r\n\t}, Janitor)\r\nend\r\n\r\n--[[**\r\n\tDetermines if the passed object is a Janitor.\r\n\t@param [t:any] Object The object you are checking.\r\n\t@returns [t:boolean] Whether or not the object is a Janitor.\r\n**--]]\r\nfunction Janitor.Is(Object)\r\n\treturn type(Object) == \"table\" and getmetatable(Object) == Janitor\r\nend\r\n\r\nJanitor.is = Janitor.Is\r\n\r\n--[[**\r\n\tAdds an `Object` to Janitor for later cleanup, where `MethodName` is the key of the method within `Object` which should be called at cleanup time. If the `MethodName` is `true` the `Object` itself will be called instead. If passed an index it will occupy a namespace which can be `Remove()`d or overwritten. Returns the `Object`.\r\n\t@param [t:any] Object The object you want to clean up.\r\n\t@param [t:string|true?] MethodName The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes `Destroy`.\r\n\t@param [t:any?] Index The index that can be used to clean up the object manually.\r\n\t@returns [t:any] The object that was passed.\r\n**--]]\r\nfunction Janitor.__index:Add(Object, MethodName, Index)\r\n\tif Index then\r\n\t\tself:Remove(Index)\r\n\r\n\t\tlocal This = self[IndicesReference]\r\n\t\tif not This then\r\n\t\t\tThis = {}\r\n\t\t\tself[IndicesReference] = This\r\n\t\tend\r\n\r\n\t\tThis[Index] = Object\r\n\tend\r\n\r\n\tlocal objectType = typeof(Object)\r\n\tif objectType == \"table\" and string.match(tostring(Object), \"Promise\") then\r\n\t\tobjectType = \"Promise\"\r\n\t\t--local status = Object:getStatus()\r\n\t\t--print(\"status =\", status, status == \"Rejected\")\r\n\tend\r\n\tMethodName = MethodName or TypeDefaults[objectType] or \"Destroy\"\r\n\tif type(Object) ~= \"function\" and not Object[MethodName] then\r\n\t\twarn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil :: any, 2)))\r\n\tend\r\n\r\n\tlocal OriginalTraceback = debug.traceback(\"\")\r\n\tself[Object] = {MethodName, OriginalTraceback}\r\n\treturn Object\r\nend\r\nJanitor.__index.Give = Janitor.__index.Add\r\n\r\n-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.\r\n\r\n--[[**\r\n\tAdds a promise to the janitor. If the janitor is cleaned up and the promise is not completed, the promise will be cancelled.\r\n\t@param [t:Promise] PromiseObject The promise you want to add to the janitor.\r\n\t@returns [t:Promise]\r\n**--]]\r\nfunction Janitor.__index:AddPromise(PromiseObject)\r\n\tlocal Promise = getPromiseReference()\r\n\tif Promise then\r\n\t\tif not Promise.is(PromiseObject) then\r\n\t\t\terror(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))\r\n\t\tend\r\n\t\tif PromiseObject:getStatus() == Promise.Status.Started then\r\n\t\t\tlocal Id = newproxy(false)\r\n\t\t\tlocal NewPromise = self:Add(Promise.new(function(Resolve, _, OnCancel)\r\n\t\t\t\tif OnCancel(function()\r\n\t\t\t\t\t\tPromiseObject:cancel()\r\n\t\t\t\t\tend) then\r\n\t\t\t\t\treturn\r\n\t\t\t\tend\r\n\r\n\t\t\t\tResolve(PromiseObject)\r\n\t\t\tend), \"cancel\", Id)\r\n\r\n\t\t\tNewPromise:finallyCall(self.Remove, self, Id)\r\n\t\t\treturn NewPromise\r\n\t\telse\r\n\t\t\treturn PromiseObject\r\n\t\tend\r\n\telse\r\n\t\treturn PromiseObject\r\n\tend\r\nend\r\nJanitor.__index.GivePromise = Janitor.__index.AddPromise\r\n\r\n-- This will assume whether or not the object is a Promise or a regular object.\r\nfunction Janitor.__index:AddObject(Object)\r\n\tlocal Id = newproxy(false)\r\n\tlocal Promise = getPromiseReference()\r\n\tif Promise and Promise.is(Object) then\r\n\t\tif Object:getStatus() == Promise.Status.Started then\r\n\t\t\tlocal NewPromise = self:Add(Promise.resolve(Object), \"cancel\", Id)\r\n\t\t\tNewPromise:finallyCall(self.Remove, self, Id)\r\n\t\t\treturn NewPromise, Id\r\n\t\telse\r\n\t\t\treturn Object\r\n\t\tend\r\n\telse\r\n\t\treturn self:Add(Object, false, Id), Id\r\n\tend\r\nend\r\n\r\nJanitor.__index.GiveObject = Janitor.__index.AddObject\r\n\r\n--[[**\r\n\tCleans up whatever `Object` was set to this namespace by the 3rd parameter of `:Add()`.\r\n\t@param [t:any] Index The index you want to remove.\r\n\t@returns [t:Janitor] The same janitor, for chaining reasons.\r\n**--]]\r\nfunction Janitor.__index:Remove(Index)\r\n\tlocal This = self[IndicesReference]\r\n\tif This then\r\n\t\tlocal Object = This[Index]\r\n\r\n\t\tif Object then\r\n\t\t\tlocal ObjectDetail = self[Object]\r\n\t\t\tlocal MethodName = ObjectDetail and ObjectDetail[1]\r\n\r\n\t\t\tif MethodName then\r\n\t\t\t\tif MethodName == true then\r\n\t\t\t\t\tObject()\r\n\t\t\t\telse\r\n\t\t\t\t\tlocal ObjectMethod = Object[MethodName]\r\n\t\t\t\t\tif ObjectMethod then\r\n\t\t\t\t\t\tObjectMethod(Object)\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\r\n\t\t\t\tself[Object] = nil\r\n\t\t\tend\r\n\r\n\t\t\tThis[Index] = nil\r\n\t\tend\r\n\tend\r\n\r\n\treturn self\r\nend\r\n\r\n--[[**\r\n\tGets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the job using `__index`.\r\n\t@param [t:any] Index The index that the object is stored under.\r\n\t@returns [t:any?] This will return the object if it is found, but it won't return anything if it doesn't exist.\r\n**--]]\r\nfunction Janitor.__index:Get(Index)\r\n\tlocal This = self[IndicesReference]\r\n\tif This then\r\n\t\treturn This[Index]\r\n\tend\r\nend\r\n\r\n--[[**\r\n\tCalls each Object's `MethodName` (or calls the Object if `MethodName == true`) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor Object (so it can be used as a destructor callback).\r\n\t@returns [t:void]\r\n**--]]\r\nfunction Janitor.__index:Cleanup()\r\n\tif not self.CurrentlyCleaning then\r\n\t\tself.CurrentlyCleaning = nil\r\n\t\tfor Object, ObjectDetail in next, self do\r\n\t\t\tif Object == IndicesReference then\r\n\t\t\t\tcontinue\r\n\t\t\tend\r\n\r\n\t\t\t-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.\r\n\t\t\tlocal TypeOf = type(Object)\r\n\t\t\tif TypeOf == \"string\" or TypeOf == \"number\" then\r\n\t\t\t\tself[Object] = nil\r\n\t\t\t\tcontinue\r\n\t\t\tend\r\n\r\n\t\t\tlocal MethodName = ObjectDetail[1]\r\n\t\t\tlocal OriginalTraceback = ObjectDetail[2]\r\n\t\t\tlocal function warnUser(warning)\r\n\t\t\t\tlocal cleanupLine = debug.traceback(\"\", 3)--string.gsub(debug.traceback(\"\", 3), \"%c\", \"\")\r\n\t\t\t\tlocal addedLine = OriginalTraceback\r\n\t\t\t\twarn(\"-------- Janitor Error --------\"..\"\\n\"..tostring(warning)..\"\\n\"..cleanupLine..\"\"..addedLine)\r\n\t\t\tend\r\n\t\t\tif MethodName == true then\r\n\t\t\t\tlocal success, warning = pcall(Object)\r\n\t\t\t\tif not success then\r\n\t\t\t\t\twarnUser(warning)\r\n\t\t\t\tend\r\n\t\t\telse\r\n\t\t\t\tlocal ObjectMethod = Object[MethodName]\r\n\t\t\t\tif ObjectMethod then\r\n\t\t\t\t\tlocal success, warning = pcall(ObjectMethod, Object)\r\n\t\t\t\t\tlocal isAnInstanceBeingDestroyed = typeof(Object) == \"Instance\" and ObjectMethod == \"Destroy\"\r\n\t\t\t\t\tif not success and not isAnInstanceBeingDestroyed then\r\n\t\t\t\t\t\twarnUser(warning)\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\tself[Object] = nil\r\n\t\tend\r\n\r\n\t\tlocal This = self[IndicesReference]\r\n\t\tif This then\r\n\t\t\tfor Index in next, This do\r\n\t\t\t\tThis[Index] = nil\r\n\t\t\tend\r\n\r\n\t\t\tself[IndicesReference] = {}\r\n\t\tend\r\n\r\n\t\tself.CurrentlyCleaning = false\r\n\tend\r\nend\r\n\r\nJanitor.__index.Clean = Janitor.__index.Cleanup\r\n\r\n--[[**\r\n\tCalls `:Cleanup()` and renders the Janitor unusable.\r\n\t@returns [t:void]\r\n**--]]\r\nfunction Janitor.__index:Destroy()\r\n\tself:Cleanup()\r\n\t--table.clear(self)\r\n\t--setmetatable(self, nil)\r\nend\r\n\r\nJanitor.__call = Janitor.__index.Cleanup\r\n\r\n--- Makes the Janitor clean up when the instance is destroyed\r\n-- @param Instance Instance The Instance the Janitor will wait for to be Destroyed\r\n-- @returns Disconnectable table to stop Janitor from being cleaned up upon Instance Destroy (automatically cleaned up by Janitor, btw)\r\n-- @author Corecii\r\nlocal Disconnect = {Connected = true}\r\nDisconnect.__index = Disconnect\r\nfunction Disconnect:Disconnect()\r\n\tif self.Connected then\r\n\t\tself.Connected = false\r\n\t\tself.Connection:Disconnect()\r\n\tend\r\nend\r\n\r\nfunction Disconnect:__tostring()\r\n\treturn \"Disconnect<\" .. tostring(self.Connected) .. \">\"\r\nend\r\n\r\n--[[**\r\n\t\"Links\" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected. A Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter, the Janitor will \"link\" the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.\r\n\t@param [t:Instance] Object The instance you want to link the Janitor to.\r\n\t@param [t:boolean?] AllowMultiple Whether or not to allow multiple links on the same Janitor.\r\n\t@returns [t:RbxScriptConnection] A pseudo RBXScriptConnection that can be disconnected.\r\n**--]]\r\nfunction Janitor.__index:LinkToInstance(Object, AllowMultiple)\r\n\tlocal Connection\r\n\tlocal IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex\r\n\tlocal IsNilParented = Object.Parent == nil\r\n\tlocal ManualDisconnect = setmetatable({}, Disconnect)\r\n\r\n\tlocal function ChangedFunction(_DoNotUse, NewParent)\r\n\t\tif ManualDisconnect.Connected then\r\n\t\t\t_DoNotUse = nil\r\n\t\t\tIsNilParented = NewParent == nil\r\n\r\n\t\t\tif IsNilParented then\r\n\t\t\t\tcoroutine.wrap(function()\r\n\t\t\t\t\tHeartbeat:Wait()\r\n\t\t\t\t\tif not ManualDisconnect.Connected then\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\telseif not Connection.Connected then\r\n\t\t\t\t\t\tself:Cleanup()\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\twhile IsNilParented and Connection.Connected and ManualDisconnect.Connected do\r\n\t\t\t\t\t\t\tHeartbeat:Wait()\r\n\t\t\t\t\t\tend\r\n\r\n\t\t\t\t\t\tif ManualDisconnect.Connected and IsNilParented then\r\n\t\t\t\t\t\t\tself:Cleanup()\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\tend\r\n\t\t\t\tend)()\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\r\n\tConnection = Object.AncestryChanged:Connect(ChangedFunction)\r\n\tManualDisconnect.Connection = Connection\r\n\r\n\tif IsNilParented then\r\n\t\tChangedFunction(nil, Object.Parent)\r\n\tend\r\n\r\n\tObject = nil\r\n\treturn self:Add(ManualDisconnect, \"Disconnect\", IndexToUse)\r\nend\r\n\r\n--[[**\r\n\tLinks several instances to a janitor, which is then returned.\r\n\t@param [t:...Instance] ... All the instances you want linked.\r\n\t@returns [t:Janitor] A janitor that can be used to manually disconnect all LinkToInstances.\r\n**--]]\r\nfunction Janitor.__index:LinkToInstances(...)\r\n\tlocal ManualCleanup = Janitor.new()\r\n\tfor _, Object in ipairs({...}) do\r\n\t\tManualCleanup:Add(self:LinkToInstance(Object, true), \"Disconnect\")\r\n\tend\r\n\r\n\treturn ManualCleanup\r\nend\r\n\r\nfor FunctionName, Function in next, Janitor.__index do\r\n\tlocal NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)\r\n\tJanitor.__index[NewFunctionName] = Function\r\nend\r\n\r\nreturn Janitor",
                                        "Children": [],
                                        "Archivable": true
                                    }
                                ],
                                "ClassName": "Folder"
                            }
                        ],
                        "Archivable": true
                    }
                ],
                "ClassName": "Folder"
            }
        ]
    }
]