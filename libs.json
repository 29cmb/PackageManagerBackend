[
    {
        "ID": "cQqLr9zqhD",
        "Name": "Roact",
        "Author": "Roblox",
        "Description": " A declarative Lua UI library similar to Facebook's React",
        "Downloads": 0,
        "Serialized": [
            {
                "Name": "Roact",
                "ClassName": "ModuleScript",
                "Source": "--~strict\n--[[\n\tPackages up the internals of Roact and exposes a public API for it.\n]]\n\nlocal GlobalConfig = require(script.GlobalConfig)\nlocal createReconciler = require(script.createReconciler)\nlocal createReconcilerCompat = require(script.createReconcilerCompat)\nlocal RobloxRenderer = require(script.RobloxRenderer)\nlocal strict = require(script.strict)\nlocal Binding = require(script.Binding)\n\nlocal robloxReconciler = createReconciler(RobloxRenderer)\nlocal reconcilerCompat = createReconcilerCompat(robloxReconciler)\n\nlocal Roact = strict({\n\tComponent = require(script.Component),\n\tcreateElement = require(script.createElement),\n\tcreateFragment = require(script.createFragment),\n\toneChild = require(script.oneChild),\n\tPureComponent = require(script.PureComponent),\n\tNone = require(script.None),\n\tPortal = require(script.Portal),\n\tcreateRef = require(script.createRef),\n\tforwardRef = require(script.forwardRef),\n\tcreateBinding = Binding.create,\n\tjoinBindings = Binding.join,\n\tcreateContext = require(script.createContext),\n\n\tChange = require(script.PropMarkers.Change),\n\tChildren = require(script.PropMarkers.Children),\n\tEvent = require(script.PropMarkers.Event),\n\tRef = require(script.PropMarkers.Ref),\n\n\tmount = robloxReconciler.mountVirtualTree,\n\tunmount = robloxReconciler.unmountVirtualTree,\n\tupdate = robloxReconciler.updateVirtualTree,\n\n\treify = reconcilerCompat.reify,\n\tteardown = reconcilerCompat.teardown,\n\treconcile = reconcilerCompat.reconcile,\n\n\tsetGlobalConfig = GlobalConfig.set,\n\n\t-- APIs that may change in the future without warning\n\tUNSTABLE = {},\n})\n\nreturn Roact\n",
                "Children": [
                    {
                        "Name": "strict.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal strict = require(script.Parent.strict)\n\n\tit(\"should error when getting a nonexistent key\", function()\n\t\tlocal t = strict({\n\t\t\ta = 1,\n\t\t\tb = 2,\n\t\t})\n\n\t\texpect(function()\n\t\t\treturn t.c\n\t\tend).to.throw()\n\tend)\n\n\tit(\"should error when setting a nonexistent key\", function()\n\t\tlocal t = strict({\n\t\t\ta = 1,\n\t\t\tb = 2,\n\t\t})\n\n\t\texpect(function()\n\t\t\tt.c = 3\n\t\tend).to.throw()\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "strict",
                        "ClassName": "ModuleScript",
                        "Source": "--!nonstrict\nlocal function strict(t, name)\n\tname = name or tostring(t)\n\n\treturn setmetatable(t, {\n\t\t__index = function(_self, key)\n\t\t\tlocal message = (\"%q (%s) is not a valid member of %s\"):format(tostring(key), typeof(key), name)\n\n\t\t\terror(message, 2)\n\t\tend,\n\n\t\t__newindex = function(_self, key, _value)\n\t\t\tlocal message = (\"%q (%s) is not a valid member of %s\"):format(tostring(key), typeof(key), name)\n\n\t\t\terror(message, 2)\n\t\tend,\n\t})\nend\n\nreturn strict\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "oneChild.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal createElement = require(script.Parent.createElement)\n\n\tlocal oneChild = require(script.Parent.oneChild)\n\n\tit(\"should get zero children from a table\", function()\n\t\tlocal children = {}\n\n\t\texpect(oneChild(children)).to.equal(nil)\n\tend)\n\n\tit(\"should get exactly one child\", function()\n\t\tlocal child = createElement(\"Frame\")\n\t\tlocal children = {\n\t\t\tfoo = child,\n\t\t}\n\n\t\texpect(oneChild(children)).to.equal(child)\n\tend)\n\n\tit(\"should error with more than one child\", function()\n\t\tlocal children = {\n\t\t\ta = createElement(\"Frame\"),\n\t\t\tb = createElement(\"Frame\"),\n\t\t}\n\n\t\texpect(function()\n\t\t\toneChild(children)\n\t\tend).to.throw()\n\tend)\n\n\tit(\"should handle being passed nil\", function()\n\t\texpect(oneChild(nil)).to.equal(nil)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "oneChild",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tRetrieves at most one child from the children passed to a component.\n\n\tIf passed nil or an empty table, will return nil.\n\n\tThrows an error if passed more than one child.\n]]\nlocal function oneChild(children)\n\tif not children then\n\t\treturn nil\n\tend\n\n\tlocal key, child = next(children)\n\n\tif not child then\n\t\treturn nil\n\tend\n\n\tlocal after = next(children, key)\n\n\tif after then\n\t\terror(\"Expected at most child, had more than one child.\", 2)\n\tend\n\n\treturn child\nend\n\nreturn oneChild\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "invalidSetStateMessages",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tThese messages are used by Component to help users diagnose when they're\n\tcalling setState in inappropriate places.\n\n\tThe indentation may seem odd, but it's necessary to avoid introducing extra\n\twhitespace into the error messages themselves.\n]]\nlocal ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)\n\nlocal invalidSetStateMessages = {}\n\ninvalidSetStateMessages[ComponentLifecyclePhase.WillUpdate] = [[\nsetState cannot be used in the willUpdate lifecycle method.\nConsider using the didUpdate method instead, or using getDerivedStateFromProps.\n\nCheck the definition of willUpdate in the component %q.]]\n\ninvalidSetStateMessages[ComponentLifecyclePhase.WillUnmount] = [[\nsetState cannot be used in the willUnmount lifecycle method.\nA component that is being unmounted cannot be updated!\n\nCheck the definition of willUnmount in the component %q.]]\n\ninvalidSetStateMessages[ComponentLifecyclePhase.ShouldUpdate] = [[\nsetState cannot be used in the shouldUpdate lifecycle method.\nshouldUpdate must be a pure function that only depends on props and state.\n\nCheck the definition of shouldUpdate in the component %q.]]\n\ninvalidSetStateMessages[ComponentLifecyclePhase.Render] = [[\nsetState cannot be used in the render method.\nrender must be a pure function that only depends on props and state.\n\nCheck the definition of render in the component %q.]]\n\ninvalidSetStateMessages[\"default\"] = [[\nsetState can not be used in the current situation, because Roact doesn't know\nwhich part of the lifecycle this component is in.\n\nThis is a bug in Roact.\nIt was triggered by the component %q.\n]]\n\nreturn invalidSetStateMessages\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "internalAssert",
                        "ClassName": "ModuleScript",
                        "Source": "local function internalAssert(condition, message)\n\tif not condition then\n\t\terror(message .. \" (This is probably a bug in Roact!)\", 3)\n\tend\nend\n\nreturn internalAssert\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "init.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal Roact = require(script.Parent)\n\n\tit(\"should load with all public APIs\", function()\n\t\tlocal publicApi = {\n\t\t\tcreateElement = \"function\",\n\t\t\tcreateFragment = \"function\",\n\t\t\tcreateRef = \"function\",\n\t\t\tforwardRef = \"function\",\n\t\t\tcreateBinding = \"function\",\n\t\t\tjoinBindings = \"function\",\n\t\t\tmount = \"function\",\n\t\t\tunmount = \"function\",\n\t\t\tupdate = \"function\",\n\t\t\toneChild = \"function\",\n\t\t\tsetGlobalConfig = \"function\",\n\t\t\tcreateContext = \"function\",\n\n\t\t\t-- These functions are deprecated and throw warnings!\n\t\t\treify = \"function\",\n\t\t\tteardown = \"function\",\n\t\t\treconcile = \"function\",\n\n\t\t\tComponent = true,\n\t\t\tPureComponent = true,\n\t\t\tPortal = true,\n\t\t\tChildren = true,\n\t\t\tEvent = true,\n\t\t\tChange = true,\n\t\t\tRef = true,\n\t\t\tNone = true,\n\t\t\tUNSTABLE = true,\n\t\t}\n\n\t\texpect(Roact).to.be.ok()\n\n\t\tfor key, valueType in pairs(publicApi) do\n\t\t\tlocal success\n\t\t\tif typeof(valueType) == \"string\" then\n\t\t\t\tsuccess = typeof(Roact[key]) == valueType\n\t\t\telse\n\t\t\t\tsuccess = Roact[key] ~= nil\n\t\t\tend\n\n\t\t\tif not success then\n\t\t\t\tlocal existence = typeof(valueType) == \"boolean\" and \"present\" or \"of type \" .. valueType\n\t\t\t\tlocal message = (\"Expected public API member %q to be %s, but instead it was of type %s\"):format(\n\t\t\t\t\ttostring(key),\n\t\t\t\t\texistence,\n\t\t\t\t\ttypeof(Roact[key])\n\t\t\t\t)\n\n\t\t\t\terror(message)\n\t\t\tend\n\t\tend\n\n\t\tfor key in pairs(Roact) do\n\t\t\tif publicApi[key] == nil then\n\t\t\t\tlocal message = (\"Found unknown public API key %q!\"):format(tostring(key))\n\n\t\t\t\terror(message)\n\t\t\tend\n\t\tend\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "getDefaultInstanceProperty.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)\n\n\tit(\"should get default name string values\", function()\n\t\tlocal _, defaultName = getDefaultInstanceProperty(\"StringValue\", \"Name\")\n\n\t\texpect(defaultName).to.equal(\"Value\")\n\tend)\n\n\tit(\"should get default empty string values\", function()\n\t\tlocal _, defaultValue = getDefaultInstanceProperty(\"StringValue\", \"Value\")\n\n\t\texpect(defaultValue).to.equal(\"\")\n\tend)\n\n\tit(\"should get default number values\", function()\n\t\tlocal _, defaultValue = getDefaultInstanceProperty(\"IntValue\", \"Value\")\n\n\t\texpect(defaultValue).to.equal(0)\n\tend)\n\n\tit(\"should get nil default values\", function()\n\t\tlocal _, defaultValue = getDefaultInstanceProperty(\"ObjectValue\", \"Value\")\n\n\t\texpect(defaultValue).to.equal(nil)\n\tend)\n\n\tit(\"should get bool default values\", function()\n\t\tlocal _, defaultValue = getDefaultInstanceProperty(\"BoolValue\", \"Value\")\n\n\t\texpect(defaultValue).to.equal(false)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "getDefaultInstanceProperty",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tAttempts to get the default value of a given property on a Roblox instance.\n\n\tThis is used by the reconciler in cases where a prop was previously set on a\n\tprimitive component, but is no longer present in a component's new props.\n\n\tEventually, Roblox might provide a nicer API to query the default property\n\tof an object without constructing an instance of it.\n]]\n\nlocal Symbol = require(script.Parent.Symbol)\n\nlocal Nil = Symbol.named(\"Nil\")\nlocal _cachedPropertyValues = {}\n\nlocal function getDefaultInstanceProperty(className, propertyName)\n\tlocal classCache = _cachedPropertyValues[className]\n\n\tif classCache then\n\t\tlocal propValue = classCache[propertyName]\n\n\t\t-- We have to use a marker here, because Lua doesn't distinguish\n\t\t-- between 'nil' and 'not in a table'\n\t\tif propValue == Nil then\n\t\t\treturn true, nil\n\t\tend\n\n\t\tif propValue ~= nil then\n\t\t\treturn true, propValue\n\t\tend\n\telse\n\t\tclassCache = {}\n\t\t_cachedPropertyValues[className] = classCache\n\tend\n\n\tlocal created = Instance.new(className)\n\tlocal ok, defaultValue = pcall(function()\n\t\treturn created[propertyName]\n\tend)\n\n\tcreated:Destroy()\n\n\tif ok then\n\t\tif defaultValue == nil then\n\t\t\tclassCache[propertyName] = Nil\n\t\telse\n\t\t\tclassCache[propertyName] = defaultValue\n\t\tend\n\tend\n\n\treturn ok, defaultValue\nend\n\nreturn getDefaultInstanceProperty\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "forwardRef.spec",
                        "ClassName": "ModuleScript",
                        "Source": "-- Tests loosely adapted from those found at:\n-- * https://github.com/facebook/react/blob/v17.0.1/packages/react/src/__tests__/forwardRef-test.js\n-- * https://github.com/facebook/react/blob/v17.0.1/packages/react/src/__tests__/forwardRef-test.internal.js\nreturn function()\n\tlocal assign = require(script.Parent.assign)\n\tlocal createElement = require(script.Parent.createElement)\n\tlocal createRef = require(script.Parent.createRef)\n\tlocal forwardRef = require(script.Parent.forwardRef)\n\tlocal createReconciler = require(script.Parent.createReconciler)\n\tlocal Component = require(script.Parent.Component)\n\tlocal GlobalConfig = require(script.Parent.GlobalConfig)\n\tlocal Ref = require(script.Parent.PropMarkers.Ref)\n\n\tlocal RobloxRenderer = require(script.Parent.RobloxRenderer)\n\n\tlocal reconciler = createReconciler(RobloxRenderer)\n\n\tit(\"should update refs when switching between children\", function()\n\t\tlocal function FunctionComponent(props)\n\t\t\tlocal forwardedRef = props.forwardedRef\n\t\t\tlocal setRefOnDiv = props.setRefOnDiv\n\t\t\t-- deviation: clearer to express this way, since we don't have real\n\t\t\t-- ternaries\n\t\t\tlocal firstRef, secondRef\n\t\t\tif setRefOnDiv then\n\t\t\t\tfirstRef = forwardedRef\n\t\t\telse\n\t\t\t\tsecondRef = forwardedRef\n\t\t\tend\n\t\t\treturn createElement(\"Frame\", nil, {\n\t\t\t\tFirst = createElement(\"Frame\", {\n\t\t\t\t\t[Ref] = firstRef,\n\t\t\t\t}, {\n\t\t\t\t\tChild = createElement(\"TextLabel\", {\n\t\t\t\t\t\tText = \"First\",\n\t\t\t\t\t}),\n\t\t\t\t}),\n\t\t\t\tSecond = createElement(\"ScrollingFrame\", {\n\t\t\t\t\t[Ref] = secondRef,\n\t\t\t\t}, {\n\t\t\t\t\tChild = createElement(\"TextLabel\", {\n\t\t\t\t\t\tText = \"Second\",\n\t\t\t\t\t}),\n\t\t\t\t}),\n\t\t\t})\n\t\tend\n\n\t\tlocal RefForwardingComponent = forwardRef(function(props, ref)\n\t\t\treturn createElement(FunctionComponent, assign({}, props, { forwardedRef = ref }))\n\t\tend)\n\n\t\tlocal ref = createRef()\n\n\t\tlocal element = createElement(RefForwardingComponent, {\n\t\t\t[Ref] = ref,\n\t\t\tsetRefOnDiv = true,\n\t\t})\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"switch refs\")\n\t\texpect(ref.current.ClassName).to.equal(\"Frame\")\n\t\treconciler.unmountVirtualTree(tree)\n\n\t\telement = createElement(RefForwardingComponent, {\n\t\t\t[Ref] = ref,\n\t\t\tsetRefOnDiv = false,\n\t\t})\n\t\ttree = reconciler.mountVirtualTree(element, nil, \"switch refs\")\n\t\texpect(ref.current.ClassName).to.equal(\"ScrollingFrame\")\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should support rendering nil\", function()\n\t\tlocal RefForwardingComponent = forwardRef(function(_props, _ref)\n\t\t\treturn nil\n\t\tend)\n\n\t\tlocal ref = createRef()\n\n\t\tlocal element = createElement(RefForwardingComponent, { [Ref] = ref })\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"nil ref\")\n\t\texpect(ref.current).to.equal(nil)\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should support rendering nil for multiple children\", function()\n\t\tlocal RefForwardingComponent = forwardRef(function(_props, _ref)\n\t\t\treturn nil\n\t\tend)\n\n\t\tlocal ref = createRef()\n\n\t\tlocal element = createElement(\"Frame\", nil, {\n\t\t\tNoRef1 = createElement(\"Frame\"),\n\t\t\tWithRef = createElement(RefForwardingComponent, { [Ref] = ref }),\n\t\t\tNoRef2 = createElement(\"Frame\"),\n\t\t})\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"multiple children nil ref\")\n\t\texpect(ref.current).to.equal(nil)\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\t-- We could support this by having forwardRef return a stateful component,\n\t-- but it's likely not necessary\n\titSKIP(\"should support defaultProps\", function()\n\t\tlocal function FunctionComponent(props)\n\t\t\tlocal forwardedRef = props.forwardedRef\n\t\t\tlocal optional = props.optional\n\t\t\tlocal required = props.required\n\t\t\treturn createElement(\"Frame\", {\n\t\t\t\t[Ref] = forwardedRef,\n\t\t\t}, {\n\t\t\t\tOptionalChild = optional,\n\t\t\t\tRequiredChild = required,\n\t\t\t})\n\t\tend\n\n\t\tlocal RefForwardingComponent = forwardRef(function(props, ref)\n\t\t\treturn createElement(\n\t\t\t\tFunctionComponent,\n\t\t\t\tassign({}, props, {\n\t\t\t\t\tforwardedRef = ref,\n\t\t\t\t})\n\t\t\t)\n\t\tend)\n\t\tRefForwardingComponent.defaultProps = {\n\t\t\toptional = createElement(\"TextLabel\"),\n\t\t}\n\n\t\tlocal ref = createRef()\n\n\t\tlocal element = createElement(RefForwardingComponent, {\n\t\t\t[Ref] = ref,\n\t\t\toptional = createElement(\"Frame\"),\n\t\t\trequired = createElement(\"ScrollingFrame\"),\n\t\t})\n\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"with optional\")\n\n\t\texpect(ref.current:FindFirstChild(\"OptionalChild\").ClassName).to.equal(\"Frame\")\n\t\texpect(ref.current:FindFirstChild(\"RequiredChild\").ClassName).to.equal(\"ScrollingFrame\")\n\n\t\treconciler.unmountVirtualTree(tree)\n\t\telement = createElement(RefForwardingComponent, {\n\t\t\t[Ref] = ref,\n\t\t\trequired = createElement(\"ScrollingFrame\"),\n\t\t})\n\t\ttree = reconciler.mountVirtualTree(element, nil, \"with default\")\n\n\t\texpect(ref.current:FindFirstChild(\"OptionalChild\").ClassName).to.equal(\"TextLabel\")\n\t\texpect(ref.current:FindFirstChild(\"RequiredChild\").ClassName).to.equal(\"ScrollingFrame\")\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should error if not provided a callback when type checking is enabled\", function()\n\t\tGlobalConfig.scoped({\n\t\t\ttypeChecks = true,\n\t\t}, function()\n\t\t\texpect(function()\n\t\t\t\tforwardRef(nil)\n\t\t\tend).to.throw()\n\t\tend)\n\n\t\tGlobalConfig.scoped({\n\t\t\ttypeChecks = true,\n\t\t}, function()\n\t\t\texpect(function()\n\t\t\t\tforwardRef(\"foo\")\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tit(\"should work without a ref to be forwarded\", function()\n\t\tlocal function Child()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal function Wrapper(props)\n\t\t\treturn createElement(Child, assign({}, props, { [Ref] = props.forwardedRef }))\n\t\tend\n\n\t\tlocal RefForwardingComponent = forwardRef(function(props, ref)\n\t\t\treturn createElement(Wrapper, assign({}, props, { forwardedRef = ref }))\n\t\tend)\n\n\t\tlocal element = createElement(RefForwardingComponent, { value = 123 })\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"nil ref\")\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should forward a ref for a single child\", function()\n\t\tlocal value\n\t\tlocal function Child(props)\n\t\t\tvalue = props.value\n\t\t\treturn createElement(\"Frame\", {\n\t\t\t\t[Ref] = props[Ref],\n\t\t\t})\n\t\tend\n\n\t\tlocal function Wrapper(props)\n\t\t\treturn createElement(Child, assign({}, props, { [Ref] = props.forwardedRef }))\n\t\tend\n\n\t\tlocal RefForwardingComponent = forwardRef(function(props, ref)\n\t\t\treturn createElement(Wrapper, assign({}, props, { forwardedRef = ref }))\n\t\tend)\n\n\t\tlocal ref = createRef()\n\n\t\tlocal element = createElement(RefForwardingComponent, { [Ref] = ref, value = 123 })\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"single child ref\")\n\t\texpect(value).to.equal(123)\n\t\texpect(ref.current.ClassName).to.equal(\"Frame\")\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should forward a ref for multiple children\", function()\n\t\tlocal function Child(props)\n\t\t\treturn createElement(\"Frame\", {\n\t\t\t\t[Ref] = props[Ref],\n\t\t\t})\n\t\tend\n\n\t\tlocal function Wrapper(props)\n\t\t\treturn createElement(Child, assign({}, props, { [Ref] = props.forwardedRef }))\n\t\tend\n\n\t\tlocal RefForwardingComponent = forwardRef(function(props, ref)\n\t\t\treturn createElement(Wrapper, assign({}, props, { forwardedRef = ref }))\n\t\tend)\n\n\t\tlocal ref = createRef()\n\n\t\tlocal element = createElement(\"Frame\", nil, {\n\t\t\tNoRef1 = createElement(\"Frame\"),\n\t\t\tWithRef = createElement(RefForwardingComponent, { [Ref] = ref }),\n\t\t\tNoRef2 = createElement(\"Frame\"),\n\t\t})\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"multi child ref\")\n\t\texpect(ref.current.ClassName).to.equal(\"Frame\")\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should maintain child instance and ref through updates\", function()\n\t\tlocal value\n\t\tlocal function Child(props)\n\t\t\tvalue = props.value\n\t\t\treturn createElement(\"Frame\", {\n\t\t\t\t[Ref] = props[Ref],\n\t\t\t})\n\t\tend\n\n\t\tlocal function Wrapper(props)\n\t\t\treturn createElement(Child, assign({}, props, { [Ref] = props.forwardedRef }))\n\t\tend\n\n\t\tlocal RefForwardingComponent = forwardRef(function(props, ref)\n\t\t\treturn createElement(Wrapper, assign({}, props, { forwardedRef = ref }))\n\t\tend)\n\n\t\tlocal setRefCount = 0\n\t\tlocal refValue\n\n\t\tlocal setRef = function(r)\n\t\t\tsetRefCount = setRefCount + 1\n\t\t\trefValue = r\n\t\tend\n\n\t\tlocal element = createElement(RefForwardingComponent, { [Ref] = setRef, value = 123 })\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"maintains instance\")\n\n\t\texpect(value).to.equal(123)\n\t\texpect(refValue.ClassName).to.equal(\"Frame\")\n\t\texpect(setRefCount).to.equal(1)\n\n\t\telement = createElement(RefForwardingComponent, { [Ref] = setRef, value = 456 })\n\t\ttree = reconciler.updateVirtualTree(tree, element)\n\n\t\texpect(value).to.equal(456)\n\t\texpect(setRefCount).to.equal(1)\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should not re-run the render callback on a deep setState\", function()\n\t\tlocal inst\n\t\tlocal renders = {}\n\n\t\tlocal Inner = Component:extend(\"Inner\")\n\t\tfunction Inner:render()\n\t\t\ttable.insert(renders, \"Inner\")\n\t\t\tinst = self\n\t\t\treturn createElement(\"Frame\", { [Ref] = self.props.forwardedRef })\n\t\tend\n\n\t\tlocal function Middle(props)\n\t\t\ttable.insert(renders, \"Middle\")\n\t\t\treturn createElement(Inner, props)\n\t\tend\n\n\t\tlocal Forward = forwardRef(function(props, ref)\n\t\t\ttable.insert(renders, \"Forward\")\n\t\t\treturn createElement(Middle, assign({}, props, { forwardedRef = ref }))\n\t\tend)\n\n\t\tlocal function App()\n\t\t\ttable.insert(renders, \"App\")\n\t\t\treturn createElement(Forward)\n\t\tend\n\n\t\tlocal tree = reconciler.mountVirtualTree(createElement(App), nil, \"deep setState\")\n\t\texpect(#renders).to.equal(4)\n\t\texpect(renders[1]).to.equal(\"App\")\n\t\texpect(renders[2]).to.equal(\"Forward\")\n\t\texpect(renders[3]).to.equal(\"Middle\")\n\t\texpect(renders[4]).to.equal(\"Inner\")\n\n\t\trenders = {}\n\t\tinst:setState({})\n\t\texpect(#renders).to.equal(1)\n\t\texpect(renders[1]).to.equal(\"Inner\")\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\n\n\tit(\"should not include the ref in the forwarded props\", function()\n\t\tlocal capturedProps\n\t\tlocal function CaptureProps(props)\n\t\t\tcapturedProps = props\n\t\t\treturn createElement(\"Frame\", { [Ref] = props.forwardedRef })\n\t\tend\n\n\t\tlocal RefForwardingComponent = forwardRef(function(props, ref)\n\t\t\treturn createElement(CaptureProps, assign({}, props, { forwardedRef = ref }))\n\t\tend)\n\n\t\tlocal ref = createRef()\n\t\tlocal element = createElement(RefForwardingComponent, {\n\t\t\t[Ref] = ref,\n\t\t})\n\n\t\tlocal tree = reconciler.mountVirtualTree(element, nil, \"no ref in props\")\n\t\texpect(capturedProps).to.be.ok()\n\t\texpect(capturedProps.forwardedRef).to.equal(ref)\n\t\texpect(capturedProps[Ref]).to.equal(nil)\n\t\treconciler.unmountVirtualTree(tree)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "forwardRef",
                        "ClassName": "ModuleScript",
                        "Source": "local assign = require(script.Parent.assign)\nlocal None = require(script.Parent.None)\nlocal Ref = require(script.Parent.PropMarkers.Ref)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal excludeRef = {\n\t[Ref] = None,\n}\n\n--[[\n\tAllows forwarding of refs to underlying host components. Accepts a render\n\tcallback which accepts props and a ref, and returns an element.\n]]\nlocal function forwardRef(render)\n\tif config.typeChecks then\n\t\tassert(typeof(render) == \"function\", \"Expected arg #1 to be a function\")\n\tend\n\n\treturn function(props)\n\t\tlocal ref = props[Ref]\n\t\tlocal propsWithoutRef = assign({}, props, excludeRef)\n\n\t\treturn render(propsWithoutRef, ref)\n\tend\nend\n\nreturn forwardRef\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createSpy.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal createSpy = require(script.Parent.createSpy)\n\n\tdescribe(\"createSpy\", function()\n\t\tit(\"should create spies\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\n\t\t\texpect(spy).to.be.ok()\n\t\tend)\n\n\t\tit(\"should throw if spies are indexed by an invalid key\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\n\t\t\texpect(function()\n\t\t\t\treturn spy.test\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tdescribe(\"value\", function()\n\t\tit(\"should increment callCount when called\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\t\t\tspy.value()\n\n\t\t\texpect(spy.callCount).to.equal(1)\n\t\tend)\n\n\t\tit(\"should store all values passed\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\t\t\tspy.value(1, true, \"3\")\n\n\t\t\texpect(spy.valuesLength).to.equal(3)\n\t\t\texpect(spy.values[1]).to.equal(1)\n\t\t\texpect(spy.values[2]).to.equal(true)\n\t\t\texpect(spy.values[3]).to.equal(\"3\")\n\t\tend)\n\n\t\tit(\"should return the value of the inner function\", function()\n\t\t\tlocal spy = createSpy(function()\n\t\t\t\treturn true\n\t\t\tend)\n\n\t\t\texpect(spy.value()).to.equal(true)\n\t\tend)\n\tend)\n\n\tdescribe(\"assertCalledWith\", function()\n\t\tit(\"should throw if the number of values differs\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\t\t\tspy.value(1, 2)\n\n\t\t\texpect(function()\n\t\t\t\tspy:assertCalledWith(1)\n\t\t\tend).to.throw()\n\t\tend)\n\n\t\tit(\"should throw if any value differs\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\t\t\tspy.value(1, 2)\n\n\t\t\texpect(function()\n\t\t\t\tspy:assertCalledWith(1, 3)\n\t\t\tend).to.throw()\n\n\t\t\texpect(function()\n\t\t\t\tspy:assertCalledWith(2, 3)\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tdescribe(\"captureValues\", function()\n\t\tit(\"should throw if the number of values differs\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\t\t\tspy.value(1, 2)\n\n\t\t\texpect(function()\n\t\t\t\tspy:captureValues(\"a\")\n\t\t\tend).to.throw()\n\t\tend)\n\n\t\tit(\"should capture all values in a table\", function()\n\t\t\tlocal spy = createSpy(function() end)\n\t\t\tspy.value(1, 2)\n\n\t\t\tlocal captured = spy:captureValues(\"a\", \"b\")\n\t\t\texpect(captured.a).to.equal(1)\n\t\t\texpect(captured.b).to.equal(2)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createSpy",
                        "ClassName": "ModuleScript",
                        "Source": "--!strict\n--[[\n\tA utility used to create a function spy that can be used to robustly test\n\tthat functions are invoked the correct number of times and with the correct\n\tnumber of arguments.\n\n\tThis should only be used in tests.\n]]\n\nlocal assertDeepEqual = require(script.Parent.assertDeepEqual)\n\nlocal function createSpy(inner)\n\tlocal self = {}\n\tself.callCount = 0\n\tself.values = {}\n\tself.valuesLength = 0\n\tself.value = function(...)\n\t\tself.callCount = self.callCount + 1\n\t\tself.values = { ... }\n\t\tself.valuesLength = select(\"#\", ...)\n\n\t\tif inner ~= nil then\n\t\t\treturn inner(...)\n\t\tend\n\t\treturn nil\n\tend\n\n\tself.assertCalledWith = function(_, ...)\n\t\tlocal len = select(\"#\", ...)\n\n\t\tif self.valuesLength ~= len then\n\t\t\terror((\"Expected %d arguments, but was called with %d arguments\"):format(self.valuesLength, len), 2)\n\t\tend\n\n\t\tfor i = 1, len do\n\t\t\tlocal expected = select(i, ...)\n\n\t\t\tassert(self.values[i] == expected, \"value differs\")\n\t\tend\n\tend\n\n\tself.assertCalledWithDeepEqual = function(_, ...)\n\t\tlocal len = select(\"#\", ...)\n\n\t\tif self.valuesLength ~= len then\n\t\t\terror((\"Expected %d arguments, but was called with %d arguments\"):format(self.valuesLength, len), 2)\n\t\tend\n\n\t\tfor i = 1, len do\n\t\t\tlocal expected = select(i, ...)\n\n\t\t\tassertDeepEqual(self.values[i], expected)\n\t\tend\n\tend\n\n\tself.captureValues = function(_, ...)\n\t\tlocal len = select(\"#\", ...)\n\t\tlocal result = {}\n\n\t\tassert(self.valuesLength == len, \"length of expected values differs from stored values\")\n\n\t\tfor i = 1, len do\n\t\t\tlocal key = select(i, ...)\n\t\t\tresult[key] = self.values[i]\n\t\tend\n\n\t\treturn result\n\tend\n\n\tsetmetatable(self, {\n\t\t__index = function(_, key)\n\t\t\terror((\"%q is not a valid member of spy\"):format(key))\n\t\tend,\n\t})\n\n\treturn self\nend\n\nreturn createSpy\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createSignal.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal createSignal = require(script.Parent.createSignal)\n\n\tlocal createSpy = require(script.Parent.createSpy)\n\n\tit(\"should fire subscribers and disconnect them\", function()\n\t\tlocal signal = createSignal()\n\n\t\tlocal spy = createSpy()\n\t\tlocal disconnect = signal:subscribe(spy.value)\n\n\t\texpect(spy.callCount).to.equal(0)\n\n\t\tlocal a = 1\n\t\tlocal b = {}\n\t\tlocal c = \"hello\"\n\t\tsignal:fire(a, b, c)\n\n\t\texpect(spy.callCount).to.equal(1)\n\t\tspy:assertCalledWith(a, b, c)\n\n\t\tdisconnect()\n\n\t\tsignal:fire()\n\n\t\texpect(spy.callCount).to.equal(1)\n\tend)\n\n\tit(\"should handle multiple subscribers\", function()\n\t\tlocal signal = createSignal()\n\n\t\tlocal spyA = createSpy()\n\t\tlocal spyB = createSpy()\n\n\t\tlocal disconnectA = signal:subscribe(spyA.value)\n\t\tlocal disconnectB = signal:subscribe(spyB.value)\n\n\t\texpect(spyA.callCount).to.equal(0)\n\t\texpect(spyB.callCount).to.equal(0)\n\n\t\tlocal a = {}\n\t\tlocal b = 67\n\t\tsignal:fire(a, b)\n\n\t\texpect(spyA.callCount).to.equal(1)\n\t\tspyA:assertCalledWith(a, b)\n\n\t\texpect(spyB.callCount).to.equal(1)\n\t\tspyB:assertCalledWith(a, b)\n\n\t\tdisconnectA()\n\n\t\tsignal:fire(b, a)\n\n\t\texpect(spyA.callCount).to.equal(1)\n\n\t\texpect(spyB.callCount).to.equal(2)\n\t\tspyB:assertCalledWith(b, a)\n\n\t\tdisconnectB()\n\tend)\n\n\tit(\"should stop firing a connection if disconnected mid-fire\", function()\n\t\tlocal signal = createSignal()\n\n\t\t-- In this test, we'll connect two listeners that each try to disconnect\n\t\t-- the other. Because the order of listeners firing isn't defined, we\n\t\t-- have to be careful to handle either case.\n\n\t\tlocal disconnectA\n\t\tlocal disconnectB\n\n\t\tlocal spyA = createSpy(function()\n\t\t\tdisconnectB()\n\t\tend)\n\n\t\tlocal spyB = createSpy(function()\n\t\t\tdisconnectA()\n\t\tend)\n\n\t\tdisconnectA = signal:subscribe(spyA.value)\n\t\tdisconnectB = signal:subscribe(spyB.value)\n\n\t\tsignal:fire()\n\n\t\t-- Exactly once listener should have been called.\n\t\texpect(spyA.callCount + spyB.callCount).to.equal(1)\n\tend)\n\n\tit(\"should allow adding listener in the middle of firing\", function()\n\t\tlocal signal = createSignal()\n\n\t\tlocal disconnectA\n\t\tlocal spyA = createSpy()\n\t\tlocal listener = function(_a, _b)\n\t\t\tdisconnectA = signal:subscribe(spyA.value)\n\t\tend\n\n\t\tlocal disconnectListener = signal:subscribe(listener)\n\n\t\texpect(spyA.callCount).to.equal(0)\n\n\t\tlocal a = {}\n\t\tlocal b = 67\n\t\tsignal:fire(a, b)\n\n\t\texpect(spyA.callCount).to.equal(0)\n\n\t\t-- The new listener should be picked up in next fire.\n\t\tsignal:fire(b, a)\n\t\texpect(spyA.callCount).to.equal(1)\n\t\tspyA:assertCalledWith(b, a)\n\n\t\tdisconnectA()\n\t\tdisconnectListener()\n\n\t\tsignal:fire(a)\n\n\t\texpect(spyA.callCount).to.equal(1)\n\tend)\n\n\tit(\"should have one connection instance when add the same listener multiple times\", function()\n\t\tlocal signal = createSignal()\n\n\t\tlocal spyA = createSpy()\n\t\tlocal disconnect1 = signal:subscribe(spyA.value)\n\n\t\texpect(spyA.callCount).to.equal(0)\n\n\t\tlocal a = {}\n\t\tlocal b = 67\n\t\tsignal:fire(a, b)\n\n\t\texpect(spyA.callCount).to.equal(1)\n\t\tspyA:assertCalledWith(a, b)\n\n\t\tlocal disconnect2 = signal:subscribe(spyA.value)\n\n\t\tsignal:fire(b, a)\n\t\texpect(spyA.callCount).to.equal(2)\n\t\tspyA:assertCalledWith(b, a)\n\n\t\tdisconnect2()\n\n\t\tsignal:fire(a)\n\n\t\texpect(spyA.callCount).to.equal(2)\n\n\t\t-- should have no effect.\n\t\tdisconnect1()\n\t\tsignal:fire(a)\n\t\texpect(spyA.callCount).to.equal(2)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createSignal",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tThis is a simple signal implementation that has a dead-simple API.\n\n\t\tlocal signal = createSignal()\n\n\t\tlocal disconnect = signal:subscribe(function(foo)\n\t\t\tprint(\"Cool foo:\", foo)\n\t\tend)\n\n\t\tsignal:fire(\"something\")\n\n\t\tdisconnect()\n]]\n\nlocal function createSignal()\n\tlocal connections = {}\n\tlocal suspendedConnections = {}\n\tlocal firing = false\n\n\tlocal function subscribe(_self, callback)\n\t\tassert(typeof(callback) == \"function\", \"Can only subscribe to signals with a function.\")\n\n\t\tlocal connection = {\n\t\t\tcallback = callback,\n\t\t\tdisconnected = false,\n\t\t}\n\n\t\t-- If the callback is already registered, don't add to the suspendedConnection. Otherwise, this will disable\n\t\t-- the existing one.\n\t\tif firing and not connections[callback] then\n\t\t\tsuspendedConnections[callback] = connection\n\t\tend\n\n\t\tconnections[callback] = connection\n\n\t\tlocal function disconnect()\n\t\t\tassert(not connection.disconnected, \"Listeners can only be disconnected once.\")\n\n\t\t\tconnection.disconnected = true\n\t\t\tconnections[callback] = nil\n\t\t\tsuspendedConnections[callback] = nil\n\t\tend\n\n\t\treturn disconnect\n\tend\n\n\tlocal function fire(_self, ...)\n\t\tfiring = true\n\t\tfor callback, connection in pairs(connections) do\n\t\t\tif not connection.disconnected and not suspendedConnections[callback] then\n\t\t\t\tcallback(...)\n\t\t\tend\n\t\tend\n\n\t\tfiring = false\n\n\t\tfor callback, _ in pairs(suspendedConnections) do\n\t\t\tsuspendedConnections[callback] = nil\n\t\tend\n\tend\n\n\treturn {\n\t\tsubscribe = subscribe,\n\t\tfire = fire,\n\t}\nend\n\nreturn createSignal\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createRef.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal Binding = require(script.Parent.Binding)\n\tlocal Type = require(script.Parent.Type)\n\n\tlocal createRef = require(script.Parent.createRef)\n\n\tit(\"should create refs, which are specialized bindings\", function()\n\t\tlocal ref = createRef()\n\n\t\texpect(Type.of(ref)).to.equal(Type.Binding)\n\t\texpect(ref.current).to.equal(nil)\n\tend)\n\n\tit(\"should have a 'current' field that is the same as the internal binding's value\", function()\n\t\tlocal ref = createRef()\n\n\t\texpect(ref.current).to.equal(nil)\n\n\t\tBinding.update(ref, 10)\n\t\texpect(ref.current).to.equal(10)\n\tend)\n\n\tit(\"should support tostring on refs\", function()\n\t\tlocal ref = createRef()\n\n\t\texpect(ref.current).to.equal(nil)\n\t\texpect(tostring(ref)).to.equal(\"RoactRef(nil)\")\n\n\t\tBinding.update(ref, 10)\n\t\texpect(tostring(ref)).to.equal(\"RoactRef(10)\")\n\tend)\n\n\tit(\"should not allow assignments to the 'current' field\", function()\n\t\tlocal ref = createRef()\n\n\t\texpect(ref.current).to.equal(nil)\n\n\t\tBinding.update(ref, 99)\n\t\texpect(ref.current).to.equal(99)\n\n\t\texpect(function()\n\t\t\tref.current = 77\n\t\tend).to.throw()\n\n\t\texpect(ref.current).to.equal(99)\n\tend)\n\n\tit(\"should return the same thing from getValue as its current field\", function()\n\t\tlocal ref = createRef()\n\t\tBinding.update(ref, 10)\n\n\t\texpect(ref:getValue()).to.equal(10)\n\t\texpect(ref:getValue()).to.equal(ref.current)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createRef",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tA ref is nothing more than a binding with a special field 'current'\n\tthat maps to the getValue method of the binding\n]]\nlocal Binding = require(script.Parent.Binding)\n\nlocal function createRef()\n\tlocal binding, _ = Binding.create(nil)\n\n\tlocal ref = {}\n\n\t--[[\n\t\tA ref is just redirected to a binding via its metatable\n\t]]\n\tsetmetatable(ref, {\n\t\t__index = function(_self, key)\n\t\t\tif key == \"current\" then\n\t\t\t\treturn binding:getValue()\n\t\t\telse\n\t\t\t\treturn binding[key]\n\t\t\tend\n\t\tend,\n\t\t__newindex = function(_self, key, value)\n\t\t\tif key == \"current\" then\n\t\t\t\terror(\"Cannot assign to the 'current' property of refs\", 2)\n\t\t\tend\n\n\t\t\tbinding[key] = value\n\t\tend,\n\t\t__tostring = function(_self)\n\t\t\treturn (\"RoactRef(%s)\"):format(tostring(binding:getValue()))\n\t\tend,\n\t})\n\n\treturn ref\nend\n\nreturn createRef\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createReconcilerCompat.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal createElement = require(script.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.createReconciler)\n\tlocal Logging = require(script.Parent.Logging)\n\tlocal NoopRenderer = require(script.Parent.NoopRenderer)\n\n\tlocal createReconcilerCompat = require(script.Parent.createReconcilerCompat)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\tlocal compatReconciler = createReconcilerCompat(noopReconciler)\n\n\tit(\"reify should only warn once per call site\", function()\n\t\tlocal logInfo = Logging.capture(function()\n\t\t\t-- We're using a loop so that we get the same stack trace and only one\n\t\t\t-- warning hopefully.\n\t\t\tfor _ = 1, 2 do\n\t\t\t\tlocal handle = compatReconciler.reify(createElement(\"StringValue\"))\n\t\t\t\tnoopReconciler.unmountVirtualTree(handle)\n\t\t\tend\n\t\tend)\n\n\t\texpect(#logInfo.warnings).to.equal(1)\n\t\texpect(logInfo.warnings[1]:find(\"reify\")).to.be.ok()\n\n\t\tlogInfo = Logging.capture(function()\n\t\t\t-- This is a different call site, which should trigger another warning.\n\t\t\tlocal handle = compatReconciler.reify(createElement(\"StringValue\"))\n\t\t\tnoopReconciler.unmountVirtualTree(handle)\n\t\tend)\n\n\t\texpect(#logInfo.warnings).to.equal(1)\n\t\texpect(logInfo.warnings[1]:find(\"reify\")).to.be.ok()\n\tend)\n\n\tit(\"teardown should only warn once per call site\", function()\n\t\tlocal logInfo = Logging.capture(function()\n\t\t\t-- We're using a loop so that we get the same stack trace and only one\n\t\t\t-- warning hopefully.\n\t\t\tfor _ = 1, 2 do\n\t\t\t\tlocal handle = noopReconciler.mountVirtualTree(createElement(\"StringValue\"))\n\t\t\t\tcompatReconciler.teardown(handle)\n\t\t\tend\n\t\tend)\n\n\t\texpect(#logInfo.warnings).to.equal(1)\n\t\texpect(logInfo.warnings[1]:find(\"teardown\")).to.be.ok()\n\n\t\tlogInfo = Logging.capture(function()\n\t\t\t-- This is a different call site, which should trigger another warning.\n\t\t\tlocal handle = noopReconciler.mountVirtualTree(createElement(\"StringValue\"))\n\t\t\tcompatReconciler.teardown(handle)\n\t\tend)\n\n\t\texpect(#logInfo.warnings).to.equal(1)\n\t\texpect(logInfo.warnings[1]:find(\"teardown\")).to.be.ok()\n\tend)\n\n\tit(\"update should only warn once per call site\", function()\n\t\tlocal logInfo = Logging.capture(function()\n\t\t\t-- We're using a loop so that we get the same stack trace and only one\n\t\t\t-- warning hopefully.\n\t\t\tfor _ = 1, 2 do\n\t\t\t\tlocal handle = noopReconciler.mountVirtualTree(createElement(\"StringValue\"))\n\t\t\t\tcompatReconciler.reconcile(handle, createElement(\"StringValue\"))\n\t\t\t\tnoopReconciler.unmountVirtualTree(handle)\n\t\t\tend\n\t\tend)\n\n\t\texpect(#logInfo.warnings).to.equal(1)\n\t\texpect(logInfo.warnings[1]:find(\"reconcile\")).to.be.ok()\n\n\t\tlogInfo = Logging.capture(function()\n\t\t\t-- This is a different call site, which should trigger another warning.\n\t\t\tlocal handle = noopReconciler.mountVirtualTree(createElement(\"StringValue\"))\n\t\t\tcompatReconciler.reconcile(handle, createElement(\"StringValue\"))\n\t\t\tnoopReconciler.unmountVirtualTree(handle)\n\t\tend)\n\n\t\texpect(#logInfo.warnings).to.equal(1)\n\t\texpect(logInfo.warnings[1]:find(\"reconcile\")).to.be.ok()\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createReconcilerCompat",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tContains deprecated methods from Reconciler. Broken out so that removing\n\tthis shim is easy -- just delete this file and remove it from init.\n]]\n\nlocal Logging = require(script.Parent.Logging)\n\nlocal reifyMessage = [[\nRoact.reify has been renamed to Roact.mount and will be removed in a future release.\nCheck the call to Roact.reify at:\n]]\n\nlocal teardownMessage = [[\nRoact.teardown has been renamed to Roact.unmount and will be removed in a future release.\nCheck the call to Roact.teardown at:\n]]\n\nlocal reconcileMessage = [[\nRoact.reconcile has been renamed to Roact.update and will be removed in a future release.\nCheck the call to Roact.reconcile at:\n]]\n\nlocal function createReconcilerCompat(reconciler)\n\tlocal compat = {}\n\n\tfunction compat.reify(...)\n\t\tLogging.warnOnce(reifyMessage)\n\n\t\treturn reconciler.mountVirtualTree(...)\n\tend\n\n\tfunction compat.teardown(...)\n\t\tLogging.warnOnce(teardownMessage)\n\n\t\treturn reconciler.unmountVirtualTree(...)\n\tend\n\n\tfunction compat.reconcile(...)\n\t\tLogging.warnOnce(reconcileMessage)\n\n\t\treturn reconciler.updateVirtualTree(...)\n\tend\n\n\treturn compat\nend\n\nreturn createReconcilerCompat\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createReconciler.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal assign = require(script.Parent.assign)\n\tlocal createElement = require(script.Parent.createElement)\n\tlocal createFragment = require(script.Parent.createFragment)\n\tlocal createSpy = require(script.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Type)\n\tlocal ElementKind = require(script.Parent.ElementKind)\n\n\tlocal createReconciler = require(script.Parent.createReconciler)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tdescribe(\"tree operations\", function()\n\t\tit(\"should mount and unmount\", function()\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(createElement(\"StringValue\"))\n\n\t\t\texpect(tree).to.be.ok()\n\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\t\tend)\n\n\t\tit(\"should mount, update, and unmount\", function()\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(createElement(\"StringValue\"))\n\n\t\t\texpect(tree).to.be.ok()\n\n\t\t\tnoopReconciler.updateVirtualTree(tree, createElement(\"StringValue\"))\n\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\t\tend)\n\tend)\n\n\tdescribe(\"booleans\", function()\n\t\tit(\"should mount booleans as nil\", function()\n\t\t\tlocal node = noopReconciler.mountVirtualNode(false, nil, \"test\")\n\t\t\texpect(node).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should unmount nodes if they are updated to a boolean value\", function()\n\t\t\tlocal node = noopReconciler.mountVirtualNode(createElement(\"StringValue\"), nil, \"test\")\n\n\t\t\texpect(node).to.be.ok()\n\n\t\t\tnode = noopReconciler.updateVirtualNode(node, true)\n\n\t\t\texpect(node).to.equal(nil)\n\t\tend)\n\tend)\n\n\tdescribe(\"invalid elements\", function()\n\t\tit(\"should throw errors when attempting to mount invalid elements\", function()\n\t\t\t-- These function components return values with incorrect types\n\t\t\tlocal returnsString = function()\n\t\t\t\treturn \"Hello\"\n\t\t\tend\n\t\t\tlocal returnsNumber = function()\n\t\t\t\treturn 1\n\t\t\tend\n\t\t\tlocal returnsFunction = function()\n\t\t\t\treturn function() end\n\t\t\tend\n\t\t\tlocal returnsTable = function()\n\t\t\t\treturn {}\n\t\t\tend\n\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\texpect(function()\n\t\t\t\tnoopReconciler.mountVirtualNode(createElement(returnsString), hostParent, key)\n\t\t\tend).to.throw()\n\n\t\t\texpect(function()\n\t\t\t\tnoopReconciler.mountVirtualNode(createElement(returnsNumber), hostParent, key)\n\t\t\tend).to.throw()\n\n\t\t\texpect(function()\n\t\t\t\tnoopReconciler.mountVirtualNode(createElement(returnsFunction), hostParent, key)\n\t\t\tend).to.throw()\n\n\t\t\texpect(function()\n\t\t\t\tnoopReconciler.mountVirtualNode(createElement(returnsTable), hostParent, key)\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tdescribe(\"Host components\", function()\n\t\tit(\"should invoke the renderer to mount host nodes\", function()\n\t\t\tlocal mountHostNode = createSpy(NoopRenderer.mountHostNode)\n\n\t\t\tlocal renderer = assign({}, NoopRenderer, {\n\t\t\t\tmountHostNode = mountHostNode.value,\n\t\t\t})\n\n\t\t\tlocal reconciler = createReconciler(renderer)\n\n\t\t\tlocal element = createElement(\"StringValue\")\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Some Key\"\n\t\t\tlocal node = reconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(Type.of(node)).to.equal(Type.VirtualNode)\n\n\t\t\texpect(mountHostNode.callCount).to.equal(1)\n\n\t\t\tlocal values = mountHostNode:captureValues(\"reconciler\", \"node\")\n\n\t\t\texpect(values.reconciler).to.equal(reconciler)\n\t\t\texpect(values.node).to.equal(node)\n\t\tend)\n\n\t\tit(\"should invoke the renderer to update host nodes\", function()\n\t\t\tlocal updateHostNode = createSpy(NoopRenderer.updateHostNode)\n\n\t\t\tlocal renderer = assign({}, NoopRenderer, {\n\t\t\t\tmountHostNode = NoopRenderer.mountHostNode,\n\t\t\t\tupdateHostNode = updateHostNode.value,\n\t\t\t})\n\n\t\t\tlocal reconciler = createReconciler(renderer)\n\n\t\t\tlocal element = createElement(\"StringValue\")\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Key\"\n\t\t\tlocal node = reconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(Type.of(node)).to.equal(Type.VirtualNode)\n\n\t\t\tlocal newElement = createElement(\"StringValue\")\n\t\t\tlocal newNode = reconciler.updateVirtualNode(node, newElement)\n\n\t\t\texpect(newNode).to.equal(node)\n\n\t\t\texpect(updateHostNode.callCount).to.equal(1)\n\n\t\t\tlocal values = updateHostNode:captureValues(\"reconciler\", \"node\", \"newElement\")\n\n\t\t\texpect(values.reconciler).to.equal(reconciler)\n\t\t\texpect(values.node).to.equal(node)\n\t\t\texpect(values.newElement).to.equal(newElement)\n\t\tend)\n\n\t\tit(\"should invoke the renderer to unmount host nodes\", function()\n\t\t\tlocal unmountHostNode = createSpy(NoopRenderer.unmountHostNode)\n\n\t\t\tlocal renderer = assign({}, NoopRenderer, {\n\t\t\t\tmountHostNode = NoopRenderer.mountHostNode,\n\t\t\t\tunmountHostNode = unmountHostNode.value,\n\t\t\t})\n\n\t\t\tlocal reconciler = createReconciler(renderer)\n\n\t\t\tlocal element = createElement(\"StringValue\")\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Key\"\n\t\t\tlocal node = reconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(Type.of(node)).to.equal(Type.VirtualNode)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(unmountHostNode.callCount).to.equal(1)\n\n\t\t\tlocal values = unmountHostNode:captureValues(\"reconciler\", \"node\")\n\n\t\t\texpect(values.reconciler).to.equal(reconciler)\n\t\t\texpect(values.node).to.equal(node)\n\t\tend)\n\tend)\n\n\tdescribe(\"Function components\", function()\n\t\tit(\"should mount and unmount function components\", function()\n\t\t\tlocal componentSpy = createSpy(function(_props)\n\t\t\t\treturn nil\n\t\t\tend)\n\n\t\t\tlocal element = createElement(componentSpy.value, {\n\t\t\t\tsomeValue = 5,\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"A Key\"\n\t\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(Type.of(node)).to.equal(Type.VirtualNode)\n\n\t\t\texpect(componentSpy.callCount).to.equal(1)\n\n\t\t\tlocal calledWith = componentSpy:captureValues(\"props\")\n\n\t\t\texpect(calledWith.props).to.be.a(\"table\")\n\t\t\texpect(calledWith.props.someValue).to.equal(5)\n\n\t\t\tnoopReconciler.unmountVirtualNode(node)\n\n\t\t\texpect(componentSpy.callCount).to.equal(1)\n\t\tend)\n\n\t\tit(\"should mount single children of function components\", function()\n\t\t\tlocal childComponentSpy = createSpy(function(_props)\n\t\t\t\treturn nil\n\t\t\tend)\n\n\t\t\tlocal parentComponentSpy = createSpy(function(props)\n\t\t\t\treturn createElement(childComponentSpy.value, {\n\t\t\t\t\tvalue = props.value + 1,\n\t\t\t\t})\n\t\t\tend)\n\n\t\t\tlocal element = createElement(parentComponentSpy.value, {\n\t\t\t\tvalue = 13,\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"A Key\"\n\t\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(Type.of(node)).to.equal(Type.VirtualNode)\n\n\t\t\texpect(parentComponentSpy.callCount).to.equal(1)\n\t\t\texpect(childComponentSpy.callCount).to.equal(1)\n\n\t\t\tlocal parentCalledWith = parentComponentSpy:captureValues(\"props\")\n\t\t\tlocal childCalledWith = childComponentSpy:captureValues(\"props\")\n\n\t\t\texpect(parentCalledWith.props).to.be.a(\"table\")\n\t\t\texpect(parentCalledWith.props.value).to.equal(13)\n\n\t\t\texpect(childCalledWith.props).to.be.a(\"table\")\n\t\t\texpect(childCalledWith.props.value).to.equal(14)\n\n\t\t\tnoopReconciler.unmountVirtualNode(node)\n\n\t\t\texpect(parentComponentSpy.callCount).to.equal(1)\n\t\t\texpect(childComponentSpy.callCount).to.equal(1)\n\t\tend)\n\n\t\tit(\"should mount fragments returned by function components\", function()\n\t\t\tlocal childAComponentSpy = createSpy(function(_props)\n\t\t\t\treturn nil\n\t\t\tend)\n\n\t\t\tlocal childBComponentSpy = createSpy(function(_props)\n\t\t\t\treturn nil\n\t\t\tend)\n\n\t\t\tlocal parentComponentSpy = createSpy(function(props)\n\t\t\t\treturn createFragment({\n\t\t\t\t\tA = createElement(childAComponentSpy.value, {\n\t\t\t\t\t\tvalue = props.value + 1,\n\t\t\t\t\t}),\n\t\t\t\t\tB = createElement(childBComponentSpy.value, {\n\t\t\t\t\t\tvalue = props.value + 5,\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\tend)\n\n\t\t\tlocal element = createElement(parentComponentSpy.value, {\n\t\t\t\tvalue = 17,\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"A Key\"\n\t\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(Type.of(node)).to.equal(Type.VirtualNode)\n\n\t\t\texpect(parentComponentSpy.callCount).to.equal(1)\n\t\t\texpect(childAComponentSpy.callCount).to.equal(1)\n\t\t\texpect(childBComponentSpy.callCount).to.equal(1)\n\n\t\t\tlocal parentCalledWith = parentComponentSpy:captureValues(\"props\")\n\t\t\tlocal childACalledWith = childAComponentSpy:captureValues(\"props\")\n\t\t\tlocal childBCalledWith = childBComponentSpy:captureValues(\"props\")\n\n\t\t\texpect(parentCalledWith.props).to.be.a(\"table\")\n\t\t\texpect(parentCalledWith.props.value).to.equal(17)\n\n\t\t\texpect(childACalledWith.props).to.be.a(\"table\")\n\t\t\texpect(childACalledWith.props.value).to.equal(18)\n\n\t\t\texpect(childBCalledWith.props).to.be.a(\"table\")\n\t\t\texpect(childBCalledWith.props.value).to.equal(22)\n\n\t\t\tnoopReconciler.unmountVirtualNode(node)\n\n\t\t\texpect(parentComponentSpy.callCount).to.equal(1)\n\t\t\texpect(childAComponentSpy.callCount).to.equal(1)\n\t\t\texpect(childBComponentSpy.callCount).to.equal(1)\n\t\tend)\n\tend)\n\n\tdescribe(\"Fragments\", function()\n\t\tit(\"should mount fragments\", function()\n\t\t\tlocal fragment = createFragment({})\n\t\t\tlocal node = noopReconciler.mountVirtualNode(fragment, nil, \"test\")\n\n\t\t\texpect(node).to.be.ok()\n\t\t\texpect(ElementKind.of(node.currentElement)).to.equal(ElementKind.Fragment)\n\t\tend)\n\n\t\tit(\"should mount an empty fragment\", function()\n\t\t\tlocal emptyFragment = createFragment({})\n\t\t\tlocal node = noopReconciler.mountVirtualNode(emptyFragment, nil, \"test\")\n\n\t\t\texpect(node).to.be.ok()\n\t\t\texpect(next(node.children)).to.never.be.ok()\n\t\tend)\n\n\t\tit(\"should mount all fragment's children\", function()\n\t\t\tlocal childComponentSpy = createSpy(function(_props)\n\t\t\t\treturn nil\n\t\t\tend)\n\t\t\tlocal elements = {}\n\t\t\tlocal totalElements = 5\n\n\t\t\tfor i = 1, totalElements do\n\t\t\t\telements[\"key\" .. tostring(i)] = createElement(childComponentSpy.value, {})\n\t\t\tend\n\n\t\t\tlocal fragments = createFragment(elements)\n\t\t\tlocal node = noopReconciler.mountVirtualNode(fragments, nil, \"test\")\n\n\t\t\texpect(node).to.be.ok()\n\t\t\texpect(childComponentSpy.callCount).to.equal(totalElements)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createReconciler",
                        "ClassName": "ModuleScript",
                        "Source": "--!nonstrict\nlocal Type = require(script.Parent.Type)\nlocal ElementKind = require(script.Parent.ElementKind)\nlocal ElementUtils = require(script.Parent.ElementUtils)\nlocal Children = require(script.Parent.PropMarkers.Children)\nlocal Symbol = require(script.Parent.Symbol)\nlocal internalAssert = require(script.Parent.internalAssert)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal InternalData = Symbol.named(\"InternalData\")\n\n--[[\n\tThe reconciler is the mechanism in Roact that constructs the virtual tree\n\tthat later gets turned into concrete objects by the renderer.\n\n\tRoact's reconciler is constructed with the renderer as an argument, which\n\tenables switching to different renderers for different platforms or\n\tscenarios.\n\n\tWhen testing the reconciler itself, it's common to use `NoopRenderer` with\n\tspies replacing some methods. The default (and only) reconciler interface\n\texposed by Roact right now uses `RobloxRenderer`.\n]]\nlocal function createReconciler(renderer)\n\tlocal reconciler\n\tlocal mountVirtualNode\n\tlocal updateVirtualNode\n\tlocal unmountVirtualNode\n\n\t--[[\n\t\tUnmount the given virtualNode, replacing it with a new node described by\n\t\tthe given element.\n\n\t\tPreserves host properties, depth, and legacyContext from parent.\n\t]]\n\tlocal function replaceVirtualNode(virtualNode, newElement)\n\t\tlocal hostParent = virtualNode.hostParent\n\t\tlocal hostKey = virtualNode.hostKey\n\t\tlocal depth = virtualNode.depth\n\t\tlocal parent = virtualNode.parent\n\n\t\t-- If the node that is being replaced has modified context, we need to\n\t\t-- use the original *unmodified* context for the new node\n\t\t-- The `originalContext` field will be nil if the context was unchanged\n\t\tlocal context = virtualNode.originalContext or virtualNode.context\n\t\tlocal parentLegacyContext = virtualNode.parentLegacyContext\n\n\t\t-- If updating this node has caused a component higher up the tree to re-render\n\t\t-- and updateChildren to be re-entered then this node could already have been\n\t\t-- unmounted in the previous updateChildren pass.\n\t\tif not virtualNode.wasUnmounted then\n\t\t\tunmountVirtualNode(virtualNode)\n\t\tend\n\t\tlocal newNode = mountVirtualNode(newElement, hostParent, hostKey, context, parentLegacyContext)\n\n\t\t-- mountVirtualNode can return nil if the element is a boolean\n\t\tif newNode ~= nil then\n\t\t\tnewNode.depth = depth\n\t\t\tnewNode.parent = parent\n\t\tend\n\n\t\treturn newNode\n\tend\n\n\t--[[\n\t\tUtility to update the children of a virtual node based on zero or more\n\t\tupdated children given as elements.\n\t]]\n\tlocal function updateChildren(virtualNode, hostParent, newChildElements)\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #1 to be of type VirtualNode\")\n\t\tend\n\n\t\tvirtualNode.updateChildrenCount = virtualNode.updateChildrenCount + 1\n\n\t\tlocal currentUpdateChildrenCount = virtualNode.updateChildrenCount\n\n\t\tlocal removeKeys = {}\n\n\t\t-- Changed or removed children\n\t\tfor childKey, childNode in pairs(virtualNode.children) do\n\t\t\tlocal newElement = ElementUtils.getElementByKey(newChildElements, childKey)\n\t\t\tlocal newNode = updateVirtualNode(childNode, newElement)\n\n\t\t\t-- If updating this node has caused a component higher up the tree to re-render\n\t\t\t-- and updateChildren to be re-entered for this virtualNode then\n\t\t\t-- this result is invalid and needs to be disgarded.\n\t\t\tif virtualNode.updateChildrenCount ~= currentUpdateChildrenCount then\n\t\t\t\tif newNode and newNode ~= virtualNode.children[childKey] then\n\t\t\t\t\tunmountVirtualNode(newNode)\n\t\t\t\tend\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\tif newNode ~= nil then\n\t\t\t\tvirtualNode.children[childKey] = newNode\n\t\t\telse\n\t\t\t\tremoveKeys[childKey] = true\n\t\t\tend\n\t\tend\n\n\t\tfor childKey in pairs(removeKeys) do\n\t\t\tvirtualNode.children[childKey] = nil\n\t\tend\n\n\t\t-- Added children\n\t\tfor childKey, newElement in ElementUtils.iterateElements(newChildElements) do\n\t\t\tlocal concreteKey = childKey\n\t\t\tif childKey == ElementUtils.UseParentKey then\n\t\t\t\tconcreteKey = virtualNode.hostKey\n\t\t\tend\n\n\t\t\tif virtualNode.children[childKey] == nil then\n\t\t\t\tlocal childNode = mountVirtualNode(\n\t\t\t\t\tnewElement,\n\t\t\t\t\thostParent,\n\t\t\t\t\tconcreteKey,\n\t\t\t\t\tvirtualNode.context,\n\t\t\t\t\tvirtualNode.legacyContext\n\t\t\t\t)\n\n\t\t\t\t-- If updating this node has caused a component higher up the tree to re-render\n\t\t\t\t-- and updateChildren to be re-entered for this virtualNode then\n\t\t\t\t-- this result is invalid and needs to be discarded.\n\t\t\t\tif virtualNode.updateChildrenCount ~= currentUpdateChildrenCount then\n\t\t\t\t\tif childNode then\n\t\t\t\t\t\tunmountVirtualNode(childNode)\n\t\t\t\t\tend\n\t\t\t\t\treturn\n\t\t\t\tend\n\n\t\t\t\t-- mountVirtualNode can return nil if the element is a boolean\n\t\t\t\tif childNode ~= nil then\n\t\t\t\t\tchildNode.depth = virtualNode.depth + 1\n\t\t\t\t\tchildNode.parent = virtualNode\n\t\t\t\t\tvirtualNode.children[childKey] = childNode\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal function updateVirtualNodeWithChildren(virtualNode, hostParent, newChildElements)\n\t\tupdateChildren(virtualNode, hostParent, newChildElements)\n\tend\n\n\tlocal function updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)\n\t\tif Type.of(renderResult) == Type.Element or renderResult == nil or typeof(renderResult) == \"boolean\" then\n\t\t\tupdateChildren(virtualNode, hostParent, renderResult)\n\t\telse\n\t\t\terror(\n\t\t\t\t(\"%s\\n%s\"):format(\n\t\t\t\t\t\"Component returned invalid children:\",\n\t\t\t\t\tvirtualNode.currentElement.source or \"<enable element tracebacks>\"\n\t\t\t\t),\n\t\t\t\t0\n\t\t\t)\n\t\tend\n\tend\n\n\t--[[\n\t\tUnmounts the given virtual node and releases any held resources.\n\t]]\n\tfunction unmountVirtualNode(virtualNode)\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #1 to be of type VirtualNode\")\n\t\tend\n\n\t\tvirtualNode.wasUnmounted = true\n\n\t\tlocal kind = ElementKind.of(virtualNode.currentElement)\n\n\t\t-- selene: allow(if_same_then_else)\n\t\tif kind == ElementKind.Host then\n\t\t\trenderer.unmountHostNode(reconciler, virtualNode)\n\t\telseif kind == ElementKind.Function then\n\t\t\tfor _, childNode in pairs(virtualNode.children) do\n\t\t\t\tunmountVirtualNode(childNode)\n\t\t\tend\n\t\telseif kind == ElementKind.Stateful then\n\t\t\tvirtualNode.instance:__unmount()\n\t\telseif kind == ElementKind.Portal then\n\t\t\tfor _, childNode in pairs(virtualNode.children) do\n\t\t\t\tunmountVirtualNode(childNode)\n\t\t\tend\n\t\telseif kind == ElementKind.Fragment then\n\t\t\tfor _, childNode in pairs(virtualNode.children) do\n\t\t\t\tunmountVirtualNode(childNode)\n\t\t\tend\n\t\telse\n\t\t\terror((\"Unknown ElementKind %q\"):format(tostring(kind)), 2)\n\t\tend\n\tend\n\n\tlocal function updateFunctionVirtualNode(virtualNode, newElement)\n\t\tlocal children = newElement.component(newElement.props)\n\n\t\tupdateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)\n\n\t\treturn virtualNode\n\tend\n\n\tlocal function updatePortalVirtualNode(virtualNode, newElement)\n\t\tlocal oldElement = virtualNode.currentElement\n\t\tlocal oldTargetHostParent = oldElement.props.target\n\n\t\tlocal targetHostParent = newElement.props.target\n\n\t\tassert(renderer.isHostObject(targetHostParent), \"Expected target to be host object\")\n\n\t\tif targetHostParent ~= oldTargetHostParent then\n\t\t\treturn replaceVirtualNode(virtualNode, newElement)\n\t\tend\n\n\t\tlocal children = newElement.props[Children]\n\n\t\tupdateVirtualNodeWithChildren(virtualNode, targetHostParent, children)\n\n\t\treturn virtualNode\n\tend\n\n\tlocal function updateFragmentVirtualNode(virtualNode, newElement)\n\t\tupdateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, newElement.elements)\n\n\t\treturn virtualNode\n\tend\n\n\t--[[\n\t\tUpdate the given virtual node using a new element describing what it\n\t\tshould transform into.\n\n\t\t`updateVirtualNode` will return a new virtual node that should replace\n\t\tthe passed in virtual node. This is because a virtual node can be\n\t\tupdated with an element referencing a different component!\n\n\t\tIn that case, `updateVirtualNode` will unmount the input virtual node,\n\t\tmount a new virtual node, and return it in this case, while also issuing\n\t\ta warning to the user.\n\t]]\n\tfunction updateVirtualNode(virtualNode, newElement, newState)\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #1 to be of type VirtualNode\")\n\t\tend\n\t\tif config.typeChecks then\n\t\t\tassert(\n\t\t\t\tType.of(newElement) == Type.Element or typeof(newElement) == \"boolean\" or newElement == nil,\n\t\t\t\t\"Expected arg #2 to be of type Element, boolean, or nil\"\n\t\t\t)\n\t\tend\n\n\t\t-- If nothing changed, we can skip this update\n\t\tif virtualNode.currentElement == newElement and newState == nil then\n\t\t\treturn virtualNode\n\t\tend\n\n\t\tif typeof(newElement) == \"boolean\" or newElement == nil then\n\t\t\tunmountVirtualNode(virtualNode)\n\t\t\treturn nil\n\t\tend\n\n\t\tif virtualNode.currentElement.component ~= newElement.component then\n\t\t\treturn replaceVirtualNode(virtualNode, newElement)\n\t\tend\n\n\t\tlocal kind = ElementKind.of(newElement)\n\n\t\tlocal shouldContinueUpdate = true\n\n\t\tif kind == ElementKind.Host then\n\t\t\tvirtualNode = renderer.updateHostNode(reconciler, virtualNode, newElement)\n\t\telseif kind == ElementKind.Function then\n\t\t\tvirtualNode = updateFunctionVirtualNode(virtualNode, newElement)\n\t\telseif kind == ElementKind.Stateful then\n\t\t\tshouldContinueUpdate = virtualNode.instance:__update(newElement, newState)\n\t\telseif kind == ElementKind.Portal then\n\t\t\tvirtualNode = updatePortalVirtualNode(virtualNode, newElement)\n\t\telseif kind == ElementKind.Fragment then\n\t\t\tvirtualNode = updateFragmentVirtualNode(virtualNode, newElement)\n\t\telse\n\t\t\terror((\"Unknown ElementKind %q\"):format(tostring(kind)), 2)\n\t\tend\n\n\t\t-- Stateful components can abort updates via shouldUpdate. If that\n\t\t-- happens, we should stop doing stuff at this point.\n\t\tif not shouldContinueUpdate then\n\t\t\treturn virtualNode\n\t\tend\n\n\t\tvirtualNode.currentElement = newElement\n\n\t\treturn virtualNode\n\tend\n\n\t--[[\n\t\tConstructs a new virtual node but not does mount it.\n\t]]\n\tlocal function createVirtualNode(element, hostParent, hostKey, context, legacyContext)\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(\n\t\t\t\trenderer.isHostObject(hostParent) or hostParent == nil,\n\t\t\t\t\"Expected arg #2 to be a host object\"\n\t\t\t)\n\t\t\tinternalAssert(typeof(context) == \"table\" or context == nil, \"Expected arg #4 to be of type table or nil\")\n\t\t\tinternalAssert(\n\t\t\t\ttypeof(legacyContext) == \"table\" or legacyContext == nil,\n\t\t\t\t\"Expected arg #5 to be of type table or nil\"\n\t\t\t)\n\t\tend\n\t\tif config.typeChecks then\n\t\t\tassert(hostKey ~= nil, \"Expected arg #3 to be non-nil\")\n\t\t\tassert(\n\t\t\t\tType.of(element) == Type.Element or typeof(element) == \"boolean\",\n\t\t\t\t\"Expected arg #1 to be of type Element or boolean\"\n\t\t\t)\n\t\tend\n\n\t\treturn {\n\t\t\t[Type] = Type.VirtualNode,\n\t\t\tcurrentElement = element,\n\t\t\tdepth = 1,\n\t\t\tparent = nil,\n\t\t\tchildren = {},\n\t\t\thostParent = hostParent,\n\t\t\thostKey = hostKey,\n\t\t\tupdateChildrenCount = 0,\n\t\t\twasUnmounted = false,\n\n\t\t\t-- Legacy Context API\n\t\t\t-- A table of context values inherited from the parent node\n\t\t\tlegacyContext = legacyContext,\n\n\t\t\t-- A saved copy of the parent context, used when replacing a node\n\t\t\tparentLegacyContext = legacyContext,\n\n\t\t\t-- Context API\n\t\t\t-- A table of context values inherited from the parent node\n\t\t\tcontext = context or {},\n\n\t\t\t-- A saved copy of the unmodified context; this will be updated when\n\t\t\t-- a component adds new context and used when a node is replaced\n\t\t\toriginalContext = nil,\n\t\t}\n\tend\n\n\tlocal function mountFunctionVirtualNode(virtualNode)\n\t\tlocal element = virtualNode.currentElement\n\n\t\tlocal children = element.component(element.props)\n\n\t\tupdateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)\n\tend\n\n\tlocal function mountPortalVirtualNode(virtualNode)\n\t\tlocal element = virtualNode.currentElement\n\n\t\tlocal targetHostParent = element.props.target\n\t\tlocal children = element.props[Children]\n\n\t\tassert(renderer.isHostObject(targetHostParent), \"Expected target to be host object\")\n\n\t\tupdateVirtualNodeWithChildren(virtualNode, targetHostParent, children)\n\tend\n\n\tlocal function mountFragmentVirtualNode(virtualNode)\n\t\tlocal element = virtualNode.currentElement\n\t\tlocal children = element.elements\n\n\t\tupdateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, children)\n\tend\n\n\t--[[\n\t\tConstructs a new virtual node and mounts it, but does not place it into\n\t\tthe tree.\n\t]]\n\tfunction mountVirtualNode(element, hostParent, hostKey, context, legacyContext)\n\t\tif config.internalTypeChecks then\n\t\t\tinternalAssert(\n\t\t\t\trenderer.isHostObject(hostParent) or hostParent == nil,\n\t\t\t\t\"Expected arg #2 to be a host object\"\n\t\t\t)\n\t\t\tinternalAssert(\n\t\t\t\ttypeof(legacyContext) == \"table\" or legacyContext == nil,\n\t\t\t\t\"Expected arg #5 to be of type table or nil\"\n\t\t\t)\n\t\tend\n\t\tif config.typeChecks then\n\t\t\tassert(hostKey ~= nil, \"Expected arg #3 to be non-nil\")\n\t\t\tassert(\n\t\t\t\tType.of(element) == Type.Element or typeof(element) == \"boolean\",\n\t\t\t\t\"Expected arg #1 to be of type Element or boolean\"\n\t\t\t)\n\t\tend\n\n\t\t-- Boolean values render as nil to enable terse conditional rendering.\n\t\tif typeof(element) == \"boolean\" then\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal kind = ElementKind.of(element)\n\n\t\tlocal virtualNode = createVirtualNode(element, hostParent, hostKey, context, legacyContext)\n\n\t\tif kind == ElementKind.Host then\n\t\t\trenderer.mountHostNode(reconciler, virtualNode)\n\t\telseif kind == ElementKind.Function then\n\t\t\tmountFunctionVirtualNode(virtualNode)\n\t\telseif kind == ElementKind.Stateful then\n\t\t\telement.component:__mount(reconciler, virtualNode)\n\t\telseif kind == ElementKind.Portal then\n\t\t\tmountPortalVirtualNode(virtualNode)\n\t\telseif kind == ElementKind.Fragment then\n\t\t\tmountFragmentVirtualNode(virtualNode)\n\t\telse\n\t\t\terror((\"Unknown ElementKind %q\"):format(tostring(kind)), 2)\n\t\tend\n\n\t\treturn virtualNode\n\tend\n\n\t--[[\n\t\tConstructs a new Roact virtual tree, constructs a root node for\n\t\tit, and mounts it.\n\t]]\n\tlocal function mountVirtualTree(element, hostParent, hostKey)\n\t\tif config.typeChecks then\n\t\t\tassert(Type.of(element) == Type.Element, \"Expected arg #1 to be of type Element\")\n\t\t\tassert(renderer.isHostObject(hostParent) or hostParent == nil, \"Expected arg #2 to be a host object\")\n\t\tend\n\n\t\tif hostKey == nil then\n\t\t\thostKey = \"RoactTree\"\n\t\tend\n\n\t\tlocal tree = {\n\t\t\t[Type] = Type.VirtualTree,\n\t\t\t[InternalData] = {\n\t\t\t\t-- The root node of the tree, which starts into the hierarchy of\n\t\t\t\t-- Roact component instances.\n\t\t\t\trootNode = nil,\n\t\t\t\tmounted = true,\n\t\t\t},\n\t\t}\n\n\t\ttree[InternalData].rootNode = mountVirtualNode(element, hostParent, hostKey)\n\n\t\treturn tree\n\tend\n\n\t--[[\n\t\tUnmounts the virtual tree, freeing all of its resources.\n\n\t\tNo further operations should be done on the tree after it's been\n\t\tunmounted, as indicated by its the `mounted` field.\n\t]]\n\tlocal function unmountVirtualTree(tree)\n\t\tlocal internalData = tree[InternalData]\n\t\tif config.typeChecks then\n\t\t\tassert(Type.of(tree) == Type.VirtualTree, \"Expected arg #1 to be a Roact handle\")\n\t\t\tassert(internalData.mounted, \"Cannot unmounted a Roact tree that has already been unmounted\")\n\t\tend\n\n\t\tinternalData.mounted = false\n\n\t\tif internalData.rootNode ~= nil then\n\t\t\tunmountVirtualNode(internalData.rootNode)\n\t\tend\n\tend\n\n\t--[[\n\t\tUtility method for updating the root node of a virtual tree given a new\n\t\telement.\n\t]]\n\tlocal function updateVirtualTree(tree, newElement)\n\t\tlocal internalData = tree[InternalData]\n\t\tif config.typeChecks then\n\t\t\tassert(Type.of(tree) == Type.VirtualTree, \"Expected arg #1 to be a Roact handle\")\n\t\t\tassert(Type.of(newElement) == Type.Element, \"Expected arg #2 to be a Roact Element\")\n\t\tend\n\n\t\tinternalData.rootNode = updateVirtualNode(internalData.rootNode, newElement)\n\n\t\treturn tree\n\tend\n\n\treconciler = {\n\t\tmountVirtualTree = mountVirtualTree,\n\t\tunmountVirtualTree = unmountVirtualTree,\n\t\tupdateVirtualTree = updateVirtualTree,\n\n\t\tcreateVirtualNode = createVirtualNode,\n\t\tmountVirtualNode = mountVirtualNode,\n\t\tunmountVirtualNode = unmountVirtualNode,\n\t\tupdateVirtualNode = updateVirtualNode,\n\t\tupdateVirtualNodeWithChildren = updateVirtualNodeWithChildren,\n\t\tupdateVirtualNodeWithRenderResult = updateVirtualNodeWithRenderResult,\n\t}\n\n\treturn reconciler\nend\n\nreturn createReconciler\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createFragment.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal ElementKind = require(script.Parent.ElementKind)\n\tlocal Type = require(script.Parent.Type)\n\n\tlocal createFragment = require(script.Parent.createFragment)\n\n\tit(\"should create new primitive elements\", function()\n\t\tlocal fragment = createFragment({})\n\n\t\texpect(fragment).to.be.ok()\n\t\texpect(Type.of(fragment)).to.equal(Type.Element)\n\t\texpect(ElementKind.of(fragment)).to.equal(ElementKind.Fragment)\n\tend)\n\n\tit(\"should accept children\", function()\n\t\tlocal subFragment = createFragment({})\n\t\tlocal fragment = createFragment({ key = subFragment })\n\n\t\texpect(fragment.elements.key).to.equal(subFragment)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createFragment",
                        "ClassName": "ModuleScript",
                        "Source": "local ElementKind = require(script.Parent.ElementKind)\nlocal Type = require(script.Parent.Type)\n\nlocal function createFragment(elements)\n\treturn {\n\t\t[Type] = Type.Element,\n\t\t[ElementKind] = ElementKind.Fragment,\n\t\telements = elements,\n\t}\nend\n\nreturn createFragment\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createElement.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal Component = require(script.Parent.Component)\n\tlocal ElementKind = require(script.Parent.ElementKind)\n\tlocal GlobalConfig = require(script.Parent.GlobalConfig)\n\tlocal Logging = require(script.Parent.Logging)\n\tlocal Type = require(script.Parent.Type)\n\tlocal Portal = require(script.Parent.Portal)\n\tlocal Children = require(script.Parent.PropMarkers.Children)\n\n\tlocal createElement = require(script.Parent.createElement)\n\n\tit(\"should create new primitive elements\", function()\n\t\tlocal element = createElement(\"Frame\")\n\n\t\texpect(element).to.be.ok()\n\t\texpect(Type.of(element)).to.equal(Type.Element)\n\t\texpect(ElementKind.of(element)).to.equal(ElementKind.Host)\n\tend)\n\n\tit(\"should create new functional elements\", function()\n\t\tlocal element = createElement(function() end)\n\n\t\texpect(element).to.be.ok()\n\t\texpect(Type.of(element)).to.equal(Type.Element)\n\t\texpect(ElementKind.of(element)).to.equal(ElementKind.Function)\n\tend)\n\n\tit(\"should create new stateful components\", function()\n\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\tlocal element = createElement(Foo)\n\n\t\texpect(element).to.be.ok()\n\t\texpect(Type.of(element)).to.equal(Type.Element)\n\t\texpect(ElementKind.of(element)).to.equal(ElementKind.Stateful)\n\tend)\n\n\tit(\"should create new portal elements\", function()\n\t\tlocal element = createElement(Portal)\n\n\t\texpect(element).to.be.ok()\n\t\texpect(Type.of(element)).to.equal(Type.Element)\n\t\texpect(ElementKind.of(element)).to.equal(ElementKind.Portal)\n\tend)\n\n\tit(\"should accept props\", function()\n\t\tlocal element = createElement(\"StringValue\", {\n\t\t\tValue = \"Foo\",\n\t\t})\n\n\t\texpect(element).to.be.ok()\n\t\texpect(element.props.Value).to.equal(\"Foo\")\n\tend)\n\n\tit(\"should accept props and children\", function()\n\t\tlocal child = createElement(\"IntValue\")\n\n\t\tlocal element = createElement(\"StringValue\", {\n\t\t\tValue = \"Foo\",\n\t\t}, {\n\t\t\tChild = child,\n\t\t})\n\n\t\texpect(element).to.be.ok()\n\t\texpect(element.props.Value).to.equal(\"Foo\")\n\t\texpect(element.props[Children]).to.be.ok()\n\t\texpect(element.props[Children].Child).to.equal(child)\n\tend)\n\n\tit(\"should accept children with without props\", function()\n\t\tlocal child = createElement(\"IntValue\")\n\n\t\tlocal element = createElement(\"StringValue\", nil, {\n\t\t\tChild = child,\n\t\t})\n\n\t\texpect(element).to.be.ok()\n\t\texpect(element.props[Children]).to.be.ok()\n\t\texpect(element.props[Children].Child).to.equal(child)\n\tend)\n\n\tit(\"should warn once if children is specified in two different ways\", function()\n\t\tlocal logInfo = Logging.capture(function()\n\t\t\t-- Using a loop here to ensure that multiple occurences of the same\n\t\t\t-- warning only cause output once.\n\t\t\tfor _ = 1, 2 do\n\t\t\t\tcreateElement(\"Frame\", {\n\t\t\t\t\t[Children] = {},\n\t\t\t\t}, {})\n\t\t\tend\n\t\tend)\n\n\t\texpect(#logInfo.warnings).to.equal(1)\n\t\texpect(logInfo.warnings[1]:find(\"createElement\")).to.be.ok()\n\t\texpect(logInfo.warnings[1]:find(\"Children\")).to.be.ok()\n\tend)\n\n\tit(\"should have a `source` member if elementTracing is set\", function()\n\t\tlocal config = {\n\t\t\telementTracing = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal element = createElement(\"StringValue\")\n\n\t\t\texpect(element.source).to.be.a(\"string\")\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createElement",
                        "ClassName": "ModuleScript",
                        "Source": "local Children = require(script.Parent.PropMarkers.Children)\nlocal ElementKind = require(script.Parent.ElementKind)\nlocal Logging = require(script.Parent.Logging)\nlocal Type = require(script.Parent.Type)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal multipleChildrenMessage = [[\nThe prop `Roact.Children` was defined but was overriden by the third parameter to createElement!\nThis can happen when a component passes props through to a child element but also uses the `children` argument:\n\n\tRoact.createElement(\"Frame\", passedProps, {\n\t\tchild = ...\n\t})\n\nInstead, consider using a utility function to merge tables of children together:\n\n\tlocal children = mergeTables(passedProps[Roact.Children], {\n\t\tchild = ...\n\t})\n\n\tlocal fullProps = mergeTables(passedProps, {\n\t\t[Roact.Children] = children\n\t})\n\n\tRoact.createElement(\"Frame\", fullProps)]]\n\n--[[\n\tCreates a new element representing the given component.\n\n\tElements are lightweight representations of what a component instance should\n\tlook like.\n\n\tChildren is a shorthand for specifying `Roact.Children` as a key inside\n\tprops. If specified, the passed `props` table is mutated!\n]]\nlocal function createElement(component, props, children)\n\tif config.typeChecks then\n\t\tassert(component ~= nil, \"`component` is required\")\n\t\tassert(typeof(props) == \"table\" or props == nil, \"`props` must be a table or nil\")\n\t\tassert(typeof(children) == \"table\" or children == nil, \"`children` must be a table or nil\")\n\tend\n\n\tif props == nil then\n\t\tprops = {}\n\tend\n\n\tif children ~= nil then\n\t\tif props[Children] ~= nil then\n\t\t\tLogging.warnOnce(multipleChildrenMessage)\n\t\tend\n\n\t\tprops[Children] = children\n\tend\n\n\tlocal elementKind = ElementKind.fromComponent(component)\n\n\tlocal element = {\n\t\t[Type] = Type.Element,\n\t\t[ElementKind] = elementKind,\n\t\tcomponent = component,\n\t\tprops = props,\n\t}\n\n\tif config.elementTracing then\n\t\t-- We trim out the leading newline since there's no way to specify the\n\t\t-- trace level without also specifying a message.\n\t\telement.source = debug.traceback(\"\", 2):sub(2)\n\tend\n\n\treturn element\nend\n\nreturn createElement\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createContext.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n\tlocal Component = require(script.Parent.Component)\n\tlocal NoopRenderer = require(script.Parent.NoopRenderer)\n\tlocal Children = require(script.Parent.PropMarkers.Children)\n\tlocal createContext = require(script.Parent.createContext)\n\tlocal createElement = require(script.Parent.createElement)\n\tlocal createFragment = require(script.Parent.createFragment)\n\tlocal createReconciler = require(script.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.createSpy)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tlocal RobloxRenderer = require(script.Parent.RobloxRenderer)\n\tlocal robloxReconciler = createReconciler(RobloxRenderer)\n\n\tit(\"should return a table\", function()\n\t\tlocal context = createContext(\"Test\")\n\t\texpect(context).to.be.ok()\n\t\texpect(type(context)).to.equal(\"table\")\n\tend)\n\n\tit(\"should contain a Provider and a Consumer\", function()\n\t\tlocal context = createContext(\"Test\")\n\t\texpect(context.Provider).to.be.ok()\n\t\texpect(context.Consumer).to.be.ok()\n\tend)\n\n\tdescribe(\"Provider\", function()\n\t\tit(\"should render its children\", function()\n\t\t\tlocal context = createContext(\"Test\")\n\n\t\t\tlocal Listener = createSpy(function()\n\t\t\t\treturn nil\n\t\t\tend)\n\n\t\t\tlocal element = createElement(context.Provider, {\n\t\t\t\tvalue = \"Test\",\n\t\t\t}, {\n\t\t\t\tListener = createElement(Listener.value),\n\t\t\t})\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(element, nil, \"Provide Tree\")\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\n\t\t\texpect(Listener.callCount).to.equal(1)\n\t\tend)\n\tend)\n\n\tdescribe(\"Consumer\", function()\n\t\tit(\"should expect a render function\", function()\n\t\t\tlocal context = createContext(\"Test\")\n\t\t\tlocal element = createElement(context.Consumer)\n\n\t\t\texpect(function()\n\t\t\t\tnoopReconciler.mountVirtualTree(element, nil, \"Provide Tree\")\n\t\t\tend).to.throw()\n\t\tend)\n\n\t\tit(\"should return the default value if there is no Provider\", function()\n\t\t\tlocal valueSpy = createSpy()\n\t\t\tlocal context = createContext(\"Test\")\n\n\t\t\tlocal element = createElement(context.Consumer, {\n\t\t\t\trender = valueSpy.value,\n\t\t\t})\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(element, nil, \"Provide Tree\")\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\n\t\t\tvalueSpy:assertCalledWith(\"Test\")\n\t\tend)\n\n\t\tit(\"should pass the value to the render function\", function()\n\t\t\tlocal valueSpy = createSpy()\n\t\t\tlocal context = createContext(\"Test\")\n\n\t\t\tlocal function Listener()\n\t\t\t\treturn createElement(context.Consumer, {\n\t\t\t\t\trender = valueSpy.value,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(context.Provider, {\n\t\t\t\tvalue = \"NewTest\",\n\t\t\t}, {\n\t\t\t\tListener = createElement(Listener),\n\t\t\t})\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(element, nil, \"Provide Tree\")\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\n\t\t\tvalueSpy:assertCalledWith(\"NewTest\")\n\t\tend)\n\n\t\tit(\"should update when the value updates\", function()\n\t\t\tlocal valueSpy = createSpy()\n\t\t\tlocal context = createContext(\"Test\")\n\n\t\t\tlocal function Listener()\n\t\t\t\treturn createElement(context.Consumer, {\n\t\t\t\t\trender = valueSpy.value,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(context.Provider, {\n\t\t\t\tvalue = \"NewTest\",\n\t\t\t}, {\n\t\t\t\tListener = createElement(Listener),\n\t\t\t})\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(element, nil, \"Provide Tree\")\n\n\t\t\texpect(valueSpy.callCount).to.equal(1)\n\t\t\tvalueSpy:assertCalledWith(\"NewTest\")\n\n\t\t\tnoopReconciler.updateVirtualTree(\n\t\t\t\ttree,\n\t\t\t\tcreateElement(context.Provider, {\n\t\t\t\t\tvalue = \"ThirdTest\",\n\t\t\t\t}, {\n\t\t\t\t\tListener = createElement(Listener),\n\t\t\t\t})\n\t\t\t)\n\n\t\t\texpect(valueSpy.callCount).to.equal(2)\n\t\t\tvalueSpy:assertCalledWith(\"ThirdTest\")\n\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\t\tend)\n\n\t\t--[[\n\t\t\tThis test is the same as the one above, but with a component that\n\t\t\talways blocks updates in the middle. We expect behavior to be the\n\t\t\tsame.\n\t\t]]\n\t\tit(\"should update when the value updates through an update blocking component\", function()\n\t\t\tlocal valueSpy = createSpy()\n\t\t\tlocal context = createContext(\"Test\")\n\n\t\t\tlocal UpdateBlocker = Component:extend(\"UpdateBlocker\")\n\n\t\t\tfunction UpdateBlocker:render()\n\t\t\t\treturn createFragment(self.props[Children])\n\t\t\tend\n\n\t\t\tfunction UpdateBlocker:shouldUpdate()\n\t\t\t\treturn false\n\t\t\tend\n\n\t\t\tlocal function Listener()\n\t\t\t\treturn createElement(context.Consumer, {\n\t\t\t\t\trender = valueSpy.value,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(context.Provider, {\n\t\t\t\tvalue = \"NewTest\",\n\t\t\t}, {\n\t\t\t\tBlocker = createElement(UpdateBlocker, nil, {\n\t\t\t\t\tListener = createElement(Listener),\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(element, nil, \"Provide Tree\")\n\n\t\t\texpect(valueSpy.callCount).to.equal(1)\n\t\t\tvalueSpy:assertCalledWith(\"NewTest\")\n\n\t\t\tnoopReconciler.updateVirtualTree(\n\t\t\t\ttree,\n\t\t\t\tcreateElement(context.Provider, {\n\t\t\t\t\tvalue = \"ThirdTest\",\n\t\t\t\t}, {\n\t\t\t\t\tBlocker = createElement(UpdateBlocker, nil, {\n\t\t\t\t\t\tListener = createElement(Listener),\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\t)\n\n\t\t\texpect(valueSpy.callCount).to.equal(2)\n\t\t\tvalueSpy:assertCalledWith(\"ThirdTest\")\n\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\t\tend)\n\n\t\tit(\"should behave correctly when the default value is nil\", function()\n\t\t\tlocal context = createContext(nil)\n\n\t\t\tlocal valueSpy = createSpy()\n\t\t\tlocal function Listener()\n\t\t\t\treturn createElement(context.Consumer, {\n\t\t\t\t\trender = valueSpy.value,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(createElement(Listener), nil, \"Provide Tree\")\n\t\t\texpect(valueSpy.callCount).to.equal(1)\n\t\t\tvalueSpy:assertCalledWith(nil)\n\n\t\t\ttree = noopReconciler.updateVirtualTree(tree, createElement(Listener))\n\t\t\tnoopReconciler.unmountVirtualTree(tree)\n\n\t\t\texpect(valueSpy.callCount).to.equal(2)\n\t\t\tvalueSpy:assertCalledWith(nil)\n\t\tend)\n\tend)\n\n\tdescribe(\"Update order\", function()\n\t\t--[[\n\t\t\tThis test ensures that there is no scenario where we can observe\n\t\t\t'update tearing' when props and context are updated at the same\n\t\t\ttime.\n\n\t\t\tUpdate tearing is scenario where a single update is partially\n\t\t\tapplied in multiple steps instead of atomically. This is observable\n\t\t\tby components and can lead to strange bugs or errors.\n\n\t\t\tThis instance of update tearing happens when updating a prop and a\n\t\t\tcontext value in the same update. Image we represent our tree's\n\t\t\tstate as the current prop and context versions. Our initial state\n\t\t\tis:\n\n\t\t\t(prop_1, context_1)\n\n\t\t\tThe next state we would like to update to is:\n\n\t\t\t(prop_2, context_2)\n\n\t\t\tUnder the bug reported in issue 259, Roact reaches three different\n\t\t\tstates in sequence:\n\n\t\t\t1: (prop_1, context_1) - the initial state\n\t\t\t2: (prop_2, context_1) - woops!\n\t\t\t3: (prop_2, context_2) - correct end state\n\n\t\t\tIn state 2, a user component was added that tried to access the\n\t\t\tcurrent context value, which was not set at the time. This raised an\n\t\t\terror, because this state is not valid!\n\n\t\t\tThe first proposed solution was to move the context update to happen\n\t\t\tbefore the props update. It is easy to show that this will still\n\t\t\tresult in update tearing:\n\n\t\t\t1: (prop_1, context_1)\n\t\t\t2: (prop_1, context_2)\n\t\t\t3: (prop_2, context_2)\n\n\t\t\tAlthough the initial concern about newly added components observing\n\t\t\told context values is fixed, there is still a state\n\t\t\tdesynchronization between props and state.\n\n\t\t\tWe would instead like the following update sequence:\n\n\t\t\t1: (prop_1, context_1)\n\t\t\t2: (prop_2, context_2)\n\n\t\t\tThis test tries to ensure that is the case.\n\n\t\t\tThe initial bug report is here:\n\t\t\thttps://github.com/Roblox/roact/issues/259\n\t\t]]\n\t\tit(\"should update context at the same time as props\", function()\n\t\t\t-- These values are used to make sure we reach both the first and\n\t\t\t-- second state combinations we want to visit.\n\t\t\tlocal observedA = false\n\t\t\tlocal observedB = false\n\t\t\tlocal updateCount = 0\n\n\t\t\tlocal context = createContext(\"default\")\n\n\t\t\tlocal function Listener(props)\n\t\t\t\treturn createElement(context.Consumer, {\n\t\t\t\t\trender = function(value)\n\t\t\t\t\t\tupdateCount = updateCount + 1\n\n\t\t\t\t\t\tif value == \"context_1\" then\n\t\t\t\t\t\t\texpect(props.someProp).to.equal(\"prop_1\")\n\t\t\t\t\t\t\tobservedA = true\n\t\t\t\t\t\telseif value == \"context_2\" then\n\t\t\t\t\t\t\texpect(props.someProp).to.equal(\"prop_2\")\n\t\t\t\t\t\t\tobservedB = true\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\terror(\"Unexpected context value\")\n\t\t\t\t\t\tend\n\t\t\t\t\tend,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element1 = createElement(context.Provider, {\n\t\t\t\tvalue = \"context_1\",\n\t\t\t}, {\n\t\t\t\tChild = createElement(Listener, {\n\t\t\t\t\tsomeProp = \"prop_1\",\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal element2 = createElement(context.Provider, {\n\t\t\t\tvalue = \"context_2\",\n\t\t\t}, {\n\t\t\t\tChild = createElement(Listener, {\n\t\t\t\t\tsomeProp = \"prop_2\",\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(element1, nil, \"UpdateObservationIsFun\")\n\t\t\tnoopReconciler.updateVirtualTree(tree, element2)\n\n\t\t\texpect(updateCount).to.equal(2)\n\t\t\texpect(observedA).to.equal(true)\n\t\t\texpect(observedB).to.equal(true)\n\t\tend)\n\tend)\n\n\t-- issue https://github.com/Roblox/roact/issues/319\n\tit(\"does not throw if willUnmount is called twice on a context consumer\", function()\n\t\tlocal context = createContext({})\n\n\t\tlocal LowestComponent = Component:extend(\"LowestComponent\")\n\t\tfunction LowestComponent:init() end\n\n\t\tfunction LowestComponent:render()\n\t\t\treturn createElement(\"Frame\")\n\t\tend\n\n\t\tfunction LowestComponent:didMount()\n\t\t\tself.props.onDidMountCallback()\n\t\tend\n\n\t\tlocal FirstComponent = Component:extend(\"FirstComponent\")\n\t\tfunction FirstComponent:init() end\n\n\t\tfunction FirstComponent:render()\n\t\t\treturn createElement(context.Consumer, {\n\t\t\t\trender = function()\n\t\t\t\t\treturn createElement(\"TextLabel\")\n\t\t\t\tend,\n\t\t\t})\n\t\tend\n\n\t\tlocal ChildComponent = Component:extend(\"ChildComponent\")\n\n\t\tfunction ChildComponent:init()\n\t\t\tself:setState({ firstTime = true })\n\t\tend\n\n\t\tlocal childCallback\n\n\t\tfunction ChildComponent:render()\n\t\t\tif self.state.firstTime then\n\t\t\t\treturn createElement(FirstComponent)\n\t\t\tend\n\n\t\t\treturn createElement(LowestComponent, {\n\t\t\t\tonDidMountCallback = self.props.onDidMountCallback,\n\t\t\t})\n\t\tend\n\n\t\tfunction ChildComponent:didMount()\n\t\t\tchildCallback = function()\n\t\t\t\tself:setState({ firstTime = false })\n\t\t\tend\n\t\tend\n\n\t\tlocal ParentComponent = Component:extend(\"ParentComponent\")\n\n\t\tlocal didMountCallbackCalled = 0\n\n\t\tfunction ParentComponent:init()\n\t\t\tself:setState({ count = 1 })\n\n\t\t\tself.onDidMountCallback = function()\n\t\t\t\tdidMountCallbackCalled = didMountCallbackCalled + 1\n\t\t\t\tif self.state.count < 5 then\n\t\t\t\t\tself:setState({ count = self.state.count + 1 })\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tfunction ParentComponent:render()\n\t\t\treturn createElement(\"Frame\", {}, {\n\t\t\t\tProvider = createElement(context.Provider, {\n\t\t\t\t\tvalue = {},\n\t\t\t\t}, {\n\t\t\t\t\tChildComponent = createElement(ChildComponent, {\n\t\t\t\t\t\tcount = self.state.count,\n\t\t\t\t\t\tonDidMountCallback = self.onDidMountCallback,\n\t\t\t\t\t}),\n\t\t\t\t}),\n\t\t\t})\n\t\tend\n\n\t\tlocal parent = Instance.new(\"ScreenGui\")\n\t\tparent.Parent = ReplicatedStorage\n\n\t\tlocal hostKey = \"Some Key\"\n\t\trobloxReconciler.mountVirtualNode(createElement(ParentComponent), parent, hostKey)\n\n\t\texpect(function()\n\t\t\t-- calling setState on ChildComponent will trigger `willUnmount` multiple times\n\t\t\tchildCallback()\n\t\tend).never.to.throw()\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "createContext",
                        "ClassName": "ModuleScript",
                        "Source": "local Symbol = require(script.Parent.Symbol)\nlocal createFragment = require(script.Parent.createFragment)\nlocal createSignal = require(script.Parent.createSignal)\nlocal Children = require(script.Parent.PropMarkers.Children)\nlocal Component = require(script.Parent.Component)\n\n--[[\n\tConstruct the value that is assigned to Roact's context storage.\n]]\nlocal function createContextEntry(currentValue)\n\treturn {\n\t\tvalue = currentValue,\n\t\tonUpdate = createSignal(),\n\t}\nend\n\nlocal function createProvider(context)\n\tlocal Provider = Component:extend(\"Provider\")\n\n\tfunction Provider:init(props)\n\t\tself.contextEntry = createContextEntry(props.value)\n\t\tself:__addContext(context.key, self.contextEntry)\n\tend\n\n\tfunction Provider:willUpdate(nextProps)\n\t\t-- If the provided value changed, immediately update the context entry.\n\t\t--\n\t\t-- During this update, any components that are reachable will receive\n\t\t-- this updated value at the same time as any props and state updates\n\t\t-- that are being applied.\n\t\tif nextProps.value ~= self.props.value then\n\t\t\tself.contextEntry.value = nextProps.value\n\t\tend\n\tend\n\n\tfunction Provider:didUpdate(prevProps)\n\t\t-- If the provided value changed, after we've updated every reachable\n\t\t-- component, fire a signal to update the rest.\n\t\t--\n\t\t-- This signal will notify all context consumers. It's expected that\n\t\t-- they will compare the last context value they updated with and only\n\t\t-- trigger an update on themselves if this value is different.\n\t\t--\n\t\t-- This codepath will generally only update consumer components that has\n\t\t-- a component implementing shouldUpdate between them and the provider.\n\t\tif prevProps.value ~= self.props.value then\n\t\t\tself.contextEntry.onUpdate:fire(self.props.value)\n\t\tend\n\tend\n\n\tfunction Provider:render()\n\t\treturn createFragment(self.props[Children])\n\tend\n\n\treturn Provider\nend\n\nlocal function createConsumer(context)\n\tlocal Consumer = Component:extend(\"Consumer\")\n\n\tfunction Consumer.validateProps(props)\n\t\tif type(props.render) ~= \"function\" then\n\t\t\treturn false, \"Consumer expects a `render` function\"\n\t\telse\n\t\t\treturn true\n\t\tend\n\tend\n\n\tfunction Consumer:init(_props)\n\t\t-- This value may be nil, which indicates that our consumer is not a\n\t\t-- descendant of a provider for this context item.\n\t\tself.contextEntry = self:__getContext(context.key)\n\tend\n\n\tfunction Consumer:render()\n\t\t-- Render using the latest available for this context item.\n\t\t--\n\t\t-- We don't store this value in state in order to have more fine-grained\n\t\t-- control over our update behavior.\n\t\tlocal value\n\t\tif self.contextEntry ~= nil then\n\t\t\tvalue = self.contextEntry.value\n\t\telse\n\t\t\tvalue = context.defaultValue\n\t\tend\n\n\t\treturn self.props.render(value)\n\tend\n\n\tfunction Consumer:didUpdate()\n\t\t-- Store the value that we most recently updated with.\n\t\t--\n\t\t-- This value is compared in the contextEntry onUpdate hook below.\n\t\tif self.contextEntry ~= nil then\n\t\t\tself.lastValue = self.contextEntry.value\n\t\tend\n\tend\n\n\tfunction Consumer:didMount()\n\t\tif self.contextEntry ~= nil then\n\t\t\t-- When onUpdate is fired, a new value has been made available in\n\t\t\t-- this context entry, but we may have already updated in the same\n\t\t\t-- update cycle.\n\t\t\t--\n\t\t\t-- To avoid sending a redundant update, we compare the new value\n\t\t\t-- with the last value that we updated with (set in didUpdate) and\n\t\t\t-- only update if they differ. This may happen when an update from a\n\t\t\t-- provider was blocked by an intermediate component that returned\n\t\t\t-- false from shouldUpdate.\n\t\t\tself.disconnect = self.contextEntry.onUpdate:subscribe(function(newValue)\n\t\t\t\tif newValue ~= self.lastValue then\n\t\t\t\t\t-- Trigger a dummy state update.\n\t\t\t\t\tself:setState({})\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\tend\n\n\tfunction Consumer:willUnmount()\n\t\tif self.disconnect ~= nil then\n\t\t\tself.disconnect()\n\t\t\tself.disconnect = nil\n\t\tend\n\tend\n\n\treturn Consumer\nend\n\nlocal Context = {}\nContext.__index = Context\n\nfunction Context.new(defaultValue)\n\treturn setmetatable({\n\t\tdefaultValue = defaultValue,\n\t\tkey = Symbol.named(\"ContextKey\"),\n\t}, Context)\nend\n\nfunction Context:__tostring()\n\treturn \"RoactContext\"\nend\n\nlocal function createContext(defaultValue)\n\tlocal context = Context.new(defaultValue)\n\n\treturn {\n\t\tProvider = createProvider(context),\n\t\tConsumer = createConsumer(context),\n\t}\nend\n\nreturn createContext\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "assign.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal None = require(script.Parent.None)\n\n\tlocal assign = require(script.Parent.assign)\n\n\tit(\"should accept zero additional tables\", function()\n\t\tlocal input = {}\n\t\tlocal result = assign(input)\n\n\t\texpect(input).to.equal(result)\n\tend)\n\n\tit(\"should merge multiple tables onto the given target table\", function()\n\t\tlocal target = {\n\t\t\ta = 5,\n\t\t\tb = 6,\n\t\t}\n\n\t\tlocal source1 = {\n\t\t\tb = 7,\n\t\t\tc = 8,\n\t\t}\n\n\t\tlocal source2 = {\n\t\t\tb = 8,\n\t\t}\n\n\t\tassign(target, source1, source2)\n\n\t\texpect(target.a).to.equal(5)\n\t\texpect(target.b).to.equal(source2.b)\n\t\texpect(target.c).to.equal(source1.c)\n\tend)\n\n\tit(\"should remove keys if specified as None\", function()\n\t\tlocal target = {\n\t\t\tfoo = 2,\n\t\t\tbar = 3,\n\t\t}\n\n\t\tlocal source = {\n\t\t\tfoo = None,\n\t\t}\n\n\t\tassign(target, source)\n\n\t\texpect(target.foo).to.equal(nil)\n\t\texpect(target.bar).to.equal(3)\n\tend)\n\n\tit(\"should re-add keys if specified after None\", function()\n\t\tlocal target = {\n\t\t\tfoo = 2,\n\t\t}\n\n\t\tlocal source1 = {\n\t\t\tfoo = None,\n\t\t}\n\n\t\tlocal source2 = {\n\t\t\tfoo = 3,\n\t\t}\n\n\t\tassign(target, source1, source2)\n\n\t\texpect(target.foo).to.equal(source2.foo)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "assign",
                        "ClassName": "ModuleScript",
                        "Source": "local None = require(script.Parent.None)\n\n--[[\n\tMerges values from zero or more tables onto a target table. If a value is\n\tset to None, it will instead be removed from the table.\n\n\tThis function is identical in functionality to JavaScript's Object.assign.\n]]\nlocal function assign(target, ...)\n\tfor index = 1, select(\"#\", ...) do\n\t\tlocal source = select(index, ...)\n\n\t\tif source ~= nil then\n\t\t\tfor key, value in pairs(source) do\n\t\t\t\tif value == None then\n\t\t\t\t\ttarget[key] = nil\n\t\t\t\telse\n\t\t\t\t\ttarget[key] = value\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\treturn target\nend\n\nreturn assign\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "assertDeepEqual.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.assertDeepEqual)\n\n\tit(\"should fail with a message when args are not equal\", function()\n\t\tlocal success, message = pcall(assertDeepEqual, 1, 2)\n\n\t\texpect(success).to.equal(false)\n\t\texpect(message:find(\"first ~= second\")).to.be.ok()\n\n\t\tsuccess, message = pcall(assertDeepEqual, {\n\t\t\tfoo = 1,\n\t\t}, {\n\t\t\tfoo = 2,\n\t\t})\n\n\t\texpect(success).to.equal(false)\n\t\texpect(message:find(\"first%[foo%] ~= second%[foo%]\")).to.be.ok()\n\tend)\n\n\tit(\"should compare non-table values using standard '==' equality\", function()\n\t\tassertDeepEqual(1, 1)\n\t\tassertDeepEqual(\"hello\", \"hello\")\n\t\tassertDeepEqual(nil, nil)\n\n\t\tlocal someFunction = function() end\n\t\tlocal theSameFunction = someFunction\n\n\t\tassertDeepEqual(someFunction, theSameFunction)\n\n\t\tlocal A = {\n\t\t\tfoo = someFunction,\n\t\t}\n\t\tlocal B = {\n\t\t\tfoo = theSameFunction,\n\t\t}\n\n\t\tassertDeepEqual(A, B)\n\tend)\n\n\tit(\"should fail when types differ\", function()\n\t\tlocal success, message = pcall(assertDeepEqual, 1, \"1\")\n\n\t\texpect(success).to.equal(false)\n\t\texpect(message:find(\"first is of type number, but second is of type string\")).to.be.ok()\n\tend)\n\n\tit(\"should compare (and report about) nested tables\", function()\n\t\tlocal A = {\n\t\t\tfoo = \"bar\",\n\t\t\tnested = {\n\t\t\t\tfoo = 1,\n\t\t\t\tbar = 2,\n\t\t\t},\n\t\t}\n\t\tlocal B = {\n\t\t\tfoo = \"bar\",\n\t\t\tnested = {\n\t\t\t\tfoo = 1,\n\t\t\t\tbar = 2,\n\t\t\t},\n\t\t}\n\n\t\tassertDeepEqual(A, B)\n\n\t\tlocal C = {\n\t\t\tfoo = \"bar\",\n\t\t\tnested = {\n\t\t\t\tfoo = 1,\n\t\t\t\tbar = 3,\n\t\t\t},\n\t\t}\n\n\t\tlocal success, message = pcall(assertDeepEqual, A, C)\n\n\t\texpect(success).to.equal(false)\n\t\texpect(message:find(\"first%[nested%]%[bar%] ~= second%[nested%]%[bar%]\")).to.be.ok()\n\tend)\n\n\tit(\"should be commutative\", function()\n\t\tlocal equalArgsA = {\n\t\t\tfoo = \"bar\",\n\t\t\thello = \"world\",\n\t\t}\n\t\tlocal equalArgsB = {\n\t\t\tfoo = \"bar\",\n\t\t\thello = \"world\",\n\t\t}\n\n\t\tassertDeepEqual(equalArgsA, equalArgsB)\n\t\tassertDeepEqual(equalArgsB, equalArgsA)\n\n\t\tlocal nonEqualArgs = {\n\t\t\tfoo = \"bar\",\n\t\t}\n\n\t\texpect(function()\n\t\t\tassertDeepEqual(equalArgsA, nonEqualArgs)\n\t\tend).to.throw()\n\t\texpect(function()\n\t\t\tassertDeepEqual(nonEqualArgs, equalArgsA)\n\t\tend).to.throw()\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "assertDeepEqual",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tA utility used to assert that two objects are value-equal recursively. It\n\toutputs fairly nicely formatted messages to help diagnose why two objects\n\twould be different.\n\n\tThis should only be used in tests.\n]]\n\nlocal function deepEqual(a, b)\n\tif typeof(a) ~= typeof(b) then\n\t\tlocal message = (\"{1} is of type %s, but {2} is of type %s\"):format(typeof(a), typeof(b))\n\t\treturn false, message\n\tend\n\n\tif typeof(a) == \"table\" then\n\t\tlocal visitedKeys = {}\n\n\t\tfor key, value in pairs(a) do\n\t\t\tvisitedKeys[key] = true\n\n\t\t\tlocal success, innerMessage = deepEqual(value, b[key])\n\t\t\tif not success then\n\t\t\t\tlocal message = innerMessage\n\t\t\t\t\t:gsub(\"{1}\", (\"{1}[%s]\"):format(tostring(key)))\n\t\t\t\t\t:gsub(\"{2}\", (\"{2}[%s]\"):format(tostring(key)))\n\n\t\t\t\treturn false, message\n\t\t\tend\n\t\tend\n\n\t\tfor key, value in pairs(b) do\n\t\t\tif not visitedKeys[key] then\n\t\t\t\tlocal success, innerMessage = deepEqual(value, a[key])\n\n\t\t\t\tif not success then\n\t\t\t\t\tlocal message = innerMessage\n\t\t\t\t\t\t:gsub(\"{1}\", (\"{1}[%s]\"):format(tostring(key)))\n\t\t\t\t\t\t:gsub(\"{2}\", (\"{2}[%s]\"):format(tostring(key)))\n\n\t\t\t\t\treturn false, message\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\treturn true\n\tend\n\n\tif a == b then\n\t\treturn true\n\tend\n\n\tlocal message = \"{1} ~= {2}\"\n\treturn false, message\nend\n\nlocal function assertDeepEqual(a, b)\n\tlocal success, innerMessageTemplate = deepEqual(a, b)\n\n\tif not success then\n\t\tlocal innerMessage = innerMessageTemplate:gsub(\"{1}\", \"first\"):gsub(\"{2}\", \"second\")\n\n\t\tlocal message = (\"Values were not deep-equal.\\n%s\"):format(innerMessage)\n\n\t\terror(message, 2)\n\tend\nend\n\nreturn assertDeepEqual\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Type.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal Type = require(script.Parent.Type)\n\n\tdescribe(\"of\", function()\n\t\tit(\"should return nil if the value is not a table\", function()\n\t\t\texpect(Type.of(1)).to.equal(nil)\n\t\t\texpect(Type.of(true)).to.equal(nil)\n\t\t\texpect(Type.of(\"test\")).to.equal(nil)\n\t\t\texpect(Type.of(print)).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should return nil if the table has no type\", function()\n\t\t\texpect(Type.of({})).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should return the assigned type\", function()\n\t\t\tlocal test = {\n\t\t\t\t[Type] = Type.Element,\n\t\t\t}\n\n\t\t\texpect(Type.of(test)).to.equal(Type.Element)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Type",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tContains markers for annotating objects with types.\n\n\tTo set the type of an object, use `Type` as a key and the actual marker as\n\tthe value:\n\n\t\tlocal foo = {\n\t\t\t[Type] = Type.Foo,\n\t\t}\n]]\n\nlocal Symbol = require(script.Parent.Symbol)\nlocal strict = require(script.Parent.strict)\n\nlocal Type = newproxy(true)\n\nlocal TypeInternal = {}\n\nlocal function addType(name)\n\tTypeInternal[name] = Symbol.named(\"Roact\" .. name)\nend\n\naddType(\"Binding\")\naddType(\"Element\")\naddType(\"HostChangeEvent\")\naddType(\"HostEvent\")\naddType(\"StatefulComponentClass\")\naddType(\"StatefulComponentInstance\")\naddType(\"VirtualNode\")\naddType(\"VirtualTree\")\n\nfunction TypeInternal.of(value)\n\tif typeof(value) ~= \"table\" then\n\t\treturn nil\n\tend\n\n\treturn value[Type]\nend\n\ngetmetatable(Type).__index = TypeInternal\n\ngetmetatable(Type).__tostring = function()\n\treturn \"RoactType\"\nend\n\nstrict(TypeInternal, \"Type\")\n\nreturn Type\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Symbol.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal Symbol = require(script.Parent.Symbol)\n\n\tdescribe(\"named\", function()\n\t\tit(\"should give an opaque object\", function()\n\t\t\tlocal symbol = Symbol.named(\"foo\")\n\n\t\t\texpect(symbol).to.be.a(\"userdata\")\n\t\tend)\n\n\t\tit(\"should coerce to the given name\", function()\n\t\t\tlocal symbol = Symbol.named(\"foo\")\n\n\t\t\texpect(tostring(symbol):find(\"foo\")).to.be.ok()\n\t\tend)\n\n\t\tit(\"should be unique when constructed\", function()\n\t\t\tlocal symbolA = Symbol.named(\"abc\")\n\t\t\tlocal symbolB = Symbol.named(\"abc\")\n\n\t\t\texpect(symbolA).never.to.equal(symbolB)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Symbol",
                        "ClassName": "ModuleScript",
                        "Source": "--!nonstrict\n--[[\n\tA 'Symbol' is an opaque marker type.\n\n\tSymbols have the type 'userdata', but when printed to the console, the name\n\tof the symbol is shown.\n]]\n\nlocal Symbol = {}\n\n--[[\n\tCreates a Symbol with the given name.\n\n\tWhen printed or coerced to a string, the symbol will turn into the string\n\tgiven as its name.\n]]\nfunction Symbol.named(name)\n\tassert(type(name) == \"string\", \"Symbols must be created using a string name!\")\n\n\tlocal self = newproxy(true)\n\n\tlocal wrappedName = (\"Symbol(%s)\"):format(name)\n\n\tgetmetatable(self).__tostring = function()\n\t\treturn wrappedName\n\tend\n\n\treturn self\nend\n\nreturn Symbol\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "SingleEventManager.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.assertDeepEqual)\n\tlocal createSpy = require(script.Parent.createSpy)\n\tlocal Logging = require(script.Parent.Logging)\n\n\tlocal SingleEventManager = require(script.Parent.SingleEventManager)\n\n\tdescribe(\"new\", function()\n\t\tit(\"should create a SingleEventManager\", function()\n\t\t\tlocal manager = SingleEventManager.new()\n\n\t\t\texpect(manager).to.be.ok()\n\t\tend)\n\tend)\n\n\tdescribe(\"connectEvent\", function()\n\t\tit(\"should connect to events\", function()\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\t\t\tlocal eventSpy = createSpy()\n\n\t\t\tmanager:connectEvent(\"Event\", eventSpy.value)\n\t\t\tmanager:resume()\n\n\t\t\tinstance:Fire(\"foo\")\n\t\t\texpect(eventSpy.callCount).to.equal(1)\n\t\t\teventSpy:assertCalledWith(instance, \"foo\")\n\n\t\t\tinstance:Fire(\"bar\")\n\t\t\texpect(eventSpy.callCount).to.equal(2)\n\t\t\teventSpy:assertCalledWith(instance, \"bar\")\n\n\t\t\tmanager:connectEvent(\"Event\", nil)\n\n\t\t\tinstance:Fire(\"baz\")\n\t\t\texpect(eventSpy.callCount).to.equal(2)\n\t\tend)\n\n\t\tit(\"should drop events until resumed initially\", function()\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\t\t\tlocal eventSpy = createSpy()\n\n\t\t\tmanager:connectEvent(\"Event\", eventSpy.value)\n\n\t\t\tinstance:Fire(\"foo\")\n\t\t\texpect(eventSpy.callCount).to.equal(0)\n\n\t\t\tmanager:resume()\n\n\t\t\tinstance:Fire(\"bar\")\n\t\t\texpect(eventSpy.callCount).to.equal(1)\n\t\t\teventSpy:assertCalledWith(instance, \"bar\")\n\t\tend)\n\n\t\tit(\"should invoke suspended events when resumed\", function()\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\t\t\tlocal eventSpy = createSpy()\n\n\t\t\tmanager:connectEvent(\"Event\", eventSpy.value)\n\t\t\tmanager:resume()\n\n\t\t\tinstance:Fire(\"foo\")\n\t\t\texpect(eventSpy.callCount).to.equal(1)\n\t\t\teventSpy:assertCalledWith(instance, \"foo\")\n\n\t\t\tmanager:suspend()\n\n\t\t\tinstance:Fire(\"bar\")\n\t\t\texpect(eventSpy.callCount).to.equal(1)\n\n\t\t\tmanager:resume()\n\t\t\texpect(eventSpy.callCount).to.equal(2)\n\t\t\teventSpy:assertCalledWith(instance, \"bar\")\n\t\tend)\n\n\t\tit(\"should invoke events triggered during resumption in the correct order\", function()\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\n\t\t\tlocal recordedValues = {}\n\t\t\tlocal eventSpy = createSpy(function(_, value)\n\t\t\t\ttable.insert(recordedValues, value)\n\n\t\t\t\tif value == 2 then\n\t\t\t\t\tinstance:Fire(3)\n\t\t\t\telseif value == 3 then\n\t\t\t\t\tinstance:Fire(4)\n\t\t\t\tend\n\t\t\tend)\n\n\t\t\tmanager:connectEvent(\"Event\", eventSpy.value)\n\t\t\tmanager:suspend()\n\n\t\t\tinstance:Fire(1)\n\t\t\tinstance:Fire(2)\n\n\t\t\tmanager:resume()\n\t\t\texpect(eventSpy.callCount).to.equal(4)\n\t\t\tassertDeepEqual(recordedValues, { 1, 2, 3, 4 })\n\t\tend)\n\n\t\tit(\"should not invoke events fired during suspension but disconnected before resumption\", function()\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\t\t\tlocal eventSpy = createSpy()\n\n\t\t\tmanager:connectEvent(\"Event\", eventSpy.value)\n\t\t\tmanager:suspend()\n\n\t\t\tinstance:Fire(1)\n\n\t\t\tmanager:connectEvent(\"Event\", nil)\n\n\t\t\tmanager:resume()\n\t\t\texpect(eventSpy.callCount).to.equal(0)\n\t\tend)\n\n\t\tit(\"should not yield events through the SingleEventManager when resuming\", function()\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\n\t\t\tmanager:connectEvent(\"Event\", function()\n\t\t\t\tcoroutine.yield()\n\t\t\tend)\n\n\t\t\tmanager:resume()\n\n\t\t\tlocal co = coroutine.create(function()\n\t\t\t\tinstance:Fire(5)\n\t\t\tend)\n\n\t\t\tassert(coroutine.resume(co))\n\t\t\texpect(coroutine.status(co)).to.equal(\"dead\")\n\n\t\t\tmanager:suspend()\n\t\t\tinstance:Fire(5)\n\n\t\t\tco = coroutine.create(function()\n\t\t\t\tmanager:resume()\n\t\t\tend)\n\n\t\t\tassert(coroutine.resume(co))\n\t\t\texpect(coroutine.status(co)).to.equal(\"dead\")\n\t\tend)\n\n\t\tit(\"should not throw errors through SingleEventManager when resuming\", function()\n\t\t\tlocal errorText = \"Error from SingleEventManager test\"\n\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\n\t\t\tmanager:connectEvent(\"Event\", function()\n\t\t\t\terror(errorText)\n\t\t\tend)\n\n\t\t\tmanager:resume()\n\n\t\t\t-- If we call instance:Fire() here, the error message will leak to\n\t\t\t-- the console since the thread's resumption will be handled by\n\t\t\t-- Roblox's scheduler.\n\n\t\t\tmanager:suspend()\n\t\t\tinstance:Fire(5)\n\n\t\t\tlocal logInfo = Logging.capture(function()\n\t\t\t\tmanager:resume()\n\t\t\tend)\n\n\t\t\texpect(#logInfo.errors).to.equal(0)\n\t\t\texpect(#logInfo.warnings).to.equal(1)\n\t\t\texpect(#logInfo.infos).to.equal(0)\n\n\t\t\texpect(logInfo.warnings[1]:find(errorText)).to.be.ok()\n\t\tend)\n\n\t\tit(\"should not overflow with events if manager:resume() is invoked when resuming a suspended event\", function()\n\t\t\tlocal instance = Instance.new(\"BindableEvent\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\n\t\t\t-- This connection emulates what happens if reconciliation is\n\t\t\t-- triggered again in response to reconciliation. Without\n\t\t\t-- appropriate guards, the inner resume() call will process the\n\t\t\t-- Fire(1) event again, causing a nasty stack overflow.\n\t\t\tlocal eventSpy = createSpy(function(_, value)\n\t\t\t\tif value == 1 then\n\t\t\t\t\tmanager:suspend()\n\t\t\t\t\tinstance:Fire(2)\n\t\t\t\t\tmanager:resume()\n\t\t\t\tend\n\t\t\tend)\n\n\t\t\tmanager:connectEvent(\"Event\", eventSpy.value)\n\n\t\t\tmanager:suspend()\n\t\t\tinstance:Fire(1)\n\t\t\tmanager:resume()\n\n\t\t\texpect(eventSpy.callCount).to.equal(2)\n\t\tend)\n\tend)\n\n\tdescribe(\"connectPropertyChange\", function()\n\t\t-- Since property changes utilize the same mechanisms as other events,\n\t\t-- the tests here are slimmed down to reduce redundancy.\n\n\t\tit(\"should connect to property changes\", function()\n\t\t\tlocal instance = Instance.new(\"Folder\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\t\t\tlocal eventSpy = createSpy()\n\n\t\t\tmanager:connectPropertyChange(\"Name\", eventSpy.value)\n\t\t\tmanager:resume()\n\n\t\t\tinstance.Name = \"foo\"\n\t\t\texpect(eventSpy.callCount).to.equal(1)\n\t\t\teventSpy:assertCalledWith(instance)\n\n\t\t\tinstance.Name = \"bar\"\n\t\t\texpect(eventSpy.callCount).to.equal(2)\n\t\t\teventSpy:assertCalledWith(instance)\n\n\t\t\tmanager:connectPropertyChange(\"Name\")\n\n\t\t\tinstance.Name = \"baz\"\n\t\t\texpect(eventSpy.callCount).to.equal(2)\n\t\tend)\n\n\t\tit(\"should throw an error if the property is invalid\", function()\n\t\t\tlocal instance = Instance.new(\"Folder\")\n\t\t\tlocal manager = SingleEventManager.new(instance)\n\n\t\t\texpect(function()\n\t\t\t\tmanager:connectPropertyChange(\"foo\", function() end)\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "SingleEventManager",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tA manager for a single host virtual node's connected events.\n]]\n\nlocal Logging = require(script.Parent.Logging)\n\nlocal CHANGE_PREFIX = \"Change.\"\n\nlocal EventStatus = {\n\t-- No events are processed at all; they're silently discarded\n\tDisabled = \"Disabled\",\n\n\t-- Events are stored in a queue; listeners are invoked when the manager is resumed\n\tSuspended = \"Suspended\",\n\n\t-- Event listeners are invoked as the events fire\n\tEnabled = \"Enabled\",\n}\n\nlocal SingleEventManager = {}\nSingleEventManager.__index = SingleEventManager\n\nfunction SingleEventManager.new(instance)\n\tlocal self = setmetatable({\n\t\t-- The queue of suspended events\n\t\t_suspendedEventQueue = {},\n\n\t\t-- All the event connections being managed\n\t\t-- Events are indexed by a string key\n\t\t_connections = {},\n\n\t\t-- All the listeners being managed\n\t\t-- These are stored distinctly from the connections\n\t\t-- Connections can have their listeners replaced at runtime\n\t\t_listeners = {},\n\n\t\t-- The suspension status of the manager\n\t\t-- Managers start disabled and are \"resumed\" after the initial render\n\t\t_status = EventStatus.Disabled,\n\n\t\t-- If true, the manager is processing queued events right now.\n\t\t_isResuming = false,\n\n\t\t-- The Roblox instance the manager is managing\n\t\t_instance = instance,\n\t}, SingleEventManager)\n\n\treturn self\nend\n\nfunction SingleEventManager:connectEvent(key, listener)\n\tself:_connect(key, self._instance[key], listener)\nend\n\nfunction SingleEventManager:connectPropertyChange(key, listener)\n\tlocal success, event = pcall(function()\n\t\treturn self._instance:GetPropertyChangedSignal(key)\n\tend)\n\n\tif not success then\n\t\terror((\"Cannot get changed signal on property %q: %s\"):format(tostring(key), event), 0)\n\tend\n\n\tself:_connect(CHANGE_PREFIX .. key, event, listener)\nend\n\nfunction SingleEventManager:_connect(eventKey, event, listener)\n\t-- If the listener doesn't exist we can just disconnect the existing connection\n\tif listener == nil then\n\t\tif self._connections[eventKey] ~= nil then\n\t\t\tself._connections[eventKey]:Disconnect()\n\t\t\tself._connections[eventKey] = nil\n\t\tend\n\n\t\tself._listeners[eventKey] = nil\n\telse\n\t\tif self._connections[eventKey] == nil then\n\t\t\tself._connections[eventKey] = event:Connect(function(...)\n\t\t\t\tif self._status == EventStatus.Enabled then\n\t\t\t\t\tself._listeners[eventKey](self._instance, ...)\n\t\t\t\telseif self._status == EventStatus.Suspended then\n\t\t\t\t\t-- Store this event invocation to be fired when resume is\n\t\t\t\t\t-- called.\n\n\t\t\t\t\tlocal argumentCount = select(\"#\", ...)\n\t\t\t\t\ttable.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\n\t\tself._listeners[eventKey] = listener\n\tend\nend\n\nfunction SingleEventManager:suspend()\n\tself._status = EventStatus.Suspended\nend\n\nfunction SingleEventManager:resume()\n\t-- If we're already resuming events for this instance, trying to resume\n\t-- again would cause a disaster.\n\tif self._isResuming then\n\t\treturn\n\tend\n\n\tself._isResuming = true\n\n\tlocal index = 1\n\n\t-- More events might be added to the queue when evaluating events, so we\n\t-- need to be careful in order to preserve correct evaluation order.\n\twhile index <= #self._suspendedEventQueue do\n\t\tlocal eventInvocation = self._suspendedEventQueue[index]\n\t\tlocal listener = self._listeners[eventInvocation[1]]\n\t\tlocal argumentCount = eventInvocation[2]\n\n\t\t-- The event might have been disconnected since suspension started; in\n\t\t-- this case, we drop the event.\n\t\tif listener ~= nil then\n\t\t\t-- Wrap the listener in a coroutine to catch errors and handle\n\t\t\t-- yielding correctly.\n\t\t\tlocal listenerCo = coroutine.create(listener)\n\t\t\tlocal success, result = coroutine.resume(\n\t\t\t\tlistenerCo,\n\t\t\t\tself._instance,\n\t\t\t\tunpack(eventInvocation, 3, 2 + argumentCount)\n\t\t\t)\n\n\t\t\t-- If the listener threw an error, we log it as a warning, since\n\t\t\t-- there's no way to write error text in Roblox Lua without killing\n\t\t\t-- our thread!\n\t\t\tif not success then\n\t\t\t\tLogging.warn(\"%s\", result)\n\t\t\tend\n\t\tend\n\n\t\tindex = index + 1\n\tend\n\n\tself._isResuming = false\n\tself._status = EventStatus.Enabled\n\tself._suspendedEventQueue = {}\nend\n\nreturn SingleEventManager\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "RobloxRenderer.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n\tlocal assertDeepEqual = require(script.Parent.assertDeepEqual)\n\tlocal Binding = require(script.Parent.Binding)\n\tlocal Children = require(script.Parent.PropMarkers.Children)\n\tlocal Component = require(script.Parent.Component)\n\tlocal createElement = require(script.Parent.createElement)\n\tlocal createFragment = require(script.Parent.createFragment)\n\tlocal createReconciler = require(script.Parent.createReconciler)\n\tlocal createRef = require(script.Parent.createRef)\n\tlocal createSpy = require(script.Parent.createSpy)\n\tlocal GlobalConfig = require(script.Parent.GlobalConfig)\n\tlocal Portal = require(script.Parent.Portal)\n\tlocal Ref = require(script.Parent.PropMarkers.Ref)\n\tlocal Event = require(script.Parent.PropMarkers.Event)\n\n\tlocal RobloxRenderer = require(script.Parent.RobloxRenderer)\n\n\tlocal reconciler = createReconciler(RobloxRenderer)\n\n\tdescribe(\"mountHostNode\", function()\n\t\tit(\"should create instances with correct props\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal value = \"Hello!\"\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal element = createElement(\"StringValue\", {\n\t\t\t\tValue = value,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal root = parent:GetChildren()[1]\n\n\t\t\texpect(root.ClassName).to.equal(\"StringValue\")\n\t\t\texpect(root.Value).to.equal(value)\n\t\t\texpect(root.Name).to.equal(key)\n\t\tend)\n\n\t\tit(\"should create children with correct names and props\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal rootValue = \"Hey there!\"\n\t\t\tlocal childValue = 173\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal element = createElement(\"StringValue\", {\n\t\t\t\tValue = rootValue,\n\t\t\t}, {\n\t\t\t\tChildA = createElement(\"IntValue\", {\n\t\t\t\t\tValue = childValue,\n\t\t\t\t}),\n\n\t\t\t\tChildB = createElement(\"Folder\"),\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal root = parent:GetChildren()[1]\n\n\t\t\texpect(root.ClassName).to.equal(\"StringValue\")\n\t\t\texpect(root.Value).to.equal(rootValue)\n\t\t\texpect(root.Name).to.equal(key)\n\n\t\t\texpect(#root:GetChildren()).to.equal(2)\n\n\t\t\tlocal childA = root.ChildA\n\t\t\tlocal childB = root.ChildB\n\n\t\t\texpect(childA).to.be.ok()\n\t\t\texpect(childB).to.be.ok()\n\n\t\t\texpect(childA.ClassName).to.equal(\"IntValue\")\n\t\t\texpect(childA.Value).to.equal(childValue)\n\n\t\t\texpect(childB.ClassName).to.equal(\"Folder\")\n\t\tend)\n\n\t\tit(\"should attach Bindings to Roblox properties\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal binding, update = Binding.create(10)\n\t\t\tlocal element = createElement(\"IntValue\", {\n\t\t\t\tValue = binding,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(instance.ClassName).to.equal(\"IntValue\")\n\t\t\texpect(instance.Value).to.equal(10)\n\n\t\t\tupdate(20)\n\n\t\t\texpect(instance.Value).to.equal(20)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\t\tend)\n\n\t\tit(\"should connect Binding refs\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal ref = createRef()\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\t[Ref] = ref,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(ref.current).to.be.ok()\n\t\t\texpect(ref.current).to.equal(instance)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\t\tend)\n\n\t\tit(\"should call function refs\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal spyRef = createSpy()\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\t[Ref] = spyRef.value,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(spyRef.callCount).to.equal(1)\n\t\t\tspyRef:assertCalledWith(instance)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\t\tend)\n\n\t\tit(\"should throw if setting invalid instance properties\", function()\n\t\t\tlocal configValues = {\n\t\t\t\telementTracing = true,\n\t\t\t}\n\n\t\t\tGlobalConfig.scoped(configValues, function()\n\t\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\t\tlocal key = \"Some Key\"\n\n\t\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\t\tFrob = 6,\n\t\t\t\t})\n\n\t\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\t\tlocal success, message = pcall(RobloxRenderer.mountHostNode, reconciler, node)\n\t\t\t\tassert(not success, \"Expected call to fail\")\n\n\t\t\t\texpect(message:find(\"Frob\")).to.be.ok()\n\t\t\t\texpect(message:find(\"Frame\")).to.be.ok()\n\t\t\t\texpect(message:find(\"RobloxRenderer%.spec\")).to.be.ok()\n\t\t\tend)\n\t\tend)\n\tend)\n\n\tdescribe(\"updateHostNode\", function()\n\t\tit(\"should update node props and children\", function()\n\t\t\t-- TODO: Break up test\n\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"updateHostNodeTest\"\n\t\t\tlocal firstValue = \"foo\"\n\t\t\tlocal newValue = \"bar\"\n\n\t\t\tlocal defaultStringValue = Instance.new(\"StringValue\").Value\n\n\t\t\tlocal element = createElement(\"StringValue\", {\n\t\t\t\tValue = firstValue,\n\t\t\t}, {\n\t\t\t\tChildA = createElement(\"IntValue\", {\n\t\t\t\t\tValue = 1,\n\t\t\t\t}),\n\t\t\t\tChildB = createElement(\"BoolValue\", {\n\t\t\t\t\tValue = true,\n\t\t\t\t}),\n\t\t\t\tChildC = createElement(\"StringValue\", {\n\t\t\t\t\tValue = \"test\",\n\t\t\t\t}),\n\t\t\t\tChildD = createElement(\"StringValue\", {\n\t\t\t\t\tValue = \"test\",\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\t-- Not testing mountHostNode's work here, only testing that the\n\t\t\t-- node is properly updated.\n\n\t\t\tlocal newElement = createElement(\"StringValue\", {\n\t\t\t\tValue = newValue,\n\t\t\t}, {\n\t\t\t\t-- ChildA changes element type.\n\t\t\t\tChildA = createElement(\"StringValue\", {\n\t\t\t\t\tValue = \"test\",\n\t\t\t\t}),\n\t\t\t\t-- ChildB changes child properties.\n\t\t\t\tChildB = createElement(\"BoolValue\", {\n\t\t\t\t\tValue = false,\n\t\t\t\t}),\n\t\t\t\t-- ChildC should reset its Value property back to the default.\n\t\t\t\tChildC = createElement(\"StringValue\", {}),\n\t\t\t\t-- ChildD is deleted.\n\t\t\t\t-- ChildE is added.\n\t\t\t\tChildE = createElement(\"Folder\", {}),\n\t\t\t})\n\n\t\t\tRobloxRenderer.updateHostNode(reconciler, node, newElement)\n\n\t\t\tlocal root = parent[key]\n\t\t\texpect(root.ClassName).to.equal(\"StringValue\")\n\t\t\texpect(root.Value).to.equal(newValue)\n\t\t\texpect(#root:GetChildren()).to.equal(4)\n\n\t\t\tlocal childA = root.ChildA\n\t\t\texpect(childA.ClassName).to.equal(\"StringValue\")\n\t\t\texpect(childA.Value).to.equal(\"test\")\n\n\t\t\tlocal childB = root.ChildB\n\t\t\texpect(childB.ClassName).to.equal(\"BoolValue\")\n\t\t\texpect(childB.Value).to.equal(false)\n\n\t\t\tlocal childC = root.ChildC\n\t\t\texpect(childC.ClassName).to.equal(\"StringValue\")\n\t\t\texpect(childC.Value).to.equal(defaultStringValue)\n\n\t\t\tlocal childE = root.ChildE\n\t\t\texpect(childE.ClassName).to.equal(\"Folder\")\n\t\tend)\n\n\t\tit(\"should update Bindings\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal bindingA, updateA = Binding.create(10)\n\t\t\tlocal element = createElement(\"IntValue\", {\n\t\t\t\tValue = bindingA,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(instance.Value).to.equal(10)\n\n\t\t\tlocal bindingB, updateB = Binding.create(99)\n\t\t\tlocal newElement = createElement(\"IntValue\", {\n\t\t\t\tValue = bindingB,\n\t\t\t})\n\n\t\t\tRobloxRenderer.updateHostNode(reconciler, node, newElement)\n\n\t\t\texpect(instance.Value).to.equal(99)\n\n\t\t\tupdateA(123)\n\n\t\t\texpect(instance.Value).to.equal(99)\n\n\t\t\tupdateB(123)\n\n\t\t\texpect(instance.Value).to.equal(123)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\t\tend)\n\n\t\tit(\"should update Binding refs\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal refA = createRef()\n\t\t\tlocal refB = createRef()\n\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\t[Ref] = refA,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(refA.current).to.equal(instance)\n\t\t\texpect(refB.current).never.to.be.ok()\n\n\t\t\tlocal newElement = createElement(\"Frame\", {\n\t\t\t\t[Ref] = refB,\n\t\t\t})\n\n\t\t\tRobloxRenderer.updateHostNode(reconciler, node, newElement)\n\n\t\t\texpect(refA.current).never.to.be.ok()\n\t\t\texpect(refB.current).to.equal(instance)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\t\tend)\n\n\t\tit(\"should call old function refs with nil and new function refs with a valid rbx\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal spyRefA = createSpy()\n\t\t\tlocal spyRefB = createSpy()\n\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\t[Ref] = spyRefA.value,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(spyRefA.callCount).to.equal(1)\n\t\t\tspyRefA:assertCalledWith(instance)\n\t\t\texpect(spyRefB.callCount).to.equal(0)\n\n\t\t\tlocal newElement = createElement(\"Frame\", {\n\t\t\t\t[Ref] = spyRefB.value,\n\t\t\t})\n\n\t\t\tRobloxRenderer.updateHostNode(reconciler, node, newElement)\n\n\t\t\texpect(spyRefA.callCount).to.equal(2)\n\t\t\tspyRefA:assertCalledWith(nil)\n\t\t\texpect(spyRefB.callCount).to.equal(1)\n\t\t\tspyRefB:assertCalledWith(instance)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\t\tend)\n\n\t\tit(\"should not call function refs again if they didn't change\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal spyRef = createSpy()\n\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\tSize = UDim2.new(1, 0, 1, 0),\n\t\t\t\t[Ref] = spyRef.value,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(spyRef.callCount).to.equal(1)\n\t\t\tspyRef:assertCalledWith(instance)\n\n\t\t\tlocal newElement = createElement(\"Frame\", {\n\t\t\t\tSize = UDim2.new(0.5, 0, 0.5, 0),\n\t\t\t\t[Ref] = spyRef.value,\n\t\t\t})\n\n\t\t\tRobloxRenderer.updateHostNode(reconciler, node, newElement)\n\n\t\t\t-- Not called again\n\t\t\texpect(spyRef.callCount).to.equal(1)\n\t\tend)\n\n\t\tit(\"should throw if setting invalid instance properties\", function()\n\t\t\tlocal configValues = {\n\t\t\t\telementTracing = true,\n\t\t\t}\n\n\t\t\tGlobalConfig.scoped(configValues, function()\n\t\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\t\tlocal key = \"Some Key\"\n\n\t\t\t\tlocal firstElement = createElement(\"Frame\")\n\t\t\t\tlocal secondElement = createElement(\"Frame\", {\n\t\t\t\t\tFrob = 6,\n\t\t\t\t})\n\n\t\t\t\tlocal node = reconciler.createVirtualNode(firstElement, parent, key)\n\t\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\t\tlocal success, message = pcall(RobloxRenderer.updateHostNode, reconciler, node, secondElement)\n\t\t\t\tassert(not success, \"Expected call to fail\")\n\n\t\t\t\texpect(message:find(\"Frob\")).to.be.ok()\n\t\t\t\texpect(message:find(\"Frame\")).to.be.ok()\n\t\t\t\texpect(message:find(\"RobloxRenderer%.spec\")).to.be.ok()\n\t\t\tend)\n\t\tend)\n\n\t\tit(\"should delete instances when reconciling to nil children\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\tSize = UDim2.new(1, 0, 1, 0),\n\t\t\t}, {\n\t\t\t\tchild = createElement(\"Frame\"),\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\t\t\texpect(#instance:GetChildren()).to.equal(1)\n\n\t\t\tlocal newElement = createElement(\"Frame\", {\n\t\t\t\tSize = UDim2.new(0.5, 0, 0.5, 0),\n\t\t\t})\n\n\t\t\tRobloxRenderer.updateHostNode(reconciler, node, newElement)\n\t\t\texpect(#instance:GetChildren()).to.equal(0)\n\t\tend)\n\tend)\n\n\tdescribe(\"unmountHostNode\", function()\n\t\tit(\"should delete instances from the inside-out\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Root\"\n\t\t\tlocal element = createElement(\"Folder\", nil, {\n\t\t\t\tChild = createElement(\"Folder\", nil, {\n\t\t\t\t\tGrandchild = createElement(\"Folder\"),\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal node = reconciler.mountVirtualNode(element, parent, key)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal root = parent:GetChildren()[1]\n\t\t\texpect(#root:GetChildren()).to.equal(1)\n\n\t\t\tlocal child = root:GetChildren()[1]\n\t\t\texpect(#child:GetChildren()).to.equal(1)\n\n\t\t\tlocal grandchild = child:GetChildren()[1]\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\n\t\t\texpect(grandchild.Parent).to.equal(nil)\n\t\t\texpect(child.Parent).to.equal(nil)\n\t\t\texpect(root.Parent).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should unsubscribe from any Bindings\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal binding, update = Binding.create(10)\n\t\t\tlocal element = createElement(\"IntValue\", {\n\t\t\t\tValue = binding,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\tlocal instance = parent:GetChildren()[1]\n\n\t\t\texpect(instance.Value).to.equal(10)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\t\t\tupdate(56)\n\n\t\t\texpect(instance.Value).to.equal(10)\n\t\tend)\n\n\t\tit(\"should clear Binding refs\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal ref = createRef()\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\t[Ref] = ref,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(ref.current).to.be.ok()\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\n\t\t\texpect(ref.current).never.to.be.ok()\n\t\tend)\n\n\t\tit(\"should call function refs with nil\", function()\n\t\t\tlocal parent = Instance.new(\"Folder\")\n\t\t\tlocal key = \"Some Key\"\n\n\t\t\tlocal spyRef = createSpy()\n\t\t\tlocal element = createElement(\"Frame\", {\n\t\t\t\t[Ref] = spyRef.value,\n\t\t\t})\n\n\t\t\tlocal node = reconciler.createVirtualNode(element, parent, key)\n\n\t\t\tRobloxRenderer.mountHostNode(reconciler, node)\n\n\t\t\texpect(spyRef.callCount).to.equal(1)\n\n\t\t\tRobloxRenderer.unmountHostNode(reconciler, node)\n\n\t\t\texpect(spyRef.callCount).to.equal(2)\n\t\t\tspyRef:assertCalledWith(nil)\n\t\tend)\n\tend)\n\n\tdescribe(\"Portals\", function()\n\t\tit(\"should create and destroy instances as children of `target`\", function()\n\t\t\tlocal target = Instance.new(\"Folder\")\n\n\t\t\tlocal function FunctionComponent(props)\n\t\t\t\treturn createElement(\"IntValue\", {\n\t\t\t\t\tValue = props.value,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(Portal, {\n\t\t\t\ttarget = target,\n\t\t\t}, {\n\t\t\t\tfolderOne = createElement(\"Folder\"),\n\t\t\t\tfolderTwo = createElement(\"Folder\"),\n\t\t\t\tintValueOne = createElement(FunctionComponent, {\n\t\t\t\t\tvalue = 42,\n\t\t\t\t}),\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\tlocal node = reconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\t\texpect(#target:GetChildren()).to.equal(3)\n\n\t\t\texpect(target:FindFirstChild(\"folderOne\")).to.be.ok()\n\t\t\texpect(target:FindFirstChild(\"folderTwo\")).to.be.ok()\n\t\t\texpect(target:FindFirstChild(\"intValueOne\")).to.be.ok()\n\t\t\texpect(target:FindFirstChild(\"intValueOne\").Value).to.equal(42)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(#target:GetChildren()).to.equal(0)\n\t\tend)\n\n\t\tit(\"should pass prop updates through to children\", function()\n\t\t\tlocal target = Instance.new(\"Folder\")\n\n\t\t\tlocal firstElement = createElement(Portal, {\n\t\t\t\ttarget = target,\n\t\t\t}, {\n\t\t\t\tChildValue = createElement(\"IntValue\", {\n\t\t\t\t\tValue = 1,\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal secondElement = createElement(Portal, {\n\t\t\t\ttarget = target,\n\t\t\t}, {\n\t\t\t\tChildValue = createElement(\"IntValue\", {\n\t\t\t\t\tValue = 2,\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"A Host Key\"\n\t\t\tlocal node = reconciler.mountVirtualNode(firstElement, hostParent, hostKey)\n\n\t\t\texpect(#target:GetChildren()).to.equal(1)\n\n\t\t\tlocal firstValue = target.ChildValue\n\t\t\texpect(firstValue.Value).to.equal(1)\n\n\t\t\tnode = reconciler.updateVirtualNode(node, secondElement)\n\n\t\t\texpect(#target:GetChildren()).to.equal(1)\n\n\t\t\tlocal secondValue = target.ChildValue\n\t\t\texpect(firstValue).to.equal(secondValue)\n\t\t\texpect(secondValue.Value).to.equal(2)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(#target:GetChildren()).to.equal(0)\n\t\tend)\n\n\t\tit(\"should throw if `target` is nil\", function()\n\t\t\t-- TODO: Relax this restriction?\n\t\t\tlocal element = createElement(Portal)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Keys for Everyone\"\n\n\t\t\texpect(function()\n\t\t\t\treconciler.mountVirtualNode(element, hostParent, hostKey)\n\t\t\tend).to.throw()\n\t\tend)\n\n\t\tit(\"should throw if `target` is not a Roblox instance\", function()\n\t\t\tlocal element = createElement(Portal, {\n\t\t\t\ttarget = {},\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Unleash the keys!\"\n\n\t\t\texpect(function()\n\t\t\t\treconciler.mountVirtualNode(element, hostParent, hostKey)\n\t\t\tend).to.throw()\n\t\tend)\n\n\t\tit(\"should recreate instances if `target` changes in an update\", function()\n\t\t\tlocal firstTarget = Instance.new(\"Folder\")\n\t\t\tlocal secondTarget = Instance.new(\"Folder\")\n\n\t\t\tlocal firstElement = createElement(Portal, {\n\t\t\t\ttarget = firstTarget,\n\t\t\t}, {\n\t\t\t\tChildValue = createElement(\"IntValue\", {\n\t\t\t\t\tValue = 1,\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal secondElement = createElement(Portal, {\n\t\t\t\ttarget = secondTarget,\n\t\t\t}, {\n\t\t\t\tChildValue = createElement(\"IntValue\", {\n\t\t\t\t\tValue = 2,\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\tlocal node = reconciler.mountVirtualNode(firstElement, hostParent, hostKey)\n\n\t\t\texpect(#firstTarget:GetChildren()).to.equal(1)\n\t\t\texpect(#secondTarget:GetChildren()).to.equal(0)\n\n\t\t\tlocal firstChild = firstTarget.ChildValue\n\t\t\texpect(firstChild.Value).to.equal(1)\n\n\t\t\tnode = reconciler.updateVirtualNode(node, secondElement)\n\n\t\t\texpect(#firstTarget:GetChildren()).to.equal(0)\n\t\t\texpect(#secondTarget:GetChildren()).to.equal(1)\n\n\t\t\tlocal secondChild = secondTarget.ChildValue\n\t\t\texpect(secondChild.Value).to.equal(2)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(#firstTarget:GetChildren()).to.equal(0)\n\t\t\texpect(#secondTarget:GetChildren()).to.equal(0)\n\t\tend)\n\tend)\n\n\tdescribe(\"Fragments\", function()\n\t\tit(\"should parent the fragment's elements into the fragment's parent\", function()\n\t\t\tlocal hostParent = Instance.new(\"Folder\")\n\n\t\t\tlocal fragment = createFragment({\n\t\t\t\tkey = createElement(\"IntValue\", {\n\t\t\t\t\tValue = 1,\n\t\t\t\t}),\n\t\t\t\tkey2 = createElement(\"IntValue\", {\n\t\t\t\t\tValue = 2,\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal node = reconciler.mountVirtualNode(fragment, hostParent, \"test\")\n\n\t\t\texpect(hostParent:FindFirstChild(\"key\")).to.be.ok()\n\t\t\texpect(hostParent.key.ClassName).to.equal(\"IntValue\")\n\t\t\texpect(hostParent.key.Value).to.equal(1)\n\n\t\t\texpect(hostParent:FindFirstChild(\"key2\")).to.be.ok()\n\t\t\texpect(hostParent.key2.ClassName).to.equal(\"IntValue\")\n\t\t\texpect(hostParent.key2.Value).to.equal(2)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(#hostParent:GetChildren()).to.equal(0)\n\t\tend)\n\n\t\tit(\"should allow sibling fragment to have common keys\", function()\n\t\t\tlocal hostParent = Instance.new(\"Folder\")\n\t\t\tlocal hostKey = \"Test\"\n\n\t\t\tlocal function parent(_props)\n\t\t\t\treturn createElement(\"IntValue\", {}, {\n\t\t\t\t\tfragmentA = createFragment({\n\t\t\t\t\t\tkey = createElement(\"StringValue\", {\n\t\t\t\t\t\t\tValue = \"A\",\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tkey2 = createElement(\"StringValue\", {\n\t\t\t\t\t\t\tValue = \"B\",\n\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t\tfragmentB = createFragment({\n\t\t\t\t\t\tkey = createElement(\"StringValue\", {\n\t\t\t\t\t\t\tValue = \"C\",\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tkey2 = createElement(\"StringValue\", {\n\t\t\t\t\t\t\tValue = \"D\",\n\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal node = reconciler.mountVirtualNode(createElement(parent), hostParent, hostKey)\n\t\t\tlocal parentChildren = hostParent[hostKey]:GetChildren()\n\n\t\t\texpect(#parentChildren).to.equal(4)\n\n\t\t\tlocal childValues = {}\n\n\t\t\tfor _, child in pairs(parentChildren) do\n\t\t\t\texpect(child.ClassName).to.equal(\"StringValue\")\n\t\t\t\tchildValues[child.Value] = 1 + (childValues[child.Value] or 0)\n\t\t\tend\n\n\t\t\t-- check if the StringValues have not collided\n\t\t\texpect(childValues.A).to.equal(1)\n\t\t\texpect(childValues.B).to.equal(1)\n\t\t\texpect(childValues.C).to.equal(1)\n\t\t\texpect(childValues.D).to.equal(1)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(#hostParent:GetChildren()).to.equal(0)\n\t\tend)\n\n\t\tit(\"should render nested fragments\", function()\n\t\t\tlocal hostParent = Instance.new(\"Folder\")\n\n\t\t\tlocal fragment = createFragment({\n\t\t\t\tkey = createFragment({\n\t\t\t\t\tTheValue = createElement(\"IntValue\", {\n\t\t\t\t\t\tValue = 1,\n\t\t\t\t\t}),\n\t\t\t\t\tTheOtherValue = createElement(\"IntValue\", {\n\t\t\t\t\t\tValue = 2,\n\t\t\t\t\t}),\n\t\t\t\t}),\n\t\t\t})\n\n\t\t\tlocal node = reconciler.mountVirtualNode(fragment, hostParent, \"Test\")\n\n\t\t\texpect(hostParent:FindFirstChild(\"TheValue\")).to.be.ok()\n\t\t\texpect(hostParent.TheValue.ClassName).to.equal(\"IntValue\")\n\t\t\texpect(hostParent.TheValue.Value).to.equal(1)\n\n\t\t\texpect(hostParent:FindFirstChild(\"TheOtherValue\")).to.be.ok()\n\t\t\texpect(hostParent.TheOtherValue.ClassName).to.equal(\"IntValue\")\n\t\t\texpect(hostParent.TheOtherValue.Value).to.equal(2)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(#hostParent:GetChildren()).to.equal(0)\n\t\tend)\n\n\t\tit(\"should not add any instances if the fragment is empty\", function()\n\t\t\tlocal hostParent = Instance.new(\"Folder\")\n\n\t\t\tlocal node = reconciler.mountVirtualNode(createFragment({}), hostParent, \"test\")\n\n\t\t\texpect(#hostParent:GetChildren()).to.equal(0)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\n\t\t\texpect(#hostParent:GetChildren()).to.equal(0)\n\t\tend)\n\tend)\n\n\tdescribe(\"Context\", function()\n\t\tit(\"should pass context values through Roblox host nodes\", function()\n\t\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\t\tlocal capturedContext\n\t\t\tfunction Consumer:init()\n\t\t\t\tcapturedContext = {\n\t\t\t\t\thello = self:__getContext(\"hello\"),\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tfunction Consumer:render() end\n\n\t\t\tlocal element = createElement(\"Folder\", nil, {\n\t\t\t\tConsumer = createElement(Consumer),\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Context Test\"\n\t\t\tlocal context = {\n\t\t\t\thello = \"world\",\n\t\t\t}\n\t\t\tlocal node = reconciler.mountVirtualNode(element, hostParent, hostKey, context)\n\n\t\t\texpect(capturedContext).never.to.equal(context)\n\t\t\tassertDeepEqual(capturedContext, context)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\t\tend)\n\n\t\tit(\"should pass context values through portal nodes\", function()\n\t\t\tlocal target = Instance.new(\"Folder\")\n\n\t\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\t\tfunction Provider:init()\n\t\t\t\tself:__addContext(\"foo\", \"bar\")\n\t\t\tend\n\n\t\t\tfunction Provider:render()\n\t\t\t\treturn createElement(\"Folder\", nil, self.props[Children])\n\t\t\tend\n\n\t\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\t\tlocal capturedContext\n\t\t\tfunction Consumer:init()\n\t\t\t\tcapturedContext = {\n\t\t\t\t\tfoo = self:__getContext(\"foo\"),\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tfunction Consumer:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(Provider, nil, {\n\t\t\t\tPortal = createElement(Portal, {\n\t\t\t\t\ttarget = target,\n\t\t\t\t}, {\n\t\t\t\t\tConsumer = createElement(Consumer),\n\t\t\t\t}),\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\treconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\t\tassertDeepEqual(capturedContext, {\n\t\t\t\tfoo = \"bar\",\n\t\t\t})\n\t\tend)\n\tend)\n\n\tdescribe(\"Legacy context\", function()\n\t\tit(\"should pass context values through Roblox host nodes\", function()\n\t\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\t\tlocal capturedContext\n\t\t\tfunction Consumer:init()\n\t\t\t\tcapturedContext = self._context\n\t\t\tend\n\n\t\t\tfunction Consumer:render() end\n\n\t\t\tlocal element = createElement(\"Folder\", nil, {\n\t\t\t\tConsumer = createElement(Consumer),\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Context Test\"\n\t\t\tlocal context = {\n\t\t\t\thello = \"world\",\n\t\t\t}\n\t\t\tlocal node = reconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)\n\n\t\t\texpect(capturedContext).never.to.equal(context)\n\t\t\tassertDeepEqual(capturedContext, context)\n\n\t\t\treconciler.unmountVirtualNode(node)\n\t\tend)\n\n\t\tit(\"should pass context values through portal nodes\", function()\n\t\t\tlocal target = Instance.new(\"Folder\")\n\n\t\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\t\tfunction Provider:init()\n\t\t\t\tself._context.foo = \"bar\"\n\t\t\tend\n\n\t\t\tfunction Provider:render()\n\t\t\t\treturn createElement(\"Folder\", nil, self.props[Children])\n\t\t\tend\n\n\t\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\t\tlocal capturedContext\n\t\t\tfunction Consumer:init()\n\t\t\t\tcapturedContext = self._context\n\t\t\tend\n\n\t\t\tfunction Consumer:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(Provider, nil, {\n\t\t\t\tPortal = createElement(Portal, {\n\t\t\t\t\ttarget = target,\n\t\t\t\t}, {\n\t\t\t\t\tConsumer = createElement(Consumer),\n\t\t\t\t}),\n\t\t\t})\n\t\t\tlocal hostParent = nil\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\treconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\t\tassertDeepEqual(capturedContext, {\n\t\t\t\tfoo = \"bar\",\n\t\t\t})\n\t\tend)\n\tend)\n\n\tdescribe(\"Integration Tests\", function()\n\t\tlocal temporaryParent = nil\n\t\tbeforeEach(function()\n\t\t\ttemporaryParent = Instance.new(\"Folder\")\n\t\t\ttemporaryParent.Parent = ReplicatedStorage\n\t\tend)\n\n\t\tafterEach(function()\n\t\t\ttemporaryParent:Destroy()\n\t\t\ttemporaryParent = nil\n\t\tend)\n\n\t\tit(\"should not allow re-entrancy in updateChildren\", function()\n\t\t\tlocal ChildComponent = Component:extend(\"ChildComponent\")\n\n\t\t\tfunction ChildComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tfirstTime = true,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal childCoroutine\n\n\t\t\tfunction ChildComponent:render()\n\t\t\t\tif self.state.firstTime then\n\t\t\t\t\treturn createElement(\"Frame\")\n\t\t\t\tend\n\n\t\t\t\treturn createElement(\"TextLabel\")\n\t\t\tend\n\n\t\t\tfunction ChildComponent:didMount()\n\t\t\t\tchildCoroutine = coroutine.create(function()\n\t\t\t\t\tself:setState({\n\t\t\t\t\t\tfirstTime = false,\n\t\t\t\t\t})\n\t\t\t\tend)\n\t\t\tend\n\n\t\t\tlocal ParentComponent = Component:extend(\"ParentComponent\")\n\n\t\t\tfunction ParentComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tcount = 1,\n\t\t\t\t})\n\n\t\t\t\tself.childAdded = function()\n\t\t\t\t\tself:setState({\n\t\t\t\t\t\tcount = self.state.count + 1,\n\t\t\t\t\t})\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction ParentComponent:render()\n\t\t\t\treturn createElement(\"Frame\", {\n\t\t\t\t\t[Event.ChildAdded] = self.childAdded,\n\t\t\t\t}, {\n\t\t\t\t\tChildComponent = createElement(ChildComponent, {\n\t\t\t\t\t\tcount = self.state.count,\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal parent = Instance.new(\"ScreenGui\")\n\t\t\tparent.Parent = temporaryParent\n\n\t\t\tlocal tree = createElement(ParentComponent)\n\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\tlocal instance = reconciler.mountVirtualNode(tree, parent, hostKey)\n\n\t\t\tcoroutine.resume(childCoroutine)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal frame = parent:GetChildren()[1]\n\n\t\t\texpect(#frame:GetChildren()).to.equal(1)\n\n\t\t\treconciler.unmountVirtualNode(instance)\n\t\tend)\n\n\t\tit(\"should not allow re-entrancy in updateChildren even with callbacks\", function()\n\t\t\tlocal LowestComponent = Component:extend(\"LowestComponent\")\n\n\t\t\tfunction LowestComponent:render()\n\t\t\t\treturn createElement(\"Frame\")\n\t\t\tend\n\n\t\t\tfunction LowestComponent:didMount()\n\t\t\t\tself.props.onDidMountCallback()\n\t\t\tend\n\n\t\t\tlocal ChildComponent = Component:extend(\"ChildComponent\")\n\n\t\t\tfunction ChildComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tfirstTime = true,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal childCoroutine\n\n\t\t\tfunction ChildComponent:render()\n\t\t\t\tif self.state.firstTime then\n\t\t\t\t\treturn createElement(\"Frame\")\n\t\t\t\tend\n\n\t\t\t\treturn createElement(LowestComponent, {\n\t\t\t\t\tonDidMountCallback = self.props.onDidMountCallback,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tfunction ChildComponent:didMount()\n\t\t\t\tchildCoroutine = coroutine.create(function()\n\t\t\t\t\tself:setState({\n\t\t\t\t\t\tfirstTime = false,\n\t\t\t\t\t})\n\t\t\t\tend)\n\t\t\tend\n\n\t\t\tlocal ParentComponent = Component:extend(\"ParentComponent\")\n\n\t\t\tlocal didMountCallbackCalled = 0\n\n\t\t\tfunction ParentComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tcount = 1,\n\t\t\t\t})\n\n\t\t\t\tself.onDidMountCallback = function()\n\t\t\t\t\tdidMountCallbackCalled = didMountCallbackCalled + 1\n\t\t\t\t\tif self.state.count < 5 then\n\t\t\t\t\t\tself:setState({\n\t\t\t\t\t\t\tcount = self.state.count + 1,\n\t\t\t\t\t\t})\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction ParentComponent:render()\n\t\t\t\treturn createElement(\"Frame\", {}, {\n\t\t\t\t\tChildComponent = createElement(ChildComponent, {\n\t\t\t\t\t\tcount = self.state.count,\n\t\t\t\t\t\tonDidMountCallback = self.onDidMountCallback,\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal parent = Instance.new(\"ScreenGui\")\n\t\t\tparent.Parent = temporaryParent\n\n\t\t\tlocal tree = createElement(ParentComponent)\n\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\tlocal instance = reconciler.mountVirtualNode(tree, parent, hostKey)\n\n\t\t\tcoroutine.resume(childCoroutine)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal frame = parent:GetChildren()[1]\n\n\t\t\texpect(#frame:GetChildren()).to.equal(1)\n\n\t\t\t-- In an ideal world, the didMount callback would probably be called only once. Since it is called by two different\n\t\t\t-- LowestComponent instantiations 2 is also acceptable though.\n\t\t\texpect(didMountCallbackCalled <= 2).to.equal(true)\n\n\t\t\treconciler.unmountVirtualNode(instance)\n\t\tend)\n\n\t\tit(\"should never call unmount twice in the case of update children re-rentrancy\", function()\n\t\t\tlocal unmountCounts = {}\n\n\t\t\tlocal function addUnmount(id)\n\t\t\t\tunmountCounts[id] = unmountCounts[id] + 1\n\t\t\tend\n\n\t\t\tlocal function addInit(id)\n\t\t\t\tunmountCounts[id] = 0\n\t\t\tend\n\n\t\t\tlocal LowestComponent = Component:extend(\"LowestComponent\")\n\t\t\tfunction LowestComponent:init()\n\t\t\t\taddInit(tostring(self))\n\t\t\tend\n\n\t\t\tfunction LowestComponent:render()\n\t\t\t\treturn createElement(\"Frame\")\n\t\t\tend\n\n\t\t\tfunction LowestComponent:didMount()\n\t\t\t\tself.props.onDidMountCallback()\n\t\t\tend\n\n\t\t\tfunction LowestComponent:willUnmount()\n\t\t\t\taddUnmount(tostring(self))\n\t\t\tend\n\n\t\t\tlocal FirstComponent = Component:extend(\"FirstComponent\")\n\t\t\tfunction FirstComponent:init()\n\t\t\t\taddInit(tostring(self))\n\t\t\tend\n\n\t\t\tfunction FirstComponent:render()\n\t\t\t\treturn createElement(\"TextLabel\")\n\t\t\tend\n\n\t\t\tfunction FirstComponent:willUnmount()\n\t\t\t\taddUnmount(tostring(self))\n\t\t\tend\n\n\t\t\tlocal ChildComponent = Component:extend(\"ChildComponent\")\n\n\t\t\tfunction ChildComponent:init()\n\t\t\t\taddInit(tostring(self))\n\n\t\t\t\tself:setState({\n\t\t\t\t\tfirstTime = true,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal childCoroutine\n\n\t\t\tfunction ChildComponent:render()\n\t\t\t\tif self.state.firstTime then\n\t\t\t\t\treturn createElement(FirstComponent)\n\t\t\t\tend\n\n\t\t\t\treturn createElement(LowestComponent, {\n\t\t\t\t\tonDidMountCallback = self.props.onDidMountCallback,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tfunction ChildComponent:didMount()\n\t\t\t\tchildCoroutine = coroutine.create(function()\n\t\t\t\t\tself:setState({\n\t\t\t\t\t\tfirstTime = false,\n\t\t\t\t\t})\n\t\t\t\tend)\n\t\t\tend\n\n\t\t\tfunction ChildComponent:willUnmount()\n\t\t\t\taddUnmount(tostring(self))\n\t\t\tend\n\n\t\t\tlocal ParentComponent = Component:extend(\"ParentComponent\")\n\n\t\t\tlocal didMountCallbackCalled = 0\n\n\t\t\tfunction ParentComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tcount = 1,\n\t\t\t\t})\n\n\t\t\t\tself.onDidMountCallback = function()\n\t\t\t\t\tdidMountCallbackCalled = didMountCallbackCalled + 1\n\t\t\t\t\tif self.state.count < 5 then\n\t\t\t\t\t\tself:setState({\n\t\t\t\t\t\t\tcount = self.state.count + 1,\n\t\t\t\t\t\t})\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction ParentComponent:render()\n\t\t\t\treturn createElement(\"Frame\", {}, {\n\t\t\t\t\tChildComponent = createElement(ChildComponent, {\n\t\t\t\t\t\tcount = self.state.count,\n\t\t\t\t\t\tonDidMountCallback = self.onDidMountCallback,\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal parent = Instance.new(\"ScreenGui\")\n\t\t\tparent.Parent = temporaryParent\n\n\t\t\tlocal tree = createElement(ParentComponent)\n\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\tlocal instance = reconciler.mountVirtualNode(tree, parent, hostKey)\n\n\t\t\tcoroutine.resume(childCoroutine)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal frame = parent:GetChildren()[1]\n\n\t\t\texpect(#frame:GetChildren()).to.equal(1)\n\n\t\t\t-- In an ideal world, the didMount callback would probably be called only once. Since it is called by two different\n\t\t\t-- LowestComponent instantiations 2 is also acceptable though.\n\t\t\texpect(didMountCallbackCalled <= 2).to.equal(true)\n\n\t\t\treconciler.unmountVirtualNode(instance)\n\n\t\t\tfor _, value in pairs(unmountCounts) do\n\t\t\t\texpect(value).to.equal(1)\n\t\t\tend\n\t\tend)\n\n\t\tit(\"should never unmount a node unnecesarily in the case of re-rentry\", function()\n\t\t\tlocal LowestComponent = Component:extend(\"LowestComponent\")\n\t\t\tfunction LowestComponent:render()\n\t\t\t\treturn createElement(\"Frame\")\n\t\t\tend\n\n\t\t\tfunction LowestComponent:didUpdate(prevProps, _prevState)\n\t\t\t\tif prevProps.firstTime and not self.props.firstTime then\n\t\t\t\t\tself.props.onChangedCallback()\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tlocal ChildComponent = Component:extend(\"ChildComponent\")\n\n\t\t\tfunction ChildComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tfirstTime = true,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal childCoroutine\n\n\t\t\tfunction ChildComponent:render()\n\t\t\t\treturn createElement(LowestComponent, {\n\t\t\t\t\tfirstTime = self.state.firstTime,\n\t\t\t\t\tonChangedCallback = self.props.onChangedCallback,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tfunction ChildComponent:didMount()\n\t\t\t\tchildCoroutine = coroutine.create(function()\n\t\t\t\t\tself:setState({\n\t\t\t\t\t\tfirstTime = false,\n\t\t\t\t\t})\n\t\t\t\tend)\n\t\t\tend\n\n\t\t\tlocal ParentComponent = Component:extend(\"ParentComponent\")\n\n\t\t\tlocal onChangedCallbackCalled = 0\n\n\t\t\tfunction ParentComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tcount = 1,\n\t\t\t\t})\n\n\t\t\t\tself.onChangedCallback = function()\n\t\t\t\t\tonChangedCallbackCalled = onChangedCallbackCalled + 1\n\t\t\t\t\tif self.state.count < 5 then\n\t\t\t\t\t\tself:setState({\n\t\t\t\t\t\t\tcount = self.state.count + 1,\n\t\t\t\t\t\t})\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction ParentComponent:render()\n\t\t\t\treturn createElement(\"Frame\", {}, {\n\t\t\t\t\tChildComponent = createElement(ChildComponent, {\n\t\t\t\t\t\tcount = self.state.count,\n\t\t\t\t\t\tonChangedCallback = self.onChangedCallback,\n\t\t\t\t\t}),\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal parent = Instance.new(\"ScreenGui\")\n\t\t\tparent.Parent = temporaryParent\n\n\t\t\tlocal tree = createElement(ParentComponent)\n\n\t\t\tlocal hostKey = \"Some Key\"\n\t\t\tlocal instance = reconciler.mountVirtualNode(tree, parent, hostKey)\n\n\t\t\tcoroutine.resume(childCoroutine)\n\n\t\t\texpect(#parent:GetChildren()).to.equal(1)\n\n\t\t\tlocal frame = parent:GetChildren()[1]\n\n\t\t\texpect(#frame:GetChildren()).to.equal(1)\n\n\t\t\texpect(onChangedCallbackCalled).to.equal(1)\n\n\t\t\treconciler.unmountVirtualNode(instance)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "RobloxRenderer",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tRenderer that deals in terms of Roblox Instances. This is the most\n\twell-supported renderer after NoopRenderer and is currently the only\n\trenderer that does anything.\n]]\n\nlocal Binding = require(script.Parent.Binding)\nlocal Children = require(script.Parent.PropMarkers.Children)\nlocal ElementKind = require(script.Parent.ElementKind)\nlocal SingleEventManager = require(script.Parent.SingleEventManager)\nlocal getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)\nlocal Ref = require(script.Parent.PropMarkers.Ref)\nlocal Type = require(script.Parent.Type)\nlocal internalAssert = require(script.Parent.internalAssert)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal applyPropsError = [[\nError applying props:\n\t%s\nIn element:\n%s\n]]\n\nlocal updatePropsError = [[\nError updating props:\n\t%s\nIn element:\n%s\n]]\n\nlocal function identity(...)\n\treturn ...\nend\n\nlocal function applyRef(ref, newHostObject)\n\tif ref == nil then\n\t\treturn\n\tend\n\n\tif typeof(ref) == \"function\" then\n\t\tref(newHostObject)\n\telseif Type.of(ref) == Type.Binding then\n\t\tBinding.update(ref, newHostObject)\n\telse\n\t\t-- TODO (#197): Better error message\n\t\terror((\"Invalid ref: Expected type Binding but got %s\"):format(typeof(ref)))\n\tend\nend\n\nlocal function setRobloxInstanceProperty(hostObject, key, newValue)\n\tif newValue == nil then\n\t\tlocal hostClass = hostObject.ClassName\n\t\tlocal _, defaultValue = getDefaultInstanceProperty(hostClass, key)\n\t\tnewValue = defaultValue\n\tend\n\n\t-- Assign the new value to the object\n\thostObject[key] = newValue\n\n\treturn\nend\n\nlocal function removeBinding(virtualNode, key)\n\tlocal disconnect = virtualNode.bindings[key]\n\tdisconnect()\n\tvirtualNode.bindings[key] = nil\nend\n\nlocal function attachBinding(virtualNode, key, newBinding)\n\tlocal function updateBoundProperty(newValue)\n\t\tlocal success, errorMessage = xpcall(function()\n\t\t\tsetRobloxInstanceProperty(virtualNode.hostObject, key, newValue)\n\t\tend, identity)\n\n\t\tif not success then\n\t\t\tlocal source = virtualNode.currentElement.source\n\n\t\t\tif source == nil then\n\t\t\t\tsource = \"<enable element tracebacks>\"\n\t\t\tend\n\n\t\t\tlocal fullMessage = updatePropsError:format(errorMessage, source)\n\t\t\terror(fullMessage, 0)\n\t\tend\n\tend\n\n\tif virtualNode.bindings == nil then\n\t\tvirtualNode.bindings = {}\n\tend\n\n\tvirtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)\n\n\tupdateBoundProperty(newBinding:getValue())\nend\n\nlocal function detachAllBindings(virtualNode)\n\tif virtualNode.bindings ~= nil then\n\t\tfor _, disconnect in pairs(virtualNode.bindings) do\n\t\t\tdisconnect()\n\t\tend\n\tend\nend\n\nlocal function applyProp(virtualNode, key, newValue, oldValue)\n\tif newValue == oldValue then\n\t\treturn\n\tend\n\n\tif key == Ref or key == Children then\n\t\t-- Refs and children are handled in a separate pass\n\t\treturn\n\tend\n\n\tlocal internalKeyType = Type.of(key)\n\n\tif internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then\n\t\tif virtualNode.eventManager == nil then\n\t\t\tvirtualNode.eventManager = SingleEventManager.new(virtualNode.hostObject)\n\t\tend\n\n\t\tlocal eventName = key.name\n\n\t\tif internalKeyType == Type.HostChangeEvent then\n\t\t\tvirtualNode.eventManager:connectPropertyChange(eventName, newValue)\n\t\telse\n\t\t\tvirtualNode.eventManager:connectEvent(eventName, newValue)\n\t\tend\n\n\t\treturn\n\tend\n\n\tlocal newIsBinding = Type.of(newValue) == Type.Binding\n\tlocal oldIsBinding = Type.of(oldValue) == Type.Binding\n\n\tif oldIsBinding then\n\t\tremoveBinding(virtualNode, key)\n\tend\n\n\tif newIsBinding then\n\t\tattachBinding(virtualNode, key, newValue)\n\telse\n\t\tsetRobloxInstanceProperty(virtualNode.hostObject, key, newValue)\n\tend\nend\n\nlocal function applyProps(virtualNode, props)\n\tfor propKey, value in pairs(props) do\n\t\tapplyProp(virtualNode, propKey, value, nil)\n\tend\nend\n\nlocal function updateProps(virtualNode, oldProps, newProps)\n\t-- Apply props that were added or updated\n\tfor propKey, newValue in pairs(newProps) do\n\t\tlocal oldValue = oldProps[propKey]\n\n\t\tapplyProp(virtualNode, propKey, newValue, oldValue)\n\tend\n\n\t-- Clean up props that were removed\n\tfor propKey, oldValue in pairs(oldProps) do\n\t\tlocal newValue = newProps[propKey]\n\n\t\tif newValue == nil then\n\t\t\tapplyProp(virtualNode, propKey, nil, oldValue)\n\t\tend\n\tend\nend\n\nlocal RobloxRenderer = {}\n\nfunction RobloxRenderer.isHostObject(target)\n\treturn typeof(target) == \"Instance\"\nend\n\nfunction RobloxRenderer.mountHostNode(reconciler, virtualNode)\n\tlocal element = virtualNode.currentElement\n\tlocal hostParent = virtualNode.hostParent\n\tlocal hostKey = virtualNode.hostKey\n\n\tif config.internalTypeChecks then\n\t\tinternalAssert(ElementKind.of(element) == ElementKind.Host, \"Element at given node is not a host Element\")\n\tend\n\tif config.typeChecks then\n\t\tassert(element.props.Name == nil, \"Name can not be specified as a prop to a host component in Roact.\")\n\t\tassert(element.props.Parent == nil, \"Parent can not be specified as a prop to a host component in Roact.\")\n\tend\n\n\tlocal instance = Instance.new(element.component)\n\tvirtualNode.hostObject = instance\n\n\tlocal success, errorMessage = xpcall(function()\n\t\tapplyProps(virtualNode, element.props)\n\tend, identity)\n\n\tif not success then\n\t\tlocal source = element.source\n\n\t\tif source == nil then\n\t\t\tsource = \"<enable element tracebacks>\"\n\t\tend\n\n\t\tlocal fullMessage = applyPropsError:format(errorMessage, source)\n\t\terror(fullMessage, 0)\n\tend\n\n\tinstance.Name = tostring(hostKey)\n\n\tlocal children = element.props[Children]\n\n\tif children ~= nil then\n\t\treconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)\n\tend\n\n\tinstance.Parent = hostParent\n\tvirtualNode.hostObject = instance\n\n\tapplyRef(element.props[Ref], instance)\n\n\tif virtualNode.eventManager ~= nil then\n\t\tvirtualNode.eventManager:resume()\n\tend\nend\n\nfunction RobloxRenderer.unmountHostNode(reconciler, virtualNode)\n\tlocal element = virtualNode.currentElement\n\n\tapplyRef(element.props[Ref], nil)\n\n\tfor _, childNode in pairs(virtualNode.children) do\n\t\treconciler.unmountVirtualNode(childNode)\n\tend\n\n\tdetachAllBindings(virtualNode)\n\n\tvirtualNode.hostObject:Destroy()\nend\n\nfunction RobloxRenderer.updateHostNode(reconciler, virtualNode, newElement)\n\tlocal oldProps = virtualNode.currentElement.props\n\tlocal newProps = newElement.props\n\n\tif virtualNode.eventManager ~= nil then\n\t\tvirtualNode.eventManager:suspend()\n\tend\n\n\t-- If refs changed, detach the old ref and attach the new one\n\tif oldProps[Ref] ~= newProps[Ref] then\n\t\tapplyRef(oldProps[Ref], nil)\n\t\tapplyRef(newProps[Ref], virtualNode.hostObject)\n\tend\n\n\tlocal success, errorMessage = xpcall(function()\n\t\tupdateProps(virtualNode, oldProps, newProps)\n\tend, identity)\n\n\tif not success then\n\t\tlocal source = newElement.source\n\n\t\tif source == nil then\n\t\t\tsource = \"<enable element tracebacks>\"\n\t\tend\n\n\t\tlocal fullMessage = updatePropsError:format(errorMessage, source)\n\t\terror(fullMessage, 0)\n\tend\n\n\tlocal children = newElement.props[Children]\n\tif children ~= nil or oldProps[Children] ~= nil then\n\t\treconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)\n\tend\n\n\tif virtualNode.eventManager ~= nil then\n\t\tvirtualNode.eventManager:resume()\n\tend\n\n\treturn virtualNode\nend\n\nreturn RobloxRenderer\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "PureComponent.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal createElement = require(script.Parent.createElement)\n\tlocal NoopRenderer = require(script.Parent.NoopRenderer)\n\tlocal createReconciler = require(script.Parent.createReconciler)\n\n\tlocal PureComponent = require(script.Parent.PureComponent)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be extendable\", function()\n\t\tlocal MyComponent = PureComponent:extend(\"MyComponent\")\n\n\t\texpect(MyComponent).to.be.ok()\n\tend)\n\n\tit(\"should skip updates for shallow-equal props\", function()\n\t\tlocal updateCount = 0\n\t\tlocal setValue\n\n\t\tlocal PureChild = PureComponent:extend(\"PureChild\")\n\n\t\tfunction PureChild:willUpdate()\n\t\t\tupdateCount = updateCount + 1\n\t\tend\n\n\t\tfunction PureChild:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal PureContainer = PureComponent:extend(\"PureContainer\")\n\n\t\tfunction PureContainer:init()\n\t\t\tself.state = {\n\t\t\t\tvalue = 0,\n\t\t\t}\n\t\tend\n\n\t\tfunction PureContainer:didMount()\n\t\t\tsetValue = function(value)\n\t\t\t\tself:setState({\n\t\t\t\t\tvalue = value,\n\t\t\t\t})\n\t\t\tend\n\t\tend\n\n\t\tfunction PureContainer:render()\n\t\t\treturn createElement(PureChild, {\n\t\t\t\tvalue = self.state.value,\n\t\t\t})\n\t\tend\n\n\t\tlocal element = createElement(PureContainer)\n\t\tlocal tree = noopReconciler.mountVirtualTree(element, nil, \"PureComponent Tree\")\n\n\t\texpect(updateCount).to.equal(0)\n\n\t\tsetValue(1)\n\n\t\texpect(updateCount).to.equal(1)\n\n\t\tsetValue(1)\n\n\t\texpect(updateCount).to.equal(1)\n\n\t\tsetValue(2)\n\n\t\texpect(updateCount).to.equal(2)\n\n\t\tsetValue(1)\n\n\t\texpect(updateCount).to.equal(3)\n\n\t\tnoopReconciler.unmountVirtualTree(tree)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "PureComponent",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tA version of Component with a `shouldUpdate` method that forces the\n\tresulting component to be pure.\n]]\n\nlocal Component = require(script.Parent.Component)\n\nlocal PureComponent = Component:extend(\"PureComponent\")\n\n-- When extend()ing a component, you don't get an extend method.\n-- This is to promote composition over inheritance.\n-- PureComponent is an exception to this rule.\nPureComponent.extend = Component.extend\n\nfunction PureComponent:shouldUpdate(newProps, newState)\n\t-- In a vast majority of cases, if state updated, something has updated.\n\t-- We don't bother checking in this case.\n\tif newState ~= self.state then\n\t\treturn true\n\tend\n\n\tif newProps == self.props then\n\t\treturn false\n\tend\n\n\tfor key, value in pairs(newProps) do\n\t\tif self.props[key] ~= value then\n\t\t\treturn true\n\t\tend\n\tend\n\n\tfor key, value in pairs(self.props) do\n\t\tif newProps[key] ~= value then\n\t\t\treturn true\n\t\tend\n\tend\n\n\treturn false\nend\n\nreturn PureComponent\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "PropMarkers",
                        "Archivable": true,
                        "Children": [
                            {
                                "Name": "Ref",
                                "ClassName": "ModuleScript",
                                "Source": "local Symbol = require(script.Parent.Parent.Symbol)\n\nlocal Ref = Symbol.named(\"Ref\")\n\nreturn Ref\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "Event.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Event = require(script.Parent.Event)\n\n\tit(\"should yield event objects when indexed\", function()\n\t\texpect(Type.of(Event.MouseButton1Click)).to.equal(Type.HostEvent)\n\t\texpect(Type.of(Event.Touched)).to.equal(Type.HostEvent)\n\tend)\n\n\tit(\"should yield the same object when indexed again\", function()\n\t\tlocal a = Event.MouseButton1Click\n\t\tlocal b = Event.MouseButton1Click\n\t\tlocal c = Event.Touched\n\n\t\texpect(a).to.equal(b)\n\t\texpect(a).never.to.equal(c)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "Event",
                                "ClassName": "ModuleScript",
                                "Source": "--[[\n\tIndex into `Event` to get a prop key for attaching to an event on a Roblox\n\tInstance.\n\n\tExample:\n\n\t\tRoact.createElement(\"TextButton\", {\n\t\t\tText = \"Hello, world!\",\n\n\t\t\t[Roact.Event.MouseButton1Click] = function(rbx)\n\t\t\t\tprint(\"Clicked\", rbx)\n\t\t\tend\n\t\t})\n]]\n\nlocal Type = require(script.Parent.Parent.Type)\n\nlocal Event = {}\n\nlocal eventMetatable = {\n\t__tostring = function(self)\n\t\treturn (\"RoactHostEvent(%s)\"):format(self.name)\n\tend,\n}\n\nsetmetatable(Event, {\n\t__index = function(_self, eventName)\n\t\tlocal event = {\n\t\t\t[Type] = Type.HostEvent,\n\t\t\tname = eventName,\n\t\t}\n\n\t\tsetmetatable(event, eventMetatable)\n\n\t\tEvent[eventName] = event\n\n\t\treturn event\n\tend,\n})\n\nreturn Event\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "Children",
                                "ClassName": "ModuleScript",
                                "Source": "local Symbol = require(script.Parent.Parent.Symbol)\n\nlocal Children = Symbol.named(\"Children\")\n\nreturn Children\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "Change.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Change = require(script.Parent.Change)\n\n\tit(\"should yield change listener objects when indexed\", function()\n\t\texpect(Type.of(Change.Text)).to.equal(Type.HostChangeEvent)\n\t\texpect(Type.of(Change.Selected)).to.equal(Type.HostChangeEvent)\n\tend)\n\n\tit(\"should yield the same object when indexed again\", function()\n\t\tlocal a = Change.Text\n\t\tlocal b = Change.Text\n\t\tlocal c = Change.Selected\n\n\t\texpect(a).to.equal(b)\n\t\texpect(a).never.to.equal(c)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "Change",
                                "ClassName": "ModuleScript",
                                "Source": "--[[\n\tChange is used to generate special prop keys that can be used to connect to\n\tGetPropertyChangedSignal.\n\n\tGenerally, Change is indexed by a Roblox property name:\n\n\t\tRoact.createElement(\"TextBox\", {\n\t\t\t[Roact.Change.Text] = function(rbx)\n\t\t\t\tprint(\"The TextBox\", rbx, \"changed text to\", rbx.Text)\n\t\t\tend,\n\t\t})\n]]\n\nlocal Type = require(script.Parent.Parent.Type)\n\nlocal Change = {}\n\nlocal changeMetatable = {\n\t__tostring = function(self)\n\t\treturn (\"RoactHostChangeEvent(%s)\"):format(self.name)\n\tend,\n}\n\nsetmetatable(Change, {\n\t__index = function(_self, propertyName)\n\t\tlocal changeListener = {\n\t\t\t[Type] = Type.HostChangeEvent,\n\t\t\tname = propertyName,\n\t\t}\n\n\t\tsetmetatable(changeListener, changeMetatable)\n\t\tChange[propertyName] = changeListener\n\n\t\treturn changeListener\n\tend,\n})\n\nreturn Change\n",
                                "Children": [],
                                "Archivable": true
                            }
                        ],
                        "ClassName": "Folder"
                    },
                    {
                        "Name": "Portal",
                        "ClassName": "ModuleScript",
                        "Source": "local Symbol = require(script.Parent.Symbol)\n\nlocal Portal = Symbol.named(\"Portal\")\n\nreturn Portal\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "NoopRenderer",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tReference renderer intended for use in tests as well as for documenting the\n\tminimum required interface for a Roact renderer.\n]]\n\nlocal NoopRenderer = {}\n\nfunction NoopRenderer.isHostObject(target)\n\t-- Attempting to use NoopRenderer to target a Roblox instance is almost\n\t-- certainly a mistake.\n\treturn target == nil\nend\n\nfunction NoopRenderer.mountHostNode(_reconciler, _node) end\n\nfunction NoopRenderer.unmountHostNode(_reconciler, _node) end\n\nfunction NoopRenderer.updateHostNode(_reconciler, node, _newElement)\n\treturn node\nend\n\nreturn NoopRenderer\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "None",
                        "ClassName": "ModuleScript",
                        "Source": "local Symbol = require(script.Parent.Symbol)\n\n-- Marker used to specify that the value is nothing, because nil cannot be\n-- stored in tables.\nlocal None = Symbol.named(\"None\")\n\nreturn None\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Logging",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tCentralized place to handle logging. Lets us:\n\t- Unit test log output via `Logging.capture`\n\t- Disable verbose log messages when not debugging Roact\n\n\tThis should be broken out into a separate library with the addition of\n\tscoping and logging configuration.\n]]\n\n-- Determines whether log messages will go to stdout/stderr\nlocal outputEnabled = true\n\n-- A set of LogInfo objects that should have messages inserted into them.\n-- This is a set so that nested calls to Logging.capture will behave.\nlocal collectors = {}\n\n-- A set of all stack traces that have called warnOnce.\nlocal onceUsedLocations = {}\n\n--[[\n\tIndent a potentially multi-line string with the given number of tabs, in\n\taddition to any indentation the string already has.\n]]\nlocal function indent(source, indentLevel)\n\tlocal indentString = (\"\\t\"):rep(indentLevel)\n\n\treturn indentString .. source:gsub(\"\\n\", \"\\n\" .. indentString)\nend\n\n--[[\n\tIndents a list of strings and then concatenates them together with newlines\n\tinto a single string.\n]]\nlocal function indentLines(lines, indentLevel)\n\tlocal outputBuffer = {}\n\n\tfor _, line in ipairs(lines) do\n\t\ttable.insert(outputBuffer, indent(line, indentLevel))\n\tend\n\n\treturn table.concat(outputBuffer, \"\\n\")\nend\n\nlocal logInfoMetatable = {}\n\n--[[\n\tAutomatic coercion to strings for LogInfo objects to enable debugging them\n\tmore easily.\n]]\nfunction logInfoMetatable:__tostring()\n\tlocal outputBuffer = { \"LogInfo {\" }\n\n\tlocal errorCount = #self.errors\n\tlocal warningCount = #self.warnings\n\tlocal infosCount = #self.infos\n\n\tif errorCount + warningCount + infosCount == 0 then\n\t\ttable.insert(outputBuffer, \"\\t(no messages)\")\n\tend\n\n\tif errorCount > 0 then\n\t\ttable.insert(outputBuffer, (\"\\tErrors (%d) {\"):format(errorCount))\n\t\ttable.insert(outputBuffer, indentLines(self.errors, 2))\n\t\ttable.insert(outputBuffer, \"\\t}\")\n\tend\n\n\tif warningCount > 0 then\n\t\ttable.insert(outputBuffer, (\"\\tWarnings (%d) {\"):format(warningCount))\n\t\ttable.insert(outputBuffer, indentLines(self.warnings, 2))\n\t\ttable.insert(outputBuffer, \"\\t}\")\n\tend\n\n\tif infosCount > 0 then\n\t\ttable.insert(outputBuffer, (\"\\tInfos (%d) {\"):format(infosCount))\n\t\ttable.insert(outputBuffer, indentLines(self.infos, 2))\n\t\ttable.insert(outputBuffer, \"\\t}\")\n\tend\n\n\ttable.insert(outputBuffer, \"}\")\n\n\treturn table.concat(outputBuffer, \"\\n\")\nend\n\nlocal function createLogInfo()\n\tlocal logInfo = {\n\t\terrors = {},\n\t\twarnings = {},\n\t\tinfos = {},\n\t}\n\n\tsetmetatable(logInfo, logInfoMetatable)\n\n\treturn logInfo\nend\n\nlocal Logging = {}\n\n--[[\n\tInvokes `callback`, capturing all output that happens during its execution.\n\n\tOutput will not go to stdout or stderr and will instead be put into a\n\tLogInfo object that is returned. If `callback` throws, the error will be\n\tbubbled up to the caller of `Logging.capture`.\n]]\nfunction Logging.capture(callback)\n\tlocal collector = createLogInfo()\n\n\tlocal wasOutputEnabled = outputEnabled\n\toutputEnabled = false\n\tcollectors[collector] = true\n\n\tlocal success, result = pcall(callback)\n\n\tcollectors[collector] = nil\n\toutputEnabled = wasOutputEnabled\n\n\tassert(success, result)\n\n\treturn collector\nend\n\n--[[\n\tIssues a warning with an automatically attached stack trace.\n]]\nfunction Logging.warn(messageTemplate, ...)\n\tlocal message = messageTemplate:format(...)\n\n\tfor collector in pairs(collectors) do\n\t\ttable.insert(collector.warnings, message)\n\tend\n\n\t-- debug.traceback inserts a leading newline, so we trim it here\n\tlocal trace = debug.traceback(\"\", 2):sub(2)\n\tlocal fullMessage = (\"%s\\n%s\"):format(message, indent(trace, 1))\n\n\tif outputEnabled then\n\t\twarn(fullMessage)\n\tend\nend\n\n--[[\n\tIssues a warning like `Logging.warn`, but only outputs once per call site.\n\n\tThis is useful for marking deprecated functions that might be called a lot;\n\tusing `warnOnce` instead of `warn` will reduce output noise while still\n\tcorrectly marking all call sites.\n]]\nfunction Logging.warnOnce(messageTemplate, ...)\n\tlocal trace = debug.traceback()\n\n\tif onceUsedLocations[trace] then\n\t\treturn\n\tend\n\n\tonceUsedLocations[trace] = true\n\tLogging.warn(messageTemplate, ...)\nend\n\nreturn Logging\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "GlobalConfig.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal GlobalConfig = require(script.Parent.GlobalConfig)\n\n\tit(\"should have the correct methods\", function()\n\t\texpect(GlobalConfig).to.be.ok()\n\t\texpect(GlobalConfig.set).to.be.ok()\n\t\texpect(GlobalConfig.get).to.be.ok()\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "GlobalConfig",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tExposes a single instance of a configuration as Roact's GlobalConfig.\n]]\n\nlocal Config = require(script.Parent.Config)\n\nreturn Config.new()\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "ElementUtils.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal ElementUtils = require(script.Parent.ElementUtils)\n\tlocal createElement = require(script.Parent.createElement)\n\tlocal createFragment = require(script.Parent.createFragment)\n\tlocal Type = require(script.Parent.Type)\n\n\tdescribe(\"iterateElements\", function()\n\t\tit(\"should iterate once for a single child\", function()\n\t\t\tlocal child = createElement(\"TextLabel\")\n\t\t\tlocal iterator = ElementUtils.iterateElements(child)\n\t\t\tlocal iteratedKey, iteratedChild = iterator()\n\t\t\t-- For single elements, the key should be UseParentKey\n\t\t\texpect(iteratedKey).to.equal(ElementUtils.UseParentKey)\n\t\t\texpect(iteratedChild).to.equal(child)\n\n\t\t\titeratedKey = iterator()\n\t\t\texpect(iteratedKey).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should iterate over tables\", function()\n\t\t\tlocal children = {\n\t\t\t\ta = createElement(\"TextLabel\"),\n\t\t\t\tb = createElement(\"TextLabel\"),\n\t\t\t}\n\n\t\t\tlocal seenChildren = {}\n\t\t\tlocal count = 0\n\n\t\t\tfor key, child in ElementUtils.iterateElements(children) do\n\t\t\t\texpect(typeof(key)).to.equal(\"string\")\n\t\t\t\texpect(Type.of(child)).to.equal(Type.Element)\n\t\t\t\tseenChildren[child] = key\n\t\t\t\tcount = count + 1\n\t\t\tend\n\n\t\t\texpect(count).to.equal(2)\n\t\t\texpect(seenChildren[children.a]).to.equal(\"a\")\n\t\t\texpect(seenChildren[children.b]).to.equal(\"b\")\n\t\tend)\n\n\t\tit(\"should return a zero-element iterator for booleans\", function()\n\t\t\tlocal booleanIterator = ElementUtils.iterateElements(false)\n\t\t\texpect(booleanIterator()).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should return a zero-element iterator for nil\", function()\n\t\t\tlocal nilIterator = ElementUtils.iterateElements(nil)\n\t\t\texpect(nilIterator()).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should throw if given an illegal value\", function()\n\t\t\texpect(function()\n\t\t\t\tElementUtils.iterateElements(1)\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tdescribe(\"getElementByKey\", function()\n\t\tit(\"should return nil for booleans\", function()\n\t\t\texpect(ElementUtils.getElementByKey(true, \"test\")).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should return nil for nil\", function()\n\t\t\texpect(ElementUtils.getElementByKey(nil, \"test\")).to.equal(nil)\n\t\tend)\n\n\t\tdescribe(\"single elements\", function()\n\t\t\tlocal element = createElement(\"TextLabel\")\n\n\t\t\tit(\"should return the element if the key is UseParentKey\", function()\n\t\t\t\texpect(ElementUtils.getElementByKey(element, ElementUtils.UseParentKey)).to.equal(element)\n\t\t\tend)\n\n\t\t\tit(\"should return nil if the key is not UseParentKey\", function()\n\t\t\t\texpect(ElementUtils.getElementByKey(element, \"test\")).to.equal(nil)\n\t\t\tend)\n\t\tend)\n\n\t\tit(\"should return the corresponding element from a table\", function()\n\t\t\tlocal children = {\n\t\t\t\ta = createElement(\"TextLabel\"),\n\t\t\t\tb = createElement(\"TextLabel\"),\n\t\t\t}\n\n\t\t\texpect(ElementUtils.getElementByKey(children, \"a\")).to.equal(children.a)\n\t\t\texpect(ElementUtils.getElementByKey(children, \"b\")).to.equal(children.b)\n\t\tend)\n\n\t\tit(\"should return nil if the key does not exist\", function()\n\t\t\tlocal children = createFragment({})\n\n\t\t\texpect(ElementUtils.getElementByKey(children, \"a\")).to.equal(nil)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "ElementUtils",
                        "ClassName": "ModuleScript",
                        "Source": "local Type = require(script.Parent.Type)\nlocal Symbol = require(script.Parent.Symbol)\n\nlocal function noop()\n\treturn nil\nend\n\nlocal ElementUtils = {}\n\n--[[\n\tA signal value indicating that a child should use its parent's key, because\n\tit has no key of its own.\n\n\tThis occurs when you return only one element from a function component or\n\tstateful render function.\n]]\nElementUtils.UseParentKey = Symbol.named(\"UseParentKey\")\n\n--[[\n\tReturns an iterator over the children of an element.\n\t`elementOrElements` may be one of:\n\t* a boolean\n\t* nil\n\t* a single element\n\t* a fragment\n\t* a table of elements\n\n\tIf `elementOrElements` is a boolean or nil, this will return an iterator with\n\tzero elements.\n\n\tIf `elementOrElements` is a single element, this will return an iterator with\n\tone element: a tuple where the first value is ElementUtils.UseParentKey, and\n\tthe second is the value of `elementOrElements`.\n\n\tIf `elementOrElements` is a fragment or a table, this will return an iterator\n\tover all the elements of the array.\n\n\tIf `elementOrElements` is none of the above, this function will throw.\n]]\nfunction ElementUtils.iterateElements(elementOrElements)\n\tlocal richType = Type.of(elementOrElements)\n\n\t-- Single child\n\tif richType == Type.Element then\n\t\tlocal called = false\n\n\t\treturn function()\n\t\t\tif called then\n\t\t\t\treturn nil\n\t\t\telse\n\t\t\t\tcalled = true\n\t\t\t\treturn ElementUtils.UseParentKey, elementOrElements\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal regularType = typeof(elementOrElements)\n\n\tif elementOrElements == nil or regularType == \"boolean\" then\n\t\treturn noop\n\tend\n\n\tif regularType == \"table\" then\n\t\treturn pairs(elementOrElements)\n\tend\n\n\terror(\"Invalid elements\")\nend\n\n--[[\n\tGets the child corresponding to a given key, respecting Roact's rules for\n\tchildren. Specifically:\n\t* If `elements` is nil or a boolean, this will return `nil`, regardless of\n\t\tthe key given.\n\t* If `elements` is a single element, this will return `nil`, unless the key\n\t\tis ElementUtils.UseParentKey.\n\t* If `elements` is a table of elements, this will return `elements[key]`.\n]]\nfunction ElementUtils.getElementByKey(elements, hostKey)\n\tif elements == nil or typeof(elements) == \"boolean\" then\n\t\treturn nil\n\tend\n\n\tif Type.of(elements) == Type.Element then\n\t\tif hostKey == ElementUtils.UseParentKey then\n\t\t\treturn elements\n\t\tend\n\n\t\treturn nil\n\tend\n\n\tif typeof(elements) == \"table\" then\n\t\treturn elements[hostKey]\n\tend\n\n\terror(\"Invalid elements\")\nend\n\nreturn ElementUtils\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "ElementKind.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal Portal = require(script.Parent.Portal)\n\tlocal Component = require(script.Parent.Component)\n\n\tlocal ElementKind = require(script.Parent.ElementKind)\n\n\tdescribe(\"of\", function()\n\t\tit(\"should return nil for non-table values\", function()\n\t\t\texpect(ElementKind.of(nil)).to.equal(nil)\n\t\t\texpect(ElementKind.of(5)).to.equal(nil)\n\t\t\texpect(ElementKind.of(newproxy(true))).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should return nil for table values without an ElementKind key\", function()\n\t\t\texpect(ElementKind.of({})).to.equal(nil)\n\t\tend)\n\n\t\tit(\"should return the ElementKind from a table\", function()\n\t\t\tlocal value = {\n\t\t\t\t[ElementKind] = ElementKind.Stateful,\n\t\t\t}\n\n\t\t\texpect(ElementKind.of(value)).to.equal(ElementKind.Stateful)\n\t\tend)\n\tend)\n\n\tdescribe(\"fromComponent\", function()\n\t\tit(\"should handle host components\", function()\n\t\t\texpect(ElementKind.fromComponent(\"foo\")).to.equal(ElementKind.Host)\n\t\tend)\n\n\t\tit(\"should handle function components\", function()\n\t\t\tlocal function foo() end\n\n\t\t\texpect(ElementKind.fromComponent(foo)).to.equal(ElementKind.Function)\n\t\tend)\n\n\t\tit(\"should handle stateful components\", function()\n\t\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\t\texpect(ElementKind.fromComponent(Foo)).to.equal(ElementKind.Stateful)\n\t\tend)\n\n\t\tit(\"should handle portals\", function()\n\t\t\texpect(ElementKind.fromComponent(Portal)).to.equal(ElementKind.Portal)\n\t\tend)\n\n\t\tit(\"should return nil for invalid inputs\", function()\n\t\t\texpect(ElementKind.fromComponent(5)).to.equal(nil)\n\t\t\texpect(ElementKind.fromComponent(newproxy(true))).to.equal(nil)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "ElementKind",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tContains markers for annotating the type of an element.\n\n\tUse `ElementKind` as a key, and values from it as the value.\n\n\t\tlocal element = {\n\t\t\t[ElementKind] = ElementKind.Host,\n\t\t}\n]]\n\nlocal Symbol = require(script.Parent.Symbol)\nlocal strict = require(script.Parent.strict)\nlocal Portal = require(script.Parent.Portal)\n\nlocal ElementKind = newproxy(true)\n\nlocal ElementKindInternal = {\n\tPortal = Symbol.named(\"Portal\"),\n\tHost = Symbol.named(\"Host\"),\n\tFunction = Symbol.named(\"Function\"),\n\tStateful = Symbol.named(\"Stateful\"),\n\tFragment = Symbol.named(\"Fragment\"),\n}\n\nfunction ElementKindInternal.of(value)\n\tif typeof(value) ~= \"table\" then\n\t\treturn nil\n\tend\n\n\treturn value[ElementKind]\nend\n\nlocal componentTypesToKinds = {\n\t[\"string\"] = ElementKindInternal.Host,\n\t[\"function\"] = ElementKindInternal.Function,\n\t[\"table\"] = ElementKindInternal.Stateful,\n}\n\nfunction ElementKindInternal.fromComponent(component)\n\tif component == Portal then\n\t\treturn ElementKind.Portal\n\telse\n\t\treturn componentTypesToKinds[typeof(component)]\n\tend\nend\n\ngetmetatable(ElementKind).__index = ElementKindInternal\n\nstrict(ElementKindInternal, \"ElementKind\")\n\nreturn ElementKind\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Config.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal Config = require(script.Parent.Config)\n\n\tit(\"should accept valid configuration\", function()\n\t\tlocal config = Config.new()\n\t\tlocal values = config.get()\n\n\t\texpect(values.elementTracing).to.equal(false)\n\n\t\tconfig.set({\n\t\t\telementTracing = true,\n\t\t})\n\n\t\texpect(values.elementTracing).to.equal(true)\n\tend)\n\n\tit(\"should reject invalid configuration keys\", function()\n\t\tlocal config = Config.new()\n\n\t\tlocal badKey = \"garblegoop\"\n\n\t\tlocal ok, err = pcall(function()\n\t\t\tconfig.set({\n\t\t\t\t[badKey] = true,\n\t\t\t})\n\t\tend)\n\n\t\texpect(ok).to.equal(false)\n\n\t\t-- The error should mention our bad key somewhere.\n\t\texpect(err:find(badKey)).to.be.ok()\n\tend)\n\n\tit(\"should reject invalid configuration values\", function()\n\t\tlocal config = Config.new()\n\n\t\tlocal goodKey = \"elementTracing\"\n\t\tlocal badValue = \"Hello there!\"\n\n\t\tlocal ok, err = pcall(function()\n\t\t\tconfig.set({\n\t\t\t\t[goodKey] = badValue,\n\t\t\t})\n\t\tend)\n\n\t\texpect(ok).to.equal(false)\n\n\t\t-- The error should mention both our key and value\n\t\texpect(err:find(goodKey)).to.be.ok()\n\t\texpect(err:find(badValue)).to.be.ok()\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Config",
                        "ClassName": "ModuleScript",
                        "Source": "--[[\n\tExposes an interface to set global configuration values for Roact.\n\n\tConfiguration can only occur once, and should only be done by an application\n\tusing Roact, not a library.\n\n\tAny keys that aren't recognized will cause errors. Configuration is only\n\tintended for configuring Roact itself, not extensions or libraries.\n\n\tConfiguration is expected to be set immediately after loading Roact. Setting\n\tconfiguration values after an application starts may produce unpredictable\n\tbehavior.\n]]\n\n-- Every valid configuration value should be non-nil in this table.\nlocal defaultConfig = {\n\t-- Enables asserts for internal Roact APIs. Useful for debugging Roact itself.\n\t[\"internalTypeChecks\"] = false,\n\t-- Enables stricter type asserts for Roact's public API.\n\t[\"typeChecks\"] = false,\n\t-- Enables storage of `debug.traceback()` values on elements for debugging.\n\t[\"elementTracing\"] = false,\n\t-- Enables validation of component props in stateful components.\n\t[\"propValidation\"] = false,\n}\n\n-- Build a list of valid configuration values up for debug messages.\nlocal defaultConfigKeys = {}\nfor key in pairs(defaultConfig) do\n\ttable.insert(defaultConfigKeys, key)\nend\n\nlocal Config = {}\n\nfunction Config.new()\n\tlocal self = {}\n\n\tself._currentConfig = setmetatable({}, {\n\t\t__index = function(_, key)\n\t\t\tlocal message = (\"Invalid global configuration key %q. Valid configuration keys are: %s\"):format(\n\t\t\t\ttostring(key),\n\t\t\t\ttable.concat(defaultConfigKeys, \", \")\n\t\t\t)\n\n\t\t\terror(message, 3)\n\t\tend,\n\t})\n\n\t-- We manually bind these methods here so that the Config's methods can be\n\t-- used without passing in self, since they eventually get exposed on the\n\t-- root Roact object.\n\tself.set = function(...)\n\t\treturn Config.set(self, ...)\n\tend\n\n\tself.get = function(...)\n\t\treturn Config.get(self, ...)\n\tend\n\n\tself.scoped = function(...)\n\t\treturn Config.scoped(self, ...)\n\tend\n\n\tself.set(defaultConfig)\n\n\treturn self\nend\n\nfunction Config:set(configValues)\n\t-- Validate values without changing any configuration.\n\t-- We only want to apply this configuration if it's valid!\n\tfor key, value in pairs(configValues) do\n\t\tif defaultConfig[key] == nil then\n\t\t\tlocal message = (\"Invalid global configuration key %q (type %s). Valid configuration keys are: %s\"):format(\n\t\t\t\ttostring(key),\n\t\t\t\ttypeof(key),\n\t\t\t\ttable.concat(defaultConfigKeys, \", \")\n\t\t\t)\n\n\t\t\terror(message, 3)\n\t\tend\n\n\t\t-- Right now, all configuration values must be boolean.\n\t\tif typeof(value) ~= \"boolean\" then\n\t\t\tlocal message = (\n\t\t\t\t\"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false\"\n\t\t\t):format(tostring(value), typeof(value), tostring(key))\n\n\t\t\terror(message, 3)\n\t\tend\n\n\t\tself._currentConfig[key] = value\n\tend\nend\n\nfunction Config:get()\n\treturn self._currentConfig\nend\n\nfunction Config:scoped(configValues, callback)\n\tlocal previousValues = {}\n\tfor key, value in pairs(self._currentConfig) do\n\t\tpreviousValues[key] = value\n\tend\n\n\tself.set(configValues)\n\n\tlocal success, result = pcall(callback)\n\n\tself.set(previousValues)\n\n\tassert(success, result)\nend\n\nreturn Config\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "ComponentLifecyclePhase",
                        "ClassName": "ModuleScript",
                        "Source": "local Symbol = require(script.Parent.Symbol)\nlocal strict = require(script.Parent.strict)\n\nlocal ComponentLifecyclePhase = strict({\n\t-- Component methods\n\tInit = Symbol.named(\"init\"),\n\tRender = Symbol.named(\"render\"),\n\tShouldUpdate = Symbol.named(\"shouldUpdate\"),\n\tWillUpdate = Symbol.named(\"willUpdate\"),\n\tDidMount = Symbol.named(\"didMount\"),\n\tDidUpdate = Symbol.named(\"didUpdate\"),\n\tWillUnmount = Symbol.named(\"willUnmount\"),\n\n\t-- Phases describing reconciliation status\n\tReconcileChildren = Symbol.named(\"reconcileChildren\"),\n\tIdle = Symbol.named(\"idle\"),\n}, \"ComponentLifecyclePhase\")\n\nreturn ComponentLifecyclePhase\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Component.spec",
                        "Archivable": true,
                        "Children": [
                            {
                                "Name": "willUpdate.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked when updated via updateVirtualNode\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal willUpdateSpy = createSpy()\n\n\t\tMyComponent.willUpdate = willUpdateSpy.value\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal initialProps = {\n\t\t\ta = 5,\n\t\t}\n\t\tlocal initialElement = createElement(MyComponent, initialProps)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)\n\n\t\tlocal newProps = {\n\t\t\ta = 6,\n\t\t\tb = 2,\n\t\t}\n\t\tlocal newElement = createElement(MyComponent, newProps)\n\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\n\t\texpect(willUpdateSpy.callCount).to.equal(1)\n\n\t\tlocal values = willUpdateSpy:captureValues(\"self\", \"newProps\", \"newState\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\t\tassertDeepEqual(values.newProps, newProps)\n\t\tassertDeepEqual(values.newState, {})\n\tend)\n\n\tit(\"it should be invoked when updated via setState\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\t\tlocal setComponentState\n\n\t\tlocal willUpdateSpy = createSpy()\n\n\t\tMyComponent.willUpdate = willUpdateSpy.value\n\n\t\tfunction MyComponent:init()\n\t\t\tsetComponentState = function(state)\n\t\t\t\tself:setState(state)\n\t\t\tend\n\n\t\t\tself:setState({\n\t\t\t\tfoo = 1,\n\t\t\t})\n\t\tend\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal initialElement = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tnoopReconciler.mountVirtualNode(initialElement, hostParent, key)\n\n\t\texpect(willUpdateSpy.callCount).to.equal(0)\n\n\t\tsetComponentState({\n\t\t\tfoo = 2,\n\t\t})\n\n\t\texpect(willUpdateSpy.callCount).to.equal(1)\n\n\t\tlocal values = willUpdateSpy:captureValues(\"self\", \"newProps\", \"newState\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\t\tassertDeepEqual(values.newProps, {})\n\t\tassertDeepEqual(values.newState, {\n\t\t\tfoo = 2,\n\t\t})\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "willUnmount.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked when unmounted\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal willUnmountSpy = createSpy()\n\n\t\tMyComponent.willUnmount = willUnmountSpy.value\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal element = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\t\tnoopReconciler.unmountVirtualNode(node)\n\n\t\texpect(willUnmountSpy.callCount).to.equal(1)\n\n\t\tlocal values = willUnmountSpy:captureValues(\"self\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "validateProps.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal GlobalConfig = require(script.Parent.Parent.GlobalConfig)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked when mounted\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\t\tlocal validatePropsSpy = createSpy(function()\n\t\t\t\treturn true\n\t\t\tend)\n\n\t\t\tMyComponent.validateProps = validatePropsSpy.value\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(1)\n\t\tend)\n\tend)\n\n\tit(\"should be invoked when props change\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\t\tlocal validatePropsSpy = createSpy(function()\n\t\t\t\treturn true\n\t\t\tend)\n\n\t\t\tMyComponent.validateProps = validatePropsSpy.value\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent, { a = 1 })\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(1)\n\t\t\tvalidatePropsSpy:assertCalledWithDeepEqual({\n\t\t\t\ta = 1,\n\t\t\t})\n\n\t\t\tlocal newElement = createElement(MyComponent, { a = 2 })\n\t\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(2)\n\t\t\tvalidatePropsSpy:assertCalledWithDeepEqual({\n\t\t\t\ta = 2,\n\t\t\t})\n\t\tend)\n\tend)\n\n\tit(\"should not be invoked when state changes\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\t\tlocal setStateCallback = nil\n\t\t\tlocal validatePropsSpy = createSpy(function()\n\t\t\t\treturn true\n\t\t\tend)\n\n\t\t\tMyComponent.validateProps = validatePropsSpy.value\n\n\t\t\tfunction MyComponent:init()\n\t\t\t\tsetStateCallback = function(newState)\n\t\t\t\t\tself:setState(newState)\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent, { a = 1 })\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(1)\n\t\t\tvalidatePropsSpy:assertCalledWithDeepEqual({\n\t\t\t\ta = 1,\n\t\t\t})\n\n\t\t\tsetStateCallback({\n\t\t\t\tb = 1,\n\t\t\t})\n\n\t\t\texpect(validatePropsSpy.callCount).to.equal(1)\n\t\tend)\n\tend)\n\n\tit(\"should throw if validateProps is not a function\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\t\t\tMyComponent.validateProps = 1\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\texpect(function()\n\t\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tit(\"should throw if validateProps returns false\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\t\t\tMyComponent.validateProps = function()\n\t\t\t\treturn false\n\t\t\tend\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\texpect(function()\n\t\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tit(\"should include the component name in the error message\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\t\t\tMyComponent.validateProps = function()\n\t\t\t\treturn false\n\t\t\tend\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal success, error = pcall(function()\n\t\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\tend)\n\n\t\t\texpect(success).to.equal(false)\n\t\t\tlocal startIndex = error:find(\"MyComponent\")\n\t\t\texpect(startIndex).to.be.ok()\n\t\tend)\n\tend)\n\n\tit(\"should be invoked after defaultProps are applied\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\t\tlocal validatePropsSpy = createSpy(function()\n\t\t\t\treturn true\n\t\t\tend)\n\n\t\t\tMyComponent.validateProps = validatePropsSpy.value\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tMyComponent.defaultProps = {\n\t\t\t\tb = 2,\n\t\t\t}\n\n\t\t\tlocal element = createElement(MyComponent, { a = 1 })\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(1)\n\t\t\tvalidatePropsSpy:assertCalledWithDeepEqual({\n\t\t\t\ta = 1,\n\t\t\t\tb = 2,\n\t\t\t})\n\n\t\t\tlocal newElement = createElement(MyComponent, { a = 2 })\n\t\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(2)\n\t\t\tvalidatePropsSpy:assertCalledWithDeepEqual({\n\t\t\t\ta = 2,\n\t\t\t\tb = 2,\n\t\t\t})\n\t\tend)\n\tend)\n\n\tit(\"should not be invoked if the flag is off\", function()\n\t\tlocal config = {\n\t\t\tpropValidation = false,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\t\tlocal validatePropsSpy = createSpy(function()\n\t\t\t\treturn true\n\t\t\tend)\n\n\t\t\tMyComponent.validateProps = validatePropsSpy.value\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent, { a = 1 })\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(0)\n\n\t\t\tlocal newElement = createElement(MyComponent, { a = 2 })\n\t\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\t\t\texpect(validatePropsSpy.callCount).to.equal(0)\n\t\tend)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "shouldUpdate.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked when props update\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal capturedProps\n\t\tlocal capturedState\n\t\tlocal shouldUpdateSpy = createSpy(function(self)\n\t\t\tcapturedProps = self.props\n\t\t\tcapturedState = self.state\n\n\t\t\treturn true\n\t\tend)\n\n\t\tMyComponent.shouldUpdate = shouldUpdateSpy.value\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal initialProps = {\n\t\t\ta = 5,\n\t\t}\n\t\tlocal initialElement = createElement(MyComponent, initialProps)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)\n\n\t\texpect(shouldUpdateSpy.callCount).to.equal(0)\n\n\t\tlocal newProps = {\n\t\t\ta = 6,\n\t\t\tb = 2,\n\t\t}\n\t\tlocal newElement = createElement(MyComponent, newProps)\n\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\n\t\texpect(shouldUpdateSpy.callCount).to.equal(1)\n\n\t\tlocal values = shouldUpdateSpy:captureValues(\"self\", \"newProps\", \"newState\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\n\t\tassertDeepEqual(values.newProps, newProps)\n\n\t\tassertDeepEqual(capturedProps, initialProps)\n\n\t\texpect(values.newState).to.equal(capturedState)\n\t\tassertDeepEqual(capturedState, {})\n\tend)\n\n\tit(\"should be invoked when state is updated\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal initialState = {\n\t\t\ta = 1,\n\t\t}\n\n\t\tlocal setState\n\t\tlocal initState\n\t\tfunction MyComponent:init()\n\t\t\tsetState = function(...)\n\t\t\t\treturn self:setState(...)\n\t\t\tend\n\n\t\t\tself:setState(initialState)\n\n\t\t\tinitState = self.state\n\t\tend\n\n\t\tlocal capturedProps\n\t\tlocal capturedState\n\t\tlocal shouldUpdateSpy = createSpy(function(self)\n\t\t\tcapturedProps = self.props\n\t\t\tcapturedState = self.state\n\n\t\t\treturn true\n\t\tend)\n\n\t\tMyComponent.shouldUpdate = shouldUpdateSpy.value\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal initialElement = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tnoopReconciler.mountVirtualNode(initialElement, hostParent, key)\n\n\t\texpect(shouldUpdateSpy.callCount).to.equal(0)\n\n\t\tlocal newState = {\n\t\t\ta = 2,\n\t\t\tb = 3,\n\t\t}\n\n\t\tsetState(newState)\n\n\t\texpect(shouldUpdateSpy.callCount).to.equal(1)\n\n\t\tlocal values = shouldUpdateSpy:captureValues(\"self\", \"newProps\", \"newState\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\n\t\texpect(values.newProps).to.equal(capturedProps)\n\t\tassertDeepEqual(capturedProps, {})\n\n\t\tassertDeepEqual(capturedState, initialState)\n\t\texpect(capturedState).to.equal(initState)\n\t\tassertDeepEqual(values.newState, newState)\n\tend)\n\n\tit(\"should not abort an update when returning true\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tfunction MyComponent:shouldUpdate()\n\t\t\treturn true\n\t\tend\n\n\t\tlocal renderSpy = createSpy()\n\n\t\tMyComponent.render = renderSpy.value\n\n\t\tlocal initialElement = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)\n\n\t\texpect(renderSpy.callCount).to.equal(1)\n\n\t\tlocal newElement = createElement(MyComponent)\n\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\n\t\texpect(renderSpy.callCount).to.equal(2)\n\tend)\n\n\tit(\"should abort an update when retuning false\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tfunction MyComponent:shouldUpdate()\n\t\t\treturn false\n\t\tend\n\n\t\tlocal renderSpy = createSpy()\n\n\t\tMyComponent.render = renderSpy.value\n\n\t\tlocal initialElement = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(initialElement, hostParent, key)\n\n\t\texpect(renderSpy.callCount).to.equal(1)\n\n\t\tlocal newElement = createElement(MyComponent)\n\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\n\t\texpect(renderSpy.callCount).to.equal(1)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "setState.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal None = require(script.Parent.Parent.None)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tdescribe(\"setState\", function()\n\t\tit(\"should not trigger an extra update when called in init\", function()\n\t\t\tlocal renderCount = 0\n\t\t\tlocal updateCount = 0\n\t\t\tlocal capturedState\n\n\t\t\tlocal InitComponent = Component:extend(\"InitComponent\")\n\n\t\t\tfunction InitComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\ta = 1,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tfunction InitComponent:willUpdate()\n\t\t\t\tupdateCount = updateCount + 1\n\t\t\tend\n\n\t\t\tfunction InitComponent:render()\n\t\t\t\trenderCount = renderCount + 1\n\t\t\t\tcapturedState = self.state\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal initElement = createElement(InitComponent)\n\n\t\t\tnoopReconciler.mountVirtualTree(initElement)\n\n\t\t\texpect(renderCount).to.equal(1)\n\t\t\texpect(updateCount).to.equal(0)\n\t\t\texpect(capturedState.a).to.equal(1)\n\t\tend)\n\n\t\tit(\"should throw when called in render\", function()\n\t\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\n\t\t\tfunction TestComponent:render()\n\t\t\t\tself:setState({\n\t\t\t\t\ta = 1,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal renderElement = createElement(TestComponent)\n\n\t\t\tlocal success, result = pcall(noopReconciler.mountVirtualTree, renderElement)\n\n\t\t\texpect(success).to.equal(false)\n\t\t\texpect(result:match(\"render\")).to.be.ok()\n\t\t\texpect(result:match(\"TestComponent\")).to.be.ok()\n\t\tend)\n\n\t\tit(\"should throw when called in shouldUpdate\", function()\n\t\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\n\t\t\tfunction TestComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction TestComponent:shouldUpdate()\n\t\t\t\tself:setState({\n\t\t\t\t\ta = 1,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal initialElement = createElement(TestComponent)\n\t\t\tlocal updatedElement = createElement(TestComponent)\n\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(initialElement)\n\n\t\t\tlocal success, result = pcall(noopReconciler.updateVirtualTree, tree, updatedElement)\n\n\t\t\texpect(success).to.equal(false)\n\t\t\texpect(result:match(\"shouldUpdate\")).to.be.ok()\n\t\t\texpect(result:match(\"TestComponent\")).to.be.ok()\n\t\tend)\n\n\t\tit(\"should throw when called in willUpdate\", function()\n\t\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\n\t\t\tfunction TestComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction TestComponent:willUpdate()\n\t\t\t\tself:setState({\n\t\t\t\t\ta = 1,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal initialElement = createElement(TestComponent)\n\t\t\tlocal updatedElement = createElement(TestComponent)\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(initialElement)\n\n\t\t\tlocal success, result = pcall(noopReconciler.updateVirtualTree, tree, updatedElement)\n\n\t\t\texpect(success).to.equal(false)\n\t\t\texpect(result:match(\"willUpdate\")).to.be.ok()\n\t\t\texpect(result:match(\"TestComponent\")).to.be.ok()\n\t\tend)\n\n\t\tit(\"should throw when called in willUnmount\", function()\n\t\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\n\t\t\tfunction TestComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction TestComponent:willUnmount()\n\t\t\t\tself:setState({\n\t\t\t\t\ta = 1,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(TestComponent)\n\t\t\tlocal tree = noopReconciler.mountVirtualTree(element)\n\n\t\t\tlocal success, result = pcall(noopReconciler.unmountVirtualTree, tree)\n\n\t\t\texpect(success).to.equal(false)\n\t\t\texpect(result:match(\"willUnmount\")).to.be.ok()\n\t\t\texpect(result:match(\"TestComponent\")).to.be.ok()\n\t\tend)\n\n\t\tit(\"should remove values from state when the value is None\", function()\n\t\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\t\t\tlocal setStateCallback, getStateCallback\n\n\t\t\tfunction TestComponent:init()\n\t\t\t\tsetStateCallback = function(newState)\n\t\t\t\t\tself:setState(newState)\n\t\t\t\tend\n\n\t\t\t\tgetStateCallback = function()\n\t\t\t\t\treturn self.state\n\t\t\t\tend\n\n\t\t\t\tself:setState({\n\t\t\t\t\tvalue = 0,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tfunction TestComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(TestComponent)\n\t\t\tlocal instance = noopReconciler.mountVirtualNode(element, nil, \"Test\")\n\n\t\t\texpect(getStateCallback().value).to.equal(0)\n\n\t\t\tsetStateCallback({\n\t\t\t\tvalue = None,\n\t\t\t})\n\n\t\t\texpect(getStateCallback().value).to.equal(nil)\n\n\t\t\tnoopReconciler.unmountVirtualNode(instance)\n\t\tend)\n\n\t\tit(\"should invoke functions to compute a partial state\", function()\n\t\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\t\t\tlocal setStateCallback, getStateCallback, getPropsCallback\n\n\t\t\tfunction TestComponent:init()\n\t\t\t\tsetStateCallback = function(newState)\n\t\t\t\t\tself:setState(newState)\n\t\t\t\tend\n\n\t\t\t\tgetStateCallback = function()\n\t\t\t\t\treturn self.state\n\t\t\t\tend\n\n\t\t\t\tgetPropsCallback = function()\n\t\t\t\t\treturn self.props\n\t\t\t\tend\n\n\t\t\t\tself:setState({\n\t\t\t\t\tvalue = 0,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tfunction TestComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(TestComponent)\n\t\t\tlocal instance = noopReconciler.mountVirtualNode(element, nil, \"Test\")\n\n\t\t\texpect(getStateCallback().value).to.equal(0)\n\n\t\t\tsetStateCallback(function(state, props)\n\t\t\t\texpect(state).to.equal(getStateCallback())\n\t\t\t\texpect(props).to.equal(getPropsCallback())\n\n\t\t\t\treturn {\n\t\t\t\t\tvalue = state.value + 1,\n\t\t\t\t}\n\t\t\tend)\n\n\t\t\texpect(getStateCallback().value).to.equal(1)\n\n\t\t\tnoopReconciler.unmountVirtualNode(instance)\n\t\tend)\n\n\t\tit(\"should cancel rendering if the function returns nil\", function()\n\t\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\t\t\tlocal setStateCallback\n\t\t\tlocal renderCount = 0\n\n\t\t\tfunction TestComponent:init()\n\t\t\t\tsetStateCallback = function(newState)\n\t\t\t\t\tself:setState(newState)\n\t\t\t\tend\n\n\t\t\t\tself:setState({\n\t\t\t\t\tvalue = 0,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tfunction TestComponent:render()\n\t\t\t\trenderCount = renderCount + 1\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tlocal element = createElement(TestComponent)\n\t\t\tlocal instance = noopReconciler.mountVirtualNode(element, nil, \"Test\")\n\t\t\texpect(renderCount).to.equal(1)\n\n\t\t\tsetStateCallback(function(_state, _props)\n\t\t\t\treturn nil\n\t\t\tend)\n\n\t\t\texpect(renderCount).to.equal(1)\n\n\t\t\tnoopReconciler.unmountVirtualNode(instance)\n\t\tend)\n\tend)\n\n\tdescribe(\"setState suspension\", function()\n\t\tit(\"should defer setState triggered while reconciling\", function()\n\t\t\tlocal Child = Component:extend(\"Child\")\n\t\t\tlocal getParentStateCallback\n\n\t\t\tfunction Child:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction Child:didMount()\n\t\t\t\tself.props.callback()\n\t\t\tend\n\n\t\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\t\tfunction Parent:init()\n\t\t\t\tgetParentStateCallback = function()\n\t\t\t\t\treturn self.state\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction Parent:render()\n\t\t\t\treturn createElement(Child, {\n\t\t\t\t\tcallback = function()\n\t\t\t\t\t\tself:setState({\n\t\t\t\t\t\t\tfoo = \"bar\",\n\t\t\t\t\t\t})\n\t\t\t\t\tend,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(Parent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal result = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(result).to.be.ok()\n\t\t\texpect(getParentStateCallback().foo).to.equal(\"bar\")\n\t\tend)\n\n\t\tit(\"should defer setState triggered while reconciling during an update\", function()\n\t\t\tlocal Child = Component:extend(\"Child\")\n\t\t\tlocal getParentStateCallback\n\n\t\t\tfunction Child:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction Child:didUpdate()\n\t\t\t\tself.props.callback()\n\t\t\tend\n\n\t\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\t\tfunction Parent:init()\n\t\t\t\tgetParentStateCallback = function()\n\t\t\t\t\treturn self.state\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction Parent:render()\n\t\t\t\treturn createElement(Child, {\n\t\t\t\t\tcallback = function()\n\t\t\t\t\t\t-- This guards against a stack overflow that would be OUR fault\n\t\t\t\t\t\tif not self.state.foo then\n\t\t\t\t\t\t\tself:setState({\n\t\t\t\t\t\t\t\tfoo = \"bar\",\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\tend\n\t\t\t\t\tend,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(Parent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal result = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(result).to.be.ok()\n\t\t\texpect(getParentStateCallback().foo).to.equal(nil)\n\n\t\t\tresult = noopReconciler.updateVirtualNode(result, createElement(Parent))\n\n\t\t\texpect(result).to.be.ok()\n\t\t\texpect(getParentStateCallback().foo).to.equal(\"bar\")\n\n\t\t\tnoopReconciler.unmountVirtualNode(result)\n\t\tend)\n\n\t\tit(\"should combine pending state changes properly\", function()\n\t\t\tlocal Child = Component:extend(\"Child\")\n\t\t\tlocal getParentStateCallback\n\n\t\t\tfunction Child:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction Child:didMount()\n\t\t\t\tself.props.callback(\"foo\", 1)\n\t\t\t\tself.props.callback(\"bar\", 3)\n\t\t\tend\n\n\t\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\t\tfunction Parent:init()\n\t\t\t\tgetParentStateCallback = function()\n\t\t\t\t\treturn self.state\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction Parent:render()\n\t\t\t\treturn createElement(Child, {\n\t\t\t\t\tcallback = function(key, value)\n\t\t\t\t\t\tself:setState({\n\t\t\t\t\t\t\t[key] = value,\n\t\t\t\t\t\t})\n\t\t\t\t\tend,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(Parent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal result = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(result).to.be.ok()\n\t\t\texpect(getParentStateCallback().foo).to.equal(1)\n\t\t\texpect(getParentStateCallback().bar).to.equal(3)\n\n\t\t\tnoopReconciler.unmountVirtualNode(result)\n\t\tend)\n\n\t\tit(\"should abort properly when functional setState returns nil while deferred\", function()\n\t\t\tlocal Child = Component:extend(\"Child\")\n\n\t\t\tfunction Child:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction Child:didMount()\n\t\t\t\tself.props.callback()\n\t\t\tend\n\n\t\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\t\tlocal renderSpy = createSpy(function(self)\n\t\t\t\treturn createElement(Child, {\n\t\t\t\t\tcallback = function()\n\t\t\t\t\t\tself:setState(function()\n\t\t\t\t\t\t\t-- abort the setState\n\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\tend)\n\t\t\t\t\tend,\n\t\t\t\t})\n\t\t\tend)\n\n\t\t\tParent.render = renderSpy.value\n\n\t\t\tlocal element = createElement(Parent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal result = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(result).to.be.ok()\n\t\t\texpect(renderSpy.callCount).to.equal(1)\n\n\t\t\tnoopReconciler.unmountVirtualNode(result)\n\t\tend)\n\n\t\tit(\"should still apply pending state if a subsequent state update was aborted\", function()\n\t\t\tlocal Child = Component:extend(\"Child\")\n\t\t\tlocal getParentStateCallback\n\n\t\t\tfunction Child:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction Child:didMount()\n\t\t\t\tself.props.callback(function()\n\t\t\t\t\treturn {\n\t\t\t\t\t\tfoo = 1,\n\t\t\t\t\t}\n\t\t\t\tend)\n\t\t\t\tself.props.callback(function()\n\t\t\t\t\treturn nil\n\t\t\t\tend)\n\t\t\tend\n\n\t\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\t\tfunction Parent:init()\n\t\t\t\tgetParentStateCallback = function()\n\t\t\t\t\treturn self.state\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction Parent:render()\n\t\t\t\treturn createElement(Child, {\n\t\t\t\t\tcallback = function(stateUpdater)\n\t\t\t\t\t\tself:setState(stateUpdater)\n\t\t\t\t\tend,\n\t\t\t\t})\n\t\t\tend\n\n\t\t\tlocal element = createElement(Parent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal result = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(result).to.be.ok()\n\t\t\texpect(getParentStateCallback().foo).to.equal(1)\n\n\t\t\tnoopReconciler.unmountVirtualNode(result)\n\t\tend)\n\n\t\tit(\"should not re-process new state when pending state is present after update\", function()\n\t\t\tlocal setComponentState\n\t\t\tlocal getComponentState\n\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\t\tfunction MyComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\thasUpdatedOnce = false,\n\t\t\t\t\tcounter = 0,\n\t\t\t\t})\n\n\t\t\t\tsetComponentState = function(mapState)\n\t\t\t\t\tself:setState(mapState)\n\t\t\t\tend\n\n\t\t\t\tgetComponentState = function()\n\t\t\t\t\treturn self.state\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction MyComponent:didUpdate()\n\t\t\t\tif self.state.hasUpdatedOnce == false then\n\t\t\t\t\tself:setState({\n\t\t\t\t\t\thasUpdatedOnce = true,\n\t\t\t\t\t})\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(getComponentState().hasUpdatedOnce).to.equal(false)\n\t\t\texpect(getComponentState().counter).to.equal(0)\n\n\t\t\tsetComponentState(function(state)\n\t\t\t\treturn {\n\t\t\t\t\tcounter = state.counter + 1,\n\t\t\t\t}\n\t\t\tend)\n\n\t\t\texpect(getComponentState().hasUpdatedOnce).to.equal(true)\n\t\t\texpect(getComponentState().counter).to.equal(1)\n\t\tend)\n\n\t\tit(\"should throw when an infinite update is triggered\", function()\n\t\t\tlocal InfiniteUpdater = Component:extend(\"InfiniteUpdater\")\n\n\t\t\tfunction InfiniteUpdater:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction InfiniteUpdater:didMount()\n\t\t\t\tself:setState({})\n\t\t\tend\n\n\t\t\tfunction InfiniteUpdater:didUpdate()\n\t\t\t\tself:setState({})\n\t\t\tend\n\n\t\t\tlocal element = createElement(InfiniteUpdater)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal success, result = pcall(noopReconciler.mountVirtualNode, element, hostParent, key)\n\n\t\t\texpect(success).to.equal(false)\n\t\t\texpect(result:find(\"InfiniteUpdater\")).to.be.ok()\n\t\t\texpect(result:find(\"reached the setState update recursion limit\")).to.be.ok()\n\t\tend)\n\n\t\titSKIP(\"should process single updates with both new and pending state\", function()\n\t\t\t--[[\n\t\t\t\tThis situation shouldn't be possible currently, but the implementation\n\t\t\t\tshould support it for future update de-duplication\n\t\t\t]]\n\t\tend)\n\n\t\tit(\"should call trigger update after didMount when setting state in didMount\", function()\n\t\t\t--[[\n\t\t\t\tBefore setState suspension, it was possible to call setState in didMount but it would\n\t\t\t\tnot actually finish resolving didMount until after the entire update.\n\n\t\t\t\tThis is theoretically problematic, as it means that lifecycle methods like didUpdate\n\t\t\t\tcould be called before didMount is finished. setState suspension resolves this by\n\t\t\t\tsuspending state updates made in didMount and didUpdate as well as reconciliation\n\t\t\t]]\n\t\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\t\tfunction MyComponent:init()\n\t\t\t\tself:setState({\n\t\t\t\t\tstatus = \"initial mount\",\n\t\t\t\t})\n\n\t\t\t\tself.isMounted = false\n\t\t\tend\n\n\t\t\tfunction MyComponent:render()\n\t\t\t\treturn nil\n\t\t\tend\n\n\t\t\tfunction MyComponent:didMount()\n\t\t\t\tself:setState({\n\t\t\t\t\tstatus = \"mounted\",\n\t\t\t\t})\n\n\t\t\t\tself.isMounted = true\n\t\t\tend\n\n\t\t\tfunction MyComponent:didUpdate(_oldProps, oldState)\n\t\t\t\texpect(oldState.status).to.equal(\"initial mount\")\n\t\t\t\texpect(self.state.status).to.equal(\"mounted\")\n\n\t\t\t\texpect(self.isMounted).to.equal(true)\n\t\t\tend\n\n\t\t\tlocal element = createElement(MyComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Test\"\n\n\t\t\tlocal result = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\t\texpect(result).to.be.ok()\n\t\tend)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "render.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should throw on mount if not overridden\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal element = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tlocal success, result = pcall(function()\n\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\tend)\n\n\t\texpect(success).to.equal(false)\n\t\texpect(result:match(\"MyComponent\")).to.be.ok()\n\t\texpect(result:match(\"render\")).to.be.ok()\n\tend)\n\n\tit(\"should be invoked when a component is mounted\", function()\n\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\tlocal capturedProps\n\t\tlocal capturedState\n\t\tlocal renderSpy = createSpy(function(self)\n\t\t\tcapturedProps = self.props\n\t\t\tcapturedState = self.state\n\t\tend)\n\t\tFoo.render = renderSpy.value\n\n\t\tlocal element = createElement(Foo)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Foo Test\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\texpect(renderSpy.callCount).to.equal(1)\n\n\t\tlocal renderArguments = renderSpy:captureValues(\"self\")\n\n\t\texpect(Type.of(renderArguments.self)).to.equal(Type.StatefulComponentInstance)\n\t\tassertDeepEqual(capturedProps, {})\n\t\tassertDeepEqual(capturedState, {})\n\tend)\n\n\tit(\"should be invoked when a component is updated via props\", function()\n\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\tlocal capturedProps\n\t\tlocal capturedState\n\t\tlocal renderSpy = createSpy(function(self)\n\t\t\tcapturedProps = self.props\n\t\t\tcapturedState = self.state\n\t\tend)\n\t\tFoo.render = renderSpy.value\n\n\t\tlocal initialProps = {\n\t\t\ta = 2,\n\t\t}\n\t\tlocal element = createElement(Foo, initialProps)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Foo Test\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\texpect(renderSpy.callCount).to.equal(1)\n\n\t\tlocal firstRenderArguments = renderSpy:captureValues(\"self\")\n\t\tlocal firstProps = capturedProps\n\t\tlocal firstState = capturedState\n\n\t\texpect(Type.of(firstRenderArguments.self)).to.equal(Type.StatefulComponentInstance)\n\t\tassertDeepEqual(firstProps, initialProps)\n\t\tassertDeepEqual(firstState, {})\n\n\t\tlocal updatedProps = {\n\t\t\ta = 3,\n\t\t}\n\t\tlocal newElement = createElement(Foo, updatedProps)\n\n\t\tnoopReconciler.updateVirtualNode(node, newElement)\n\n\t\texpect(renderSpy.callCount).to.equal(2)\n\n\t\tlocal secondRenderArguments = renderSpy:captureValues(\"self\")\n\t\tlocal secondProps = capturedProps\n\t\tlocal secondState = capturedState\n\n\t\texpect(Type.of(secondRenderArguments.self)).to.equal(Type.StatefulComponentInstance)\n\t\texpect(secondProps).never.to.equal(firstProps)\n\t\tassertDeepEqual(secondProps, updatedProps)\n\t\texpect(secondState).to.equal(firstState)\n\tend)\n\n\tit(\"should be invoked when a component is updated via state\", function()\n\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\tlocal setState\n\t\tfunction Foo:init()\n\t\t\tsetState = function(...)\n\t\t\t\treturn self:setState(...)\n\t\t\tend\n\t\tend\n\n\t\tlocal capturedProps\n\t\tlocal capturedState\n\t\tlocal renderSpy = createSpy(function(self)\n\t\t\tcapturedProps = self.props\n\t\t\tcapturedState = self.state\n\t\tend)\n\t\tFoo.render = renderSpy.value\n\n\t\tlocal element = createElement(Foo)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Foo Test\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\texpect(renderSpy.callCount).to.equal(1)\n\n\t\tlocal firstRenderArguments = renderSpy:captureValues(\"self\")\n\t\tlocal firstProps = capturedProps\n\t\tlocal firstState = capturedState\n\n\t\texpect(Type.of(firstRenderArguments.self)).to.equal(Type.StatefulComponentInstance)\n\n\t\tsetState({})\n\n\t\texpect(renderSpy.callCount).to.equal(2)\n\n\t\tlocal renderArguments = renderSpy:captureValues(\"self\")\n\n\t\texpect(Type.of(renderArguments.self)).to.equal(Type.StatefulComponentInstance)\n\t\texpect(capturedProps).to.equal(firstProps)\n\t\texpect(capturedState).never.to.equal(firstState)\n\tend)\n\n\titSKIP(\"Test defaultProps on initial render\", function() end)\n\titSKIP(\"Test defaultProps on prop update\", function() end)\n\titSKIP(\"Test defaultProps on state update\", function() end)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "legacyContext.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be provided as a mutable self._context in Component:init\", function()\n\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\tfunction Provider:init()\n\t\t\tself._context.foo = \"bar\"\n\t\tend\n\n\t\tfunction Provider:render() end\n\n\t\tlocal element = createElement(Provider)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Provider\"\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\tlocal expectedContext = {\n\t\t\tfoo = \"bar\",\n\t\t}\n\n\t\tassertDeepEqual(node.legacyContext, expectedContext)\n\tend)\n\n\tit(\"should be inherited from parent stateful nodes\", function()\n\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\tlocal capturedContext\n\t\tfunction Consumer:init()\n\t\t\tcapturedContext = self._context\n\t\tend\n\n\t\tfunction Consumer:render() end\n\n\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\tfunction Parent:render()\n\t\t\treturn createElement(Consumer)\n\t\tend\n\n\t\tlocal element = createElement(Parent)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Parent\"\n\t\tlocal context = {\n\t\t\thello = \"world\",\n\t\t\tvalue = 6,\n\t\t}\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)\n\n\t\texpect(capturedContext).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(node.legacyContext)\n\t\tassertDeepEqual(node.legacyContext, context)\n\t\tassertDeepEqual(capturedContext, context)\n\tend)\n\n\tit(\"should be inherited from parent function nodes\", function()\n\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\tlocal capturedContext\n\t\tfunction Consumer:init()\n\t\t\tcapturedContext = self._context\n\t\tend\n\n\t\tfunction Consumer:render() end\n\n\t\tlocal function Parent()\n\t\t\treturn createElement(Consumer)\n\t\tend\n\n\t\tlocal element = createElement(Parent)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Parent\"\n\t\tlocal context = {\n\t\t\thello = \"world\",\n\t\t\tvalue = 6,\n\t\t}\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)\n\n\t\texpect(capturedContext).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(node.legacyContext)\n\t\tassertDeepEqual(node.legacyContext, context)\n\t\tassertDeepEqual(capturedContext, context)\n\tend)\n\n\tit(\"should contain values put into the tree by parent nodes\", function()\n\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\tlocal capturedContext\n\t\tfunction Consumer:init()\n\t\t\tcapturedContext = self._context\n\t\tend\n\n\t\tfunction Consumer:render() end\n\n\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\tfunction Provider:init()\n\t\t\tself._context.frob = \"ulator\"\n\t\tend\n\n\t\tfunction Provider:render()\n\t\t\treturn createElement(Consumer)\n\t\tend\n\n\t\tlocal element = createElement(Provider)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Consumer\"\n\t\tlocal context = {\n\t\t\tdont = \"try it\",\n\t\t}\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, nil, context)\n\n\t\tlocal initialContext = {\n\t\t\tdont = \"try it\",\n\t\t}\n\n\t\tlocal expectedContext = {\n\t\t\tdont = \"try it\",\n\t\t\tfrob = \"ulator\",\n\t\t}\n\n\t\t-- Because components mutate context, we're careful with equality\n\t\texpect(node.legacyContext).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(node.legacyContext)\n\n\t\tassertDeepEqual(context, initialContext)\n\t\tassertDeepEqual(node.legacyContext, expectedContext)\n\t\tassertDeepEqual(capturedContext, expectedContext)\n\tend)\n\n\tit(\"should transfer context to children that are replaced\", function()\n\t\tlocal ConsumerA = Component:extend(\"ConsumerA\")\n\n\t\tlocal capturedContextA\n\t\tfunction ConsumerA:init()\n\t\t\tself._context.A = \"hello\"\n\n\t\t\tcapturedContextA = self._context\n\t\tend\n\n\t\tfunction ConsumerA:render() end\n\n\t\tlocal ConsumerB = Component:extend(\"ConsumerB\")\n\n\t\tlocal capturedContextB\n\t\tfunction ConsumerB:init()\n\t\t\tself._context.B = \"hello\"\n\n\t\t\tcapturedContextB = self._context\n\t\tend\n\n\t\tfunction ConsumerB:render() end\n\n\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\tfunction Provider:init()\n\t\t\tself._context.frob = \"ulator\"\n\t\tend\n\n\t\tfunction Provider:render()\n\t\t\tlocal useConsumerB = self.props.useConsumerB\n\n\t\t\tif useConsumerB then\n\t\t\t\treturn createElement(ConsumerB)\n\t\t\telse\n\t\t\t\treturn createElement(ConsumerA)\n\t\t\tend\n\t\tend\n\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Consumer\"\n\n\t\tlocal element = createElement(Provider)\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\tlocal expectedContextA = {\n\t\t\tfrob = \"ulator\",\n\t\t\tA = \"hello\",\n\t\t}\n\n\t\tassertDeepEqual(capturedContextA, expectedContextA)\n\n\t\tlocal expectedContextB = {\n\t\t\tfrob = \"ulator\",\n\t\t\tB = \"hello\",\n\t\t}\n\n\t\tlocal replacedElement = createElement(Provider, {\n\t\t\tuseConsumerB = true,\n\t\t})\n\t\tnoopReconciler.updateVirtualNode(node, replacedElement)\n\n\t\tassertDeepEqual(capturedContextB, expectedContextB)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "init.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked with props when mounted\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal initSpy = createSpy()\n\n\t\tMyComponent.init = initSpy.value\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal props = {\n\t\t\ta = 5,\n\t\t}\n\t\tlocal element = createElement(MyComponent, props)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Some Component Key\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\texpect(initSpy.callCount).to.equal(1)\n\n\t\tlocal values = initSpy:captureValues(\"self\", \"props\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\t\texpect(typeof(values.props)).to.equal(\"table\")\n\t\tassertDeepEqual(values.props, props)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "getElementTraceback.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal GlobalConfig = require(script.Parent.Parent.GlobalConfig)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should return stack traces in initial renders\", function()\n\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\n\t\tlocal stackTrace\n\t\tfunction TestComponent:init()\n\t\t\tstackTrace = self:getElementTraceback()\n\t\tend\n\n\t\tfunction TestComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal config = {\n\t\t\telementTracing = true,\n\t\t}\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal element = createElement(TestComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Some key\"\n\n\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\tend)\n\n\t\texpect(stackTrace).to.be.a(\"string\")\n\tend)\n\n\titSKIP(\"it should return an updated stack trace after an update\", function() end)\n\n\tit(\"should return nil when elementTracing is off\", function()\n\t\tlocal stackTrace = nil\n\n\t\tlocal config = {\n\t\t\telementTracing = false,\n\t\t}\n\n\t\tlocal TestComponent = Component:extend(\"TestComponent\")\n\n\t\tfunction TestComponent:init()\n\t\t\tstackTrace = self:getElementTraceback()\n\t\tend\n\n\t\tfunction TestComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tGlobalConfig.scoped(config, function()\n\t\t\tlocal element = createElement(TestComponent)\n\t\t\tlocal hostParent = nil\n\t\t\tlocal key = \"Some key\"\n\n\t\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\t\tend)\n\n\t\texpect(stackTrace).to.equal(nil)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "getDerivedStateFromProps.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createFragment = require(script.Parent.Parent.createFragment)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked on initial mount\", function()\n\t\tlocal getDerivedSpy = createSpy()\n\t\tlocal WithDerivedState = Component:extend(\"WithDerivedState\")\n\n\t\tWithDerivedState.getDerivedStateFromProps = getDerivedSpy.value\n\n\t\tfunction WithDerivedState:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal element = createElement(WithDerivedState, {\n\t\t\tsomeProp = 1,\n\t\t})\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"WithDerivedState\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\texpect(getDerivedSpy.callCount).to.equal(1)\n\n\t\tlocal values = getDerivedSpy:captureValues(\"props\", \"state\")\n\n\t\tassertDeepEqual(values.props, { someProp = 1 })\n\t\tassertDeepEqual(values.state, {})\n\tend)\n\n\tit(\"should be invoked when updated via props\", function()\n\t\tlocal getDerivedSpy = createSpy()\n\t\tlocal WithDerivedState = Component:extend(\"WithDerivedState\")\n\n\t\tWithDerivedState.getDerivedStateFromProps = getDerivedSpy.value\n\n\t\tfunction WithDerivedState:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"WithDerivedState\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(\n\t\t\tcreateElement(WithDerivedState, {\n\t\t\t\tsomeProp = 1,\n\t\t\t}),\n\t\t\thostParent,\n\t\t\thostKey\n\t\t)\n\n\t\tnoopReconciler.updateVirtualNode(\n\t\t\tnode,\n\t\t\tcreateElement(WithDerivedState, {\n\t\t\t\tsomeProp = 2,\n\t\t\t})\n\t\t)\n\n\t\texpect(getDerivedSpy.callCount).to.equal(2)\n\n\t\tlocal values = getDerivedSpy:captureValues(\"props\", \"state\")\n\n\t\tassertDeepEqual(values.props, { someProp = 2 })\n\t\tassertDeepEqual(values.state, {})\n\tend)\n\n\tit(\"should be invoked when updated via state\", function()\n\t\tlocal getDerivedSpy = createSpy()\n\t\tlocal WithDerivedState = Component:extend(\"WithDerivedState\")\n\n\t\tWithDerivedState.getDerivedStateFromProps = getDerivedSpy.value\n\n\t\tfunction WithDerivedState:init()\n\t\t\tself:setState({\n\t\t\t\tsomeState = 1,\n\t\t\t})\n\t\tend\n\n\t\tfunction WithDerivedState:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal element = createElement(WithDerivedState)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"WithDerivedState\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\tnoopReconciler.updateVirtualNode(node, element, {\n\t\t\tsomeState = 2,\n\t\t})\n\n\t\t-- getDerivedStateFromProps will be called:\n\t\t-- * Once on empty props\n\t\t-- * Once during the self:setState in init\n\t\t-- * Once more, defensively, on the resulting state AFTER init\n\t\t-- * On updating with new state via updateVirtualNode\n\t\texpect(getDerivedSpy.callCount).to.equal(4)\n\n\t\tlocal values = getDerivedSpy:captureValues(\"props\", \"state\")\n\n\t\tassertDeepEqual(values.props, {})\n\t\tassertDeepEqual(values.state, { someState = 2 })\n\tend)\n\n\tit(\"should be invoked when updating via state in init (which skips reconciliation)\", function()\n\t\tlocal getDerivedSpy = createSpy()\n\t\tlocal WithDerivedState = Component:extend(\"WithDerivedState\")\n\n\t\tWithDerivedState.getDerivedStateFromProps = getDerivedSpy.value\n\n\t\tfunction WithDerivedState:init()\n\t\t\tself:setState({\n\t\t\t\tstateFromInit = 1,\n\t\t\t})\n\t\tend\n\n\t\tfunction WithDerivedState:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal element = createElement(WithDerivedState, {\n\t\t\tsomeProp = 1,\n\t\t})\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"WithDerivedState\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\t-- getDerivedStateFromProps will be called:\n\t\t-- * Once on empty props\n\t\t-- * Once during the self:setState in init\n\t\t-- * Once more, defensively, on the resulting state AFTER init\n\t\texpect(getDerivedSpy.callCount).to.equal(3)\n\n\t\tlocal values = getDerivedSpy:captureValues(\"props\", \"state\")\n\n\t\tassertDeepEqual(values.props, {\n\t\t\tsomeProp = 1,\n\t\t})\n\t\tassertDeepEqual(values.state, {\n\t\t\tstateFromInit = 1,\n\t\t})\n\tend)\n\n\tit(\"should receive defaultProps\", function()\n\t\tlocal getDerivedSpy = createSpy()\n\t\tlocal WithDerivedState = Component:extend(\"WithDerivedState\")\n\n\t\tWithDerivedState.defaultProps = {\n\t\t\tsomeDefaultProp = \"foo\",\n\t\t}\n\n\t\tWithDerivedState.getDerivedStateFromProps = getDerivedSpy.value\n\n\t\tfunction WithDerivedState:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal element = createElement(WithDerivedState, {\n\t\t\tsomeProp = 1,\n\t\t})\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"WithDerivedState\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\texpect(getDerivedSpy.callCount).to.equal(1)\n\n\t\tlocal values = getDerivedSpy:captureValues(\"props\", \"state\")\n\n\t\tassertDeepEqual(values.props, {\n\t\t\tsomeDefaultProp = \"foo\",\n\t\t\tsomeProp = 1,\n\t\t})\n\n\t\t-- Update via props, confirm that defaultProp is still present\n\t\telement = createElement(WithDerivedState, {\n\t\t\tsomeProp = 2,\n\t\t})\n\n\t\tnoopReconciler.updateVirtualNode(node, element)\n\n\t\texpect(getDerivedSpy.callCount).to.equal(2)\n\n\t\tvalues = getDerivedSpy:captureValues(\"props\", \"state\")\n\n\t\tassertDeepEqual(values.props, {\n\t\t\tsomeDefaultProp = \"foo\",\n\t\t\tsomeProp = 2,\n\t\t})\n\tend)\n\n\tit(\"should derive state for all setState updates, even when deferred\", function()\n\t\tlocal Child = Component:extend(\"Child\")\n\t\tlocal stateUpdaterSpy = createSpy(function()\n\t\t\treturn {}\n\t\tend)\n\t\tlocal stateDerivedSpy = createSpy()\n\n\t\tfunction Child:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tfunction Child:didMount()\n\t\t\tself.props.callback()\n\t\tend\n\n\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\tParent.getDerivedStateFromProps = stateDerivedSpy.value\n\n\t\tfunction Parent:render()\n\t\t\tlocal callback = function()\n\t\t\t\tself:setState(stateUpdaterSpy.value)\n\t\t\tend\n\n\t\t\treturn createFragment({\n\t\t\t\tChildA = createElement(Child, {\n\t\t\t\t\tcallback = callback,\n\t\t\t\t}),\n\t\t\t\tChildB = createElement(Child, {\n\t\t\t\t\tcallback = callback,\n\t\t\t\t}),\n\t\t\t})\n\t\tend\n\n\t\tlocal element = createElement(Parent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\texpect(stateUpdaterSpy.callCount).to.equal(2)\n\n\t\t-- getDerivedStateFromProps is always called on initial state\n\t\texpect(stateDerivedSpy.callCount).to.equal(3)\n\tend)\n\n\tit(\"should have derived state after assigning to state in init\", function()\n\t\tlocal getStateCallback\n\t\tlocal getDerivedSpy = createSpy(function()\n\t\t\treturn {\n\t\t\t\tderived = true,\n\t\t\t}\n\t\tend)\n\t\tlocal WithDerivedState = Component:extend(\"WithDerivedState\")\n\n\t\tWithDerivedState.getDerivedStateFromProps = getDerivedSpy.value\n\n\t\tfunction WithDerivedState:init()\n\t\t\tself.state = {\n\t\t\t\tinit = true,\n\t\t\t}\n\n\t\t\tgetStateCallback = function()\n\t\t\t\treturn self.state\n\t\t\tend\n\t\tend\n\n\t\tfunction WithDerivedState:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"WithDerivedState\"\n\t\tlocal element = createElement(WithDerivedState)\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\texpect(getDerivedSpy.callCount).to.equal(2)\n\n\t\tassertDeepEqual(getStateCallback(), {\n\t\t\tinit = true,\n\t\t\tderived = true,\n\t\t})\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "extend.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tit(\"should be extendable\", function()\n\t\tlocal MyComponent = Component:extend(\"The Senate\")\n\n\t\texpect(MyComponent).to.be.ok()\n\t\texpect(Type.of(MyComponent)).to.equal(Type.StatefulComponentClass)\n\tend)\n\n\tit(\"should prevent extending a user component\", function()\n\t\tlocal MyComponent = Component:extend(\"Sheev\")\n\n\t\texpect(function()\n\t\t\tMyComponent:extend(\"Frank\")\n\t\tend).to.throw()\n\tend)\n\n\tit(\"should use a given name\", function()\n\t\tlocal MyComponent = Component:extend(\"FooBar\")\n\n\t\tlocal name = tostring(MyComponent)\n\n\t\texpect(name).to.be.a(\"string\")\n\t\texpect(name:find(\"FooBar\")).to.be.ok()\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "didUpdate.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked when updated via updateVirtualNode\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal didUpdateSpy = createSpy()\n\t\tMyComponent.didUpdate = didUpdateSpy.value\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal initialProps = {\n\t\t\ta = 5,\n\t\t}\n\t\tlocal initialElement = createElement(MyComponent, initialProps)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tlocal virtualNode = noopReconciler.mountVirtualNode(initialElement, hostParent, key)\n\n\t\texpect(didUpdateSpy.callCount).to.equal(0)\n\n\t\tlocal newProps = {\n\t\t\ta = 6,\n\t\t\tb = 2,\n\t\t}\n\t\tlocal newElement = createElement(MyComponent, newProps)\n\t\tnoopReconciler.updateVirtualNode(virtualNode, newElement)\n\n\t\texpect(didUpdateSpy.callCount).to.equal(1)\n\n\t\tlocal values = didUpdateSpy:captureValues(\"self\", \"oldProps\", \"oldState\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\t\tassertDeepEqual(values.oldProps, initialProps)\n\t\tassertDeepEqual(values.oldState, {})\n\tend)\n\n\tit(\"should be invoked when updated via setState\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal didUpdateSpy = createSpy()\n\t\tMyComponent.didUpdate = didUpdateSpy.value\n\n\t\tlocal initialState = {\n\t\t\ta = 4,\n\t\t}\n\n\t\tlocal setState\n\t\tfunction MyComponent:init()\n\t\t\tsetState = function(...)\n\t\t\t\treturn self:setState(...)\n\t\t\tend\n\n\t\t\tself:setState(initialState)\n\t\tend\n\n\t\tfunction MyComponent:render() end\n\n\t\tlocal element = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\texpect(didUpdateSpy.callCount).to.equal(0)\n\n\t\tsetState({\n\t\t\ta = 5,\n\t\t})\n\n\t\texpect(didUpdateSpy.callCount).to.equal(1)\n\n\t\tlocal values = didUpdateSpy:captureValues(\"self\", \"oldProps\", \"oldState\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\t\tassertDeepEqual(values.oldProps, {})\n\t\tassertDeepEqual(values.oldState, initialState)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "didMount.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal createSpy = require(script.Parent.Parent.createSpy)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal Type = require(script.Parent.Parent.Type)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be invoked when mounted\", function()\n\t\tlocal MyComponent = Component:extend(\"MyComponent\")\n\n\t\tlocal didMountSpy = createSpy()\n\n\t\tMyComponent.didMount = didMountSpy.value\n\n\t\tfunction MyComponent:render()\n\t\t\treturn nil\n\t\tend\n\n\t\tlocal element = createElement(MyComponent)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Test\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\texpect(didMountSpy.callCount).to.equal(1)\n\n\t\tlocal values = didMountSpy:captureValues(\"self\")\n\n\t\texpect(Type.of(values.self)).to.equal(Type.StatefulComponentInstance)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "defaultProps.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal None = require(script.Parent.Parent.None)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should fill in when mounting before init\", function()\n\t\tlocal defaultProps = {\n\t\t\ta = 3,\n\t\t\tb = 2,\n\t\t}\n\n\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\tFoo.defaultProps = defaultProps\n\n\t\tlocal capturedProps\n\t\tfunction Foo:init()\n\t\t\tcapturedProps = self.props\n\t\tend\n\n\t\tfunction Foo:render() end\n\n\t\tlocal initialProps = {\n\t\t\tb = 4,\n\t\t\tc = 6,\n\t\t}\n\n\t\tlocal element = createElement(Foo, initialProps)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Some Foo\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\tlocal expectedProps = {\n\t\t\ta = defaultProps.a,\n\t\t\tb = initialProps.b,\n\t\t\tc = initialProps.c,\n\t\t}\n\n\t\tassertDeepEqual(capturedProps, expectedProps)\n\tend)\n\n\tit(\"should fill in when updating via props\", function()\n\t\tlocal defaultProps = {\n\t\t\ta = 3,\n\t\t\tb = 2,\n\t\t}\n\n\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\tFoo.defaultProps = defaultProps\n\n\t\tlocal capturedProps\n\t\tfunction Foo:render()\n\t\t\tcapturedProps = self.props\n\t\tend\n\n\t\tlocal initialProps = {\n\t\t\tb = 4,\n\t\t\tc = 6,\n\t\t}\n\n\t\tlocal element = createElement(Foo, initialProps)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Some Foo\"\n\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\tlocal updatedProps = {\n\t\t\tc = 5,\n\t\t}\n\t\tlocal updatedElement = createElement(Foo, updatedProps)\n\n\t\tnoopReconciler.updateVirtualNode(node, updatedElement)\n\n\t\tlocal expectedProps = {\n\t\t\ta = defaultProps.a,\n\t\t\tb = defaultProps.b,\n\t\t\tc = updatedProps.c,\n\t\t}\n\n\t\tassertDeepEqual(capturedProps, expectedProps)\n\tend)\n\n\tit(\"should respect None to override a default prop with nil\", function()\n\t\tlocal defaultProps = {\n\t\t\ta = 3,\n\t\t\tb = 2,\n\t\t}\n\n\t\tlocal Foo = Component:extend(\"Foo\")\n\n\t\tFoo.defaultProps = defaultProps\n\n\t\tlocal capturedProps\n\t\tfunction Foo:render()\n\t\t\tcapturedProps = self.props\n\t\tend\n\n\t\tlocal initialProps = {\n\t\t\tb = None,\n\t\t\tc = 4,\n\t\t}\n\n\t\tlocal element = createElement(Foo, initialProps)\n\t\tlocal hostParent = nil\n\t\tlocal key = \"Some Foo\"\n\n\t\tnoopReconciler.mountVirtualNode(element, hostParent, key)\n\n\t\tlocal expectedProps = {\n\t\t\ta = defaultProps.a,\n\t\t\tb = nil,\n\t\t\tc = initialProps.c,\n\t\t}\n\n\t\tassertDeepEqual(capturedProps, expectedProps)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            },
                            {
                                "Name": "context.spec",
                                "ClassName": "ModuleScript",
                                "Source": "return function()\n\tlocal assertDeepEqual = require(script.Parent.Parent.assertDeepEqual)\n\tlocal createElement = require(script.Parent.Parent.createElement)\n\tlocal createReconciler = require(script.Parent.Parent.createReconciler)\n\tlocal NoopRenderer = require(script.Parent.Parent.NoopRenderer)\n\tlocal oneChild = require(script.Parent.Parent.oneChild)\n\n\tlocal Component = require(script.Parent.Parent.Component)\n\n\tlocal noopReconciler = createReconciler(NoopRenderer)\n\n\tit(\"should be provided as an internal api on Component\", function()\n\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\tfunction Provider:init()\n\t\t\tself:__addContext(\"foo\", \"bar\")\n\t\tend\n\n\t\tfunction Provider:render() end\n\n\t\tlocal element = createElement(Provider)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Provider\"\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\tlocal expectedContext = {\n\t\t\tfoo = \"bar\",\n\t\t}\n\n\t\tassertDeepEqual(node.context, expectedContext)\n\tend)\n\n\tit(\"should be inherited from parent stateful nodes\", function()\n\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\tlocal capturedContext\n\t\tfunction Consumer:init()\n\t\t\tcapturedContext = {\n\t\t\t\thello = self:__getContext(\"hello\"),\n\t\t\t\tvalue = self:__getContext(\"value\"),\n\t\t\t}\n\t\tend\n\n\t\tfunction Consumer:render() end\n\n\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\tfunction Parent:render()\n\t\t\treturn createElement(Consumer)\n\t\tend\n\n\t\tlocal element = createElement(Parent)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Parent\"\n\t\tlocal context = {\n\t\t\thello = \"world\",\n\t\t\tvalue = 6,\n\t\t}\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)\n\n\t\texpect(capturedContext).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(node.context)\n\t\tassertDeepEqual(node.context, context)\n\t\tassertDeepEqual(capturedContext, context)\n\tend)\n\n\tit(\"should be inherited from parent function nodes\", function()\n\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\tlocal capturedContext\n\t\tfunction Consumer:init()\n\t\t\tcapturedContext = {\n\t\t\t\thello = self:__getContext(\"hello\"),\n\t\t\t\tvalue = self:__getContext(\"value\"),\n\t\t\t}\n\t\tend\n\n\t\tfunction Consumer:render() end\n\n\t\tlocal function Parent()\n\t\t\treturn createElement(Consumer)\n\t\tend\n\n\t\tlocal element = createElement(Parent)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Parent\"\n\t\tlocal context = {\n\t\t\thello = \"world\",\n\t\t\tvalue = 6,\n\t\t}\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)\n\n\t\texpect(capturedContext).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(node.context)\n\t\tassertDeepEqual(node.context, context)\n\t\tassertDeepEqual(capturedContext, context)\n\tend)\n\n\tit(\"should not copy the context table if it doesn't need to\", function()\n\t\tlocal Parent = Component:extend(\"Parent\")\n\n\t\tfunction Parent:init()\n\t\t\tself:__addContext(\"parent\", \"I'm here!\")\n\t\tend\n\n\t\tfunction Parent:render()\n\t\t\t-- Create some child element\n\t\t\treturn createElement(function() end)\n\t\tend\n\n\t\tlocal element = createElement(Parent)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Parent\"\n\t\tlocal parentNode = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\tlocal expectedContext = {\n\t\t\tparent = \"I'm here!\",\n\t\t}\n\n\t\tassertDeepEqual(parentNode.context, expectedContext)\n\n\t\tlocal childNode = oneChild(parentNode.children)\n\n\t\t-- Parent and child should have the same context table\n\t\texpect(parentNode.context).to.equal(childNode.context)\n\tend)\n\n\tit(\"should not allow context to move up the tree\", function()\n\t\tlocal ChildProvider = Component:extend(\"ChildProvider\")\n\n\t\tfunction ChildProvider:init()\n\t\t\tself:__addContext(\"child\", \"I'm here too!\")\n\t\tend\n\n\t\tfunction ChildProvider:render() end\n\n\t\tlocal ParentProvider = Component:extend(\"ParentProvider\")\n\n\t\tfunction ParentProvider:init()\n\t\t\tself:__addContext(\"parent\", \"I'm here!\")\n\t\tend\n\n\t\tfunction ParentProvider:render()\n\t\t\treturn createElement(ChildProvider)\n\t\tend\n\n\t\tlocal element = createElement(ParentProvider)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Parent\"\n\n\t\tlocal parentNode = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\t\tlocal childNode = oneChild(parentNode.children)\n\n\t\tlocal expectedParentContext = {\n\t\t\tparent = \"I'm here!\",\n\t\t\t-- Context does not travel back up\n\t\t}\n\n\t\tlocal expectedChildContext = {\n\t\t\tparent = \"I'm here!\",\n\t\t\tchild = \"I'm here too!\",\n\t\t}\n\n\t\tassertDeepEqual(parentNode.context, expectedParentContext)\n\t\tassertDeepEqual(childNode.context, expectedChildContext)\n\tend)\n\n\tit(\"should contain values put into the tree by parent nodes\", function()\n\t\tlocal Consumer = Component:extend(\"Consumer\")\n\n\t\tlocal capturedContext\n\t\tfunction Consumer:init()\n\t\t\tcapturedContext = {\n\t\t\t\tdont = self:__getContext(\"dont\"),\n\t\t\t\tfrob = self:__getContext(\"frob\"),\n\t\t\t}\n\t\tend\n\n\t\tfunction Consumer:render() end\n\n\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\tfunction Provider:init()\n\t\t\tself:__addContext(\"frob\", \"ulator\")\n\t\tend\n\n\t\tfunction Provider:render()\n\t\t\treturn createElement(Consumer)\n\t\tend\n\n\t\tlocal element = createElement(Provider)\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Consumer\"\n\t\tlocal context = {\n\t\t\tdont = \"try it\",\n\t\t}\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey, context)\n\n\t\tlocal initialContext = {\n\t\t\tdont = \"try it\",\n\t\t}\n\n\t\tlocal expectedContext = {\n\t\t\tdont = \"try it\",\n\t\t\tfrob = \"ulator\",\n\t\t}\n\n\t\t-- Because components mutate context, we're careful with equality\n\t\texpect(node.context).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(context)\n\t\texpect(capturedContext).never.to.equal(node.context)\n\n\t\tassertDeepEqual(context, initialContext)\n\t\tassertDeepEqual(node.context, expectedContext)\n\t\tassertDeepEqual(capturedContext, expectedContext)\n\tend)\n\n\tit(\"should transfer context to children that are replaced\", function()\n\t\tlocal ConsumerA = Component:extend(\"ConsumerA\")\n\n\t\tlocal function captureAllContext(component)\n\t\t\treturn {\n\t\t\t\tA = component:__getContext(\"A\"),\n\t\t\t\tB = component:__getContext(\"B\"),\n\t\t\t\tfrob = component:__getContext(\"frob\"),\n\t\t\t}\n\t\tend\n\n\t\tlocal capturedContextA\n\t\tfunction ConsumerA:init()\n\t\t\tself:__addContext(\"A\", \"hello\")\n\n\t\t\tcapturedContextA = captureAllContext(self)\n\t\tend\n\n\t\tfunction ConsumerA:render() end\n\n\t\tlocal ConsumerB = Component:extend(\"ConsumerB\")\n\n\t\tlocal capturedContextB\n\t\tfunction ConsumerB:init()\n\t\t\tself:__addContext(\"B\", \"hello\")\n\n\t\t\tcapturedContextB = captureAllContext(self)\n\t\tend\n\n\t\tfunction ConsumerB:render() end\n\n\t\tlocal Provider = Component:extend(\"Provider\")\n\n\t\tfunction Provider:init()\n\t\t\tself:__addContext(\"frob\", \"ulator\")\n\t\tend\n\n\t\tfunction Provider:render()\n\t\t\tlocal useConsumerB = self.props.useConsumerB\n\n\t\t\tif useConsumerB then\n\t\t\t\treturn createElement(ConsumerB)\n\t\t\telse\n\t\t\t\treturn createElement(ConsumerA)\n\t\t\tend\n\t\tend\n\n\t\tlocal hostParent = nil\n\t\tlocal hostKey = \"Consumer\"\n\n\t\tlocal element = createElement(Provider)\n\t\tlocal node = noopReconciler.mountVirtualNode(element, hostParent, hostKey)\n\n\t\tlocal expectedContextA = {\n\t\t\tfrob = \"ulator\",\n\t\t\tA = \"hello\",\n\t\t}\n\n\t\tassertDeepEqual(capturedContextA, expectedContextA)\n\n\t\tlocal expectedContextB = {\n\t\t\tfrob = \"ulator\",\n\t\t\tB = \"hello\",\n\t\t}\n\n\t\tlocal replacedElement = createElement(Provider, {\n\t\t\tuseConsumerB = true,\n\t\t})\n\t\tnoopReconciler.updateVirtualNode(node, replacedElement)\n\n\t\tassertDeepEqual(capturedContextB, expectedContextB)\n\tend)\nend\n",
                                "Children": [],
                                "Archivable": true
                            }
                        ],
                        "ClassName": "Folder"
                    },
                    {
                        "Name": "Component",
                        "ClassName": "ModuleScript",
                        "Source": "local assign = require(script.Parent.assign)\nlocal ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)\nlocal Type = require(script.Parent.Type)\nlocal Symbol = require(script.Parent.Symbol)\nlocal invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)\nlocal internalAssert = require(script.Parent.internalAssert)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\n--[[\n\tCalling setState during certain lifecycle allowed methods has the potential\n\tto create an infinitely updating component. Rather than time out, we exit\n\twith an error if an unreasonable number of self-triggering updates occur\n]]\nlocal MAX_PENDING_UPDATES = 100\n\nlocal InternalData = Symbol.named(\"InternalData\")\n\nlocal componentMissingRenderMessage = [[\nThe component %q is missing the `render` method.\n`render` must be defined when creating a Roact component!]]\n\nlocal tooManyUpdatesMessage = [[\nThe component %q has reached the setState update recursion limit.\nWhen using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]\n\nlocal componentClassMetatable = {}\n\nfunction componentClassMetatable:__tostring()\n\treturn self.__componentName\nend\n\nlocal Component = {}\nsetmetatable(Component, componentClassMetatable)\n\nComponent[Type] = Type.StatefulComponentClass\nComponent.__index = Component\nComponent.__componentName = \"Component\"\n\n--[[\n\tA method called by consumers of Roact to create a new component class.\n\tComponents can not be extended beyond this point, with the exception of\n\tPureComponent.\n]]\nfunction Component:extend(name)\n\tif config.typeChecks then\n\t\tassert(Type.of(self) == Type.StatefulComponentClass, \"Invalid `self` argument to `extend`.\")\n\t\tassert(typeof(name) == \"string\", \"Component class name must be a string\")\n\tend\n\n\tlocal class = {}\n\n\tfor key, value in pairs(self) do\n\t\t-- Roact opts to make consumers use composition over inheritance, which\n\t\t-- lines up with React.\n\t\t-- https://reactjs.org/docs/composition-vs-inheritance.html\n\t\tif key ~= \"extend\" then\n\t\t\tclass[key] = value\n\t\tend\n\tend\n\n\tclass[Type] = Type.StatefulComponentClass\n\tclass.__index = class\n\tclass.__componentName = name\n\n\tsetmetatable(class, componentClassMetatable)\n\n\treturn class\nend\n\nfunction Component:__getDerivedState(incomingProps, incomingState)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__getDerivedState`\")\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal componentClass = internalData.componentClass\n\n\tif componentClass.getDerivedStateFromProps ~= nil then\n\t\tlocal derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)\n\n\t\tif derivedState ~= nil then\n\t\t\tif config.typeChecks then\n\t\t\t\tassert(typeof(derivedState) == \"table\", \"getDerivedStateFromProps must return a table!\")\n\t\t\tend\n\n\t\t\treturn derivedState\n\t\tend\n\tend\n\n\treturn nil\nend\n\nfunction Component:setState(mapState)\n\tif config.typeChecks then\n\t\tassert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid `self` argument to `extend`.\")\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal lifecyclePhase = internalData.lifecyclePhase\n\n\t--[[\n\t\tWhen preparing to update, rendering, or unmounting, it is not safe\n\t\tto call `setState` as it will interfere with in-flight updates. It's\n\t\talso disallowed during unmounting\n\t]]\n\tif\n\t\tlifecyclePhase == ComponentLifecyclePhase.ShouldUpdate\n\t\tor lifecyclePhase == ComponentLifecyclePhase.WillUpdate\n\t\tor lifecyclePhase == ComponentLifecyclePhase.Render\n\t\tor lifecyclePhase == ComponentLifecyclePhase.WillUnmount\n\tthen\n\t\tlocal messageTemplate = invalidSetStateMessages[internalData.lifecyclePhase]\n\n\t\tlocal message = messageTemplate:format(tostring(internalData.componentClass))\n\n\t\terror(message, 2)\n\tend\n\n\tlocal pendingState = internalData.pendingState\n\n\tlocal partialState\n\tif typeof(mapState) == \"function\" then\n\t\tpartialState = mapState(pendingState or self.state, self.props)\n\n\t\t-- Abort the state update if the given state updater function returns nil\n\t\tif partialState == nil then\n\t\t\treturn\n\t\tend\n\telseif typeof(mapState) == \"table\" then\n\t\tpartialState = mapState\n\telse\n\t\terror(\"Invalid argument to setState, expected function or table\", 2)\n\tend\n\n\tlocal newState\n\tif pendingState ~= nil then\n\t\tnewState = assign(pendingState, partialState)\n\telse\n\t\tnewState = assign({}, self.state, partialState)\n\tend\n\n\tif lifecyclePhase == ComponentLifecyclePhase.Init then\n\t\t-- If `setState` is called in `init`, we can skip triggering an update!\n\t\tlocal derivedState = self:__getDerivedState(self.props, newState)\n\t\tself.state = assign(newState, derivedState)\n\telseif\n\t\tlifecyclePhase == ComponentLifecyclePhase.DidMount\n\t\tor lifecyclePhase == ComponentLifecyclePhase.DidUpdate\n\t\tor lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren\n\tthen\n\t\t--[[\n\t\t\tDuring certain phases of the component lifecycle, it's acceptable to\n\t\t\tallow `setState` but defer the update until we're done with ones in flight.\n\t\t\tWe do this by collapsing it into any pending updates we have.\n\t\t]]\n\t\tlocal derivedState = self:__getDerivedState(self.props, newState)\n\t\tinternalData.pendingState = assign(newState, derivedState)\n\telseif lifecyclePhase == ComponentLifecyclePhase.Idle then\n\t\t-- Outside of our lifecycle, the state update is safe to make immediately\n\t\tself:__update(nil, newState)\n\telse\n\t\tlocal messageTemplate = invalidSetStateMessages.default\n\n\t\tlocal message = messageTemplate:format(tostring(internalData.componentClass))\n\n\t\terror(message, 2)\n\tend\nend\n\n--[[\n\tReturns the stack trace of where the element was created that this component\n\tinstance's properties are based on.\n\n\tIntended to be used primarily by diagnostic tools.\n]]\nfunction Component:getElementTraceback()\n\treturn self[InternalData].virtualNode.currentElement.source\nend\n\n--[[\n\tReturns a snapshot of this component given the current props and state. Must\n\tbe overridden by consumers of Roact and should be a pure function with\n\tregards to props and state.\n\n\tTODO (#199): Accept props and state as arguments.\n]]\nfunction Component:render()\n\tlocal internalData = self[InternalData]\n\n\tlocal message = componentMissingRenderMessage:format(tostring(internalData.componentClass))\n\n\terror(message, 0)\nend\n\n--[[\n\tRetrieves the context value corresponding to the given key. Can return nil\n\tif a requested context key is not present\n]]\nfunction Component:__getContext(key)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__getContext`\")\n\t\tinternalAssert(key ~= nil, \"Context key cannot be nil\")\n\tend\n\n\tlocal virtualNode = self[InternalData].virtualNode\n\tlocal context = virtualNode.context\n\n\treturn context[key]\nend\n\n--[[\n\tAdds a new context entry to this component's context table (which will be\n\tpassed down to child components).\n]]\nfunction Component:__addContext(key, value)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__addContext`\")\n\tend\n\tlocal virtualNode = self[InternalData].virtualNode\n\n\t-- Make sure we store a reference to the component's original, unmodified\n\t-- context the virtual node. In the reconciler, we'll restore the original\n\t-- context if we need to replace the node (this happens when a node gets\n\t-- re-rendered as a different component)\n\tif virtualNode.originalContext == nil then\n\t\tvirtualNode.originalContext = virtualNode.context\n\tend\n\n\t-- Build a new context table on top of the existing one, then apply it to\n\t-- our virtualNode\n\tlocal existing = virtualNode.context\n\tvirtualNode.context = assign({}, existing, { [key] = value })\nend\n\n--[[\n\tPerforms property validation if the static method validateProps is declared.\n\tvalidateProps should follow assert's expected arguments:\n\t(false, message: string) | true. The function may return a message in the\n\ttrue case; it will be ignored. If this fails, the function will throw the\n\terror.\n]]\nfunction Component:__validateProps(props)\n\tif not config.propValidation then\n\t\treturn\n\tend\n\n\tlocal validator = self[InternalData].componentClass.validateProps\n\n\tif validator == nil then\n\t\treturn\n\tend\n\n\tif typeof(validator) ~= \"function\" then\n\t\terror(\n\t\t\t(\"validateProps must be a function, but it is a %s.\\nCheck the definition of the component %q.\"):format(\n\t\t\t\ttypeof(validator),\n\t\t\t\tself.__componentName\n\t\t\t)\n\t\t)\n\tend\n\n\tlocal success, failureReason = validator(props)\n\n\tif not success then\n\t\tfailureReason = failureReason or \"<Validator function did not supply a message>\"\n\t\terror(\n\t\t\t(\"Property validation failed in %s: %s\\n\\n%s\"):format(\n\t\t\t\tself.__componentName,\n\t\t\t\ttostring(failureReason),\n\t\t\t\tself:getElementTraceback() or \"<enable element tracebacks>\"\n\t\t\t),\n\t\t\t0\n\t\t)\n\tend\nend\n\n--[[\n\tAn internal method used by the reconciler to construct a new component\n\tinstance and attach it to the given virtualNode.\n]]\nfunction Component:__mount(reconciler, virtualNode)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentClass, \"Invalid use of `__mount`\")\n\t\tinternalAssert(Type.of(virtualNode) == Type.VirtualNode, \"Expected arg #2 to be of type VirtualNode\")\n\tend\n\n\tlocal currentElement = virtualNode.currentElement\n\tlocal hostParent = virtualNode.hostParent\n\n\t-- Contains all the information that we want to keep from consumers of\n\t-- Roact, or even other parts of the codebase like the reconciler.\n\tlocal internalData = {\n\t\treconciler = reconciler,\n\t\tvirtualNode = virtualNode,\n\t\tcomponentClass = self,\n\t\tlifecyclePhase = ComponentLifecyclePhase.Init,\n\t}\n\n\tlocal instance = {\n\t\t[Type] = Type.StatefulComponentInstance,\n\t\t[InternalData] = internalData,\n\t}\n\n\tsetmetatable(instance, self)\n\n\tvirtualNode.instance = instance\n\n\tlocal props = currentElement.props\n\n\tif self.defaultProps ~= nil then\n\t\tprops = assign({}, self.defaultProps, props)\n\tend\n\n\tinstance:__validateProps(props)\n\n\tinstance.props = props\n\n\tlocal newContext = assign({}, virtualNode.legacyContext)\n\tinstance._context = newContext\n\n\tinstance.state = assign({}, instance:__getDerivedState(instance.props, {}))\n\n\tif instance.init ~= nil then\n\t\tinstance:init(instance.props)\n\t\tassign(instance.state, instance:__getDerivedState(instance.props, instance.state))\n\tend\n\n\t-- It's possible for init() to redefine _context!\n\tvirtualNode.legacyContext = instance._context\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Render\n\tlocal renderResult = instance:render()\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren\n\treconciler.updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)\n\n\tif instance.didMount ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.DidMount\n\t\tinstance:didMount()\n\tend\n\n\tif internalData.pendingState ~= nil then\n\t\t-- __update will handle pendingState, so we don't pass any new element or state\n\t\tinstance:__update(nil, nil)\n\tend\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Idle\nend\n\n--[[\n\tInternal method used by the reconciler to clean up any resources held by\n\tthis component instance.\n]]\nfunction Component:__unmount()\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__unmount`\")\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal virtualNode = internalData.virtualNode\n\tlocal reconciler = internalData.reconciler\n\n\tif self.willUnmount ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount\n\t\tself:willUnmount()\n\tend\n\n\tfor _, childNode in pairs(virtualNode.children) do\n\t\treconciler.unmountVirtualNode(childNode)\n\tend\nend\n\n--[[\n\tInternal method used by setState (to trigger updates based on state) and by\n\tthe reconciler (to trigger updates based on props)\n\n\tReturns true if the update was completed, false if it was cancelled by shouldUpdate\n]]\nfunction Component:__update(updatedElement, updatedState)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__update`\")\n\t\tinternalAssert(\n\t\t\tType.of(updatedElement) == Type.Element or updatedElement == nil,\n\t\t\t\"Expected arg #1 to be of type Element or nil\"\n\t\t)\n\t\tinternalAssert(\n\t\t\ttypeof(updatedState) == \"table\" or updatedState == nil,\n\t\t\t\"Expected arg #2 to be of type table or nil\"\n\t\t)\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal componentClass = internalData.componentClass\n\n\tlocal newProps = self.props\n\tif updatedElement ~= nil then\n\t\tnewProps = updatedElement.props\n\n\t\tif componentClass.defaultProps ~= nil then\n\t\t\tnewProps = assign({}, componentClass.defaultProps, newProps)\n\t\tend\n\n\t\tself:__validateProps(newProps)\n\tend\n\n\tlocal updateCount = 0\n\trepeat\n\t\tlocal finalState\n\t\tlocal pendingState = nil\n\n\t\t-- Consume any pending state we might have\n\t\tif internalData.pendingState ~= nil then\n\t\t\tpendingState = internalData.pendingState\n\t\t\tinternalData.pendingState = nil\n\t\tend\n\n\t\t-- Consume a standard update to state or props\n\t\tif updatedState ~= nil or newProps ~= self.props then\n\t\t\tif pendingState == nil then\n\t\t\t\tfinalState = updatedState or self.state\n\t\t\telse\n\t\t\t\tfinalState = assign(pendingState, updatedState)\n\t\t\tend\n\n\t\t\tlocal derivedState = self:__getDerivedState(newProps, finalState)\n\n\t\t\tif derivedState ~= nil then\n\t\t\t\tfinalState = assign({}, finalState, derivedState)\n\t\t\tend\n\n\t\t\tupdatedState = nil\n\t\telse\n\t\t\tfinalState = pendingState\n\t\tend\n\n\t\tif not self:__resolveUpdate(newProps, finalState) then\n\t\t\t-- If the update was short-circuited, bubble the result up to the caller\n\t\t\treturn false\n\t\tend\n\n\t\tupdateCount = updateCount + 1\n\n\t\tif updateCount > MAX_PENDING_UPDATES then\n\t\t\terror(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)\n\t\tend\n\tuntil internalData.pendingState == nil\n\n\treturn true\nend\n\n--[[\n\tInternal method used by __update to apply new props and state\n\n\tReturns true if the update was completed, false if it was cancelled by shouldUpdate\n]]\nfunction Component:__resolveUpdate(incomingProps, incomingState)\n\tif config.internalTypeChecks then\n\t\tinternalAssert(Type.of(self) == Type.StatefulComponentInstance, \"Invalid use of `__resolveUpdate`\")\n\tend\n\n\tlocal internalData = self[InternalData]\n\tlocal virtualNode = internalData.virtualNode\n\tlocal reconciler = internalData.reconciler\n\n\tlocal oldProps = self.props\n\tlocal oldState = self.state\n\n\tif incomingProps == nil then\n\t\tincomingProps = oldProps\n\tend\n\tif incomingState == nil then\n\t\tincomingState = oldState\n\tend\n\n\tif self.shouldUpdate ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate\n\t\tlocal continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)\n\n\t\tif not continueWithUpdate then\n\t\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Idle\n\t\t\treturn false\n\t\tend\n\tend\n\n\tif self.willUpdate ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate\n\t\tself:willUpdate(incomingProps, incomingState)\n\tend\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Render\n\n\tself.props = incomingProps\n\tself.state = incomingState\n\n\tlocal renderResult = virtualNode.instance:render()\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren\n\treconciler.updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, renderResult)\n\n\tif self.didUpdate ~= nil then\n\t\tinternalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate\n\t\tself:didUpdate(oldProps, oldState)\n\tend\n\n\tinternalData.lifecyclePhase = ComponentLifecyclePhase.Idle\n\treturn true\nend\n\nreturn Component\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Binding.spec",
                        "ClassName": "ModuleScript",
                        "Source": "return function()\n\tlocal createSpy = require(script.Parent.createSpy)\n\tlocal Type = require(script.Parent.Type)\n\tlocal GlobalConfig = require(script.Parent.GlobalConfig)\n\n\tlocal Binding = require(script.Parent.Binding)\n\n\tdescribe(\"Binding.create\", function()\n\t\tit(\"should return a Binding object and an update function\", function()\n\t\t\tlocal binding, update = Binding.create(1)\n\n\t\t\texpect(Type.of(binding)).to.equal(Type.Binding)\n\t\t\texpect(typeof(update)).to.equal(\"function\")\n\t\tend)\n\n\t\tit(\"should support tostring on bindings\", function()\n\t\t\tlocal binding, update = Binding.create(1)\n\t\t\texpect(tostring(binding)).to.equal(\"RoactBinding(1)\")\n\n\t\t\tupdate(\"foo\")\n\t\t\texpect(tostring(binding)).to.equal(\"RoactBinding(foo)\")\n\t\tend)\n\tend)\n\n\tdescribe(\"Binding object\", function()\n\t\tit(\"should provide a getter and setter\", function()\n\t\t\tlocal binding, update = Binding.create(1)\n\n\t\t\texpect(binding:getValue()).to.equal(1)\n\n\t\t\tupdate(3)\n\n\t\t\texpect(binding:getValue()).to.equal(3)\n\t\tend)\n\n\t\tit(\"should let users subscribe and unsubscribe to its updates\", function()\n\t\t\tlocal binding, update = Binding.create(1)\n\n\t\t\tlocal spy = createSpy()\n\t\t\tlocal disconnect = Binding.subscribe(binding, spy.value)\n\n\t\t\texpect(spy.callCount).to.equal(0)\n\n\t\t\tupdate(2)\n\n\t\t\texpect(spy.callCount).to.equal(1)\n\t\t\tspy:assertCalledWith(2)\n\n\t\t\tdisconnect()\n\t\t\tupdate(3)\n\n\t\t\texpect(spy.callCount).to.equal(1)\n\t\tend)\n\tend)\n\n\tdescribe(\"Mapped bindings\", function()\n\t\tit(\"should be composable\", function()\n\t\t\tlocal word, updateWord = Binding.create(\"hi\")\n\n\t\t\tlocal wordLength = word:map(string.len)\n\t\t\tlocal isEvenLength = wordLength:map(function(value)\n\t\t\t\treturn value % 2 == 0\n\t\t\tend)\n\n\t\t\texpect(word:getValue()).to.equal(\"hi\")\n\t\t\texpect(wordLength:getValue()).to.equal(2)\n\t\t\texpect(isEvenLength:getValue()).to.equal(true)\n\n\t\t\tupdateWord(\"sup\")\n\n\t\t\texpect(word:getValue()).to.equal(\"sup\")\n\t\t\texpect(wordLength:getValue()).to.equal(3)\n\t\t\texpect(isEvenLength:getValue()).to.equal(false)\n\t\tend)\n\n\t\tit(\"should cascade updates when subscribed\", function()\n\t\t\t-- base binding\n\t\t\tlocal word, updateWord = Binding.create(\"hi\")\n\n\t\t\tlocal wordSpy = createSpy()\n\t\t\tlocal disconnectWord = Binding.subscribe(word, wordSpy.value)\n\n\t\t\t-- binding -> base binding\n\t\t\tlocal length = word:map(string.len)\n\n\t\t\tlocal lengthSpy = createSpy()\n\t\t\tlocal disconnectLength = Binding.subscribe(length, lengthSpy.value)\n\n\t\t\t-- binding -> binding -> base binding\n\t\t\tlocal isEvenLength = length:map(function(value)\n\t\t\t\treturn value % 2 == 0\n\t\t\tend)\n\n\t\t\tlocal isEvenLengthSpy = createSpy()\n\t\t\tlocal disconnectIsEvenLength = Binding.subscribe(isEvenLength, isEvenLengthSpy.value)\n\n\t\t\texpect(wordSpy.callCount).to.equal(0)\n\t\t\texpect(lengthSpy.callCount).to.equal(0)\n\t\t\texpect(isEvenLengthSpy.callCount).to.equal(0)\n\n\t\t\tupdateWord(\"nice\")\n\n\t\t\texpect(wordSpy.callCount).to.equal(1)\n\t\t\twordSpy:assertCalledWith(\"nice\")\n\n\t\t\texpect(lengthSpy.callCount).to.equal(1)\n\t\t\tlengthSpy:assertCalledWith(4)\n\n\t\t\texpect(isEvenLengthSpy.callCount).to.equal(1)\n\t\t\tisEvenLengthSpy:assertCalledWith(true)\n\n\t\t\tdisconnectWord()\n\t\t\tdisconnectLength()\n\t\t\tdisconnectIsEvenLength()\n\n\t\t\tupdateWord(\"goodbye\")\n\n\t\t\texpect(wordSpy.callCount).to.equal(1)\n\t\t\texpect(isEvenLengthSpy.callCount).to.equal(1)\n\t\t\texpect(lengthSpy.callCount).to.equal(1)\n\t\tend)\n\n\t\tit(\"should throw when updated directly\", function()\n\t\t\tlocal source = Binding.create(1)\n\t\t\tlocal mapped = source:map(function(v)\n\t\t\t\treturn v\n\t\t\tend)\n\n\t\t\texpect(function()\n\t\t\t\tBinding.update(mapped, 5)\n\t\t\tend).to.throw()\n\t\tend)\n\tend)\n\n\tdescribe(\"Binding.join\", function()\n\t\tit(\"should have getValue\", function()\n\t\t\tlocal binding1 = Binding.create(1)\n\t\t\tlocal binding2 = Binding.create(2)\n\t\t\tlocal binding3 = Binding.create(3)\n\n\t\t\tlocal joinedBinding = Binding.join({\n\t\t\t\tbinding1,\n\t\t\t\tbinding2,\n\t\t\t\tfoo = binding3,\n\t\t\t})\n\n\t\t\tlocal bindingValue = joinedBinding:getValue()\n\t\t\texpect(bindingValue).to.be.a(\"table\")\n\t\t\texpect(bindingValue[1]).to.equal(1)\n\t\t\texpect(bindingValue[2]).to.equal(2)\n\t\t\texpect(bindingValue.foo).to.equal(3)\n\t\tend)\n\n\t\tit(\"should update when any one of the subscribed bindings updates\", function()\n\t\t\tlocal binding1, update1 = Binding.create(1)\n\t\t\tlocal binding2, update2 = Binding.create(2)\n\t\t\tlocal binding3, update3 = Binding.create(3)\n\n\t\t\tlocal joinedBinding = Binding.join({\n\t\t\t\tbinding1,\n\t\t\t\tbinding2,\n\t\t\t\tfoo = binding3,\n\t\t\t})\n\n\t\t\tlocal spy = createSpy()\n\t\t\tBinding.subscribe(joinedBinding, spy.value)\n\n\t\t\texpect(spy.callCount).to.equal(0)\n\n\t\t\tupdate1(3)\n\t\t\texpect(spy.callCount).to.equal(1)\n\n\t\t\tlocal args = spy:captureValues(\"value\")\n\t\t\texpect(args.value).to.be.a(\"table\")\n\t\t\texpect(args.value[1]).to.equal(3)\n\t\t\texpect(args.value[2]).to.equal(2)\n\t\t\texpect(args.value[\"foo\"]).to.equal(3)\n\n\t\t\tupdate2(4)\n\t\t\texpect(spy.callCount).to.equal(2)\n\n\t\t\targs = spy:captureValues(\"value\")\n\t\t\texpect(args.value).to.be.a(\"table\")\n\t\t\texpect(args.value[1]).to.equal(3)\n\t\t\texpect(args.value[2]).to.equal(4)\n\t\t\texpect(args.value[\"foo\"]).to.equal(3)\n\n\t\t\tupdate3(8)\n\t\t\texpect(spy.callCount).to.equal(3)\n\n\t\t\targs = spy:captureValues(\"value\")\n\t\t\texpect(args.value).to.be.a(\"table\")\n\t\t\texpect(args.value[1]).to.equal(3)\n\t\t\texpect(args.value[2]).to.equal(4)\n\t\t\texpect(args.value[\"foo\"]).to.equal(8)\n\t\tend)\n\n\t\tit(\"should disconnect from all upstream bindings\", function()\n\t\t\tlocal binding1, update1 = Binding.create(1)\n\t\t\tlocal binding2, update2 = Binding.create(2)\n\n\t\t\tlocal joined = Binding.join({ binding1, binding2 })\n\n\t\t\tlocal spy = createSpy()\n\t\t\tlocal disconnect = Binding.subscribe(joined, spy.value)\n\n\t\t\texpect(spy.callCount).to.equal(0)\n\n\t\t\tupdate1(3)\n\t\t\texpect(spy.callCount).to.equal(1)\n\n\t\t\tupdate2(3)\n\t\t\texpect(spy.callCount).to.equal(2)\n\n\t\t\tdisconnect()\n\t\t\tupdate1(4)\n\t\t\texpect(spy.callCount).to.equal(2)\n\n\t\t\tupdate2(2)\n\t\t\texpect(spy.callCount).to.equal(2)\n\n\t\t\tlocal value = joined:getValue()\n\t\t\texpect(value[1]).to.equal(4)\n\t\t\texpect(value[2]).to.equal(2)\n\t\tend)\n\n\t\tit(\"should be okay with calling disconnect multiple times\", function()\n\t\t\tlocal joined = Binding.join({})\n\n\t\t\tlocal disconnect = Binding.subscribe(joined, function() end)\n\n\t\t\tdisconnect()\n\t\t\tdisconnect()\n\t\tend)\n\n\t\tit(\"should throw if updated directly\", function()\n\t\t\tlocal joined = Binding.join({})\n\n\t\t\texpect(function()\n\t\t\t\tBinding.update(joined, 0)\n\t\t\tend)\n\t\tend)\n\n\t\tit(\"should throw when a non-table value is passed\", function()\n\t\t\tGlobalConfig.scoped({\n\t\t\t\ttypeChecks = true,\n\t\t\t}, function()\n\t\t\t\texpect(function()\n\t\t\t\t\tBinding.join(\"hi\")\n\t\t\t\tend).to.throw()\n\t\t\tend)\n\t\tend)\n\n\t\tit(\"should throw when a non-binding value is passed via table\", function()\n\t\t\tGlobalConfig.scoped({\n\t\t\t\ttypeChecks = true,\n\t\t\t}, function()\n\t\t\t\texpect(function()\n\t\t\t\t\tlocal binding = Binding.create(123)\n\n\t\t\t\t\tBinding.join({\n\t\t\t\t\t\tbinding,\n\t\t\t\t\t\t\"abcde\",\n\t\t\t\t\t})\n\t\t\t\tend).to.throw()\n\t\t\tend)\n\t\tend)\n\tend)\nend\n",
                        "Children": [],
                        "Archivable": true
                    },
                    {
                        "Name": "Binding",
                        "ClassName": "ModuleScript",
                        "Source": "local createSignal = require(script.Parent.createSignal)\nlocal Symbol = require(script.Parent.Symbol)\nlocal Type = require(script.Parent.Type)\n\nlocal config = require(script.Parent.GlobalConfig).get()\n\nlocal BindingImpl = Symbol.named(\"BindingImpl\")\n\nlocal BindingInternalApi = {}\n\nlocal bindingPrototype = {}\n\nfunction bindingPrototype:getValue()\n\treturn BindingInternalApi.getValue(self)\nend\n\nfunction bindingPrototype:map(predicate)\n\treturn BindingInternalApi.map(self, predicate)\nend\n\nlocal BindingPublicMeta = {\n\t__index = bindingPrototype,\n\t__tostring = function(self)\n\t\treturn string.format(\"RoactBinding(%s)\", tostring(self:getValue()))\n\tend,\n}\n\nfunction BindingInternalApi.update(binding, newValue)\n\treturn binding[BindingImpl].update(newValue)\nend\n\nfunction BindingInternalApi.subscribe(binding, callback)\n\treturn binding[BindingImpl].subscribe(callback)\nend\n\nfunction BindingInternalApi.getValue(binding)\n\treturn binding[BindingImpl].getValue()\nend\n\nfunction BindingInternalApi.create(initialValue)\n\tlocal impl = {\n\t\tvalue = initialValue,\n\t\tchangeSignal = createSignal(),\n\t}\n\n\tfunction impl.subscribe(callback)\n\t\treturn impl.changeSignal:subscribe(callback)\n\tend\n\n\tfunction impl.update(newValue)\n\t\timpl.value = newValue\n\t\timpl.changeSignal:fire(newValue)\n\tend\n\n\tfunction impl.getValue()\n\t\treturn impl.value\n\tend\n\n\treturn setmetatable({\n\t\t[Type] = Type.Binding,\n\t\t[BindingImpl] = impl,\n\t}, BindingPublicMeta), impl.update\nend\n\nfunction BindingInternalApi.map(upstreamBinding, predicate)\n\tif config.typeChecks then\n\t\tassert(Type.of(upstreamBinding) == Type.Binding, \"Expected arg #1 to be a binding\")\n\t\tassert(typeof(predicate) == \"function\", \"Expected arg #1 to be a function\")\n\tend\n\n\tlocal impl = {}\n\n\tfunction impl.subscribe(callback)\n\t\treturn BindingInternalApi.subscribe(upstreamBinding, function(newValue)\n\t\t\tcallback(predicate(newValue))\n\t\tend)\n\tend\n\n\tfunction impl.update(_newValue)\n\t\terror(\"Bindings created by Binding:map(fn) cannot be updated directly\", 2)\n\tend\n\n\tfunction impl.getValue()\n\t\treturn predicate(upstreamBinding:getValue())\n\tend\n\n\treturn setmetatable({\n\t\t[Type] = Type.Binding,\n\t\t[BindingImpl] = impl,\n\t}, BindingPublicMeta)\nend\n\nfunction BindingInternalApi.join(upstreamBindings)\n\tif config.typeChecks then\n\t\tassert(typeof(upstreamBindings) == \"table\", \"Expected arg #1 to be of type table\")\n\n\t\tfor key, value in pairs(upstreamBindings) do\n\t\t\tif Type.of(value) ~= Type.Binding then\n\t\t\t\tlocal message = (\"Expected arg #1 to contain only bindings, but key %q had a non-binding value\"):format(\n\t\t\t\t\ttostring(key)\n\t\t\t\t)\n\t\t\t\terror(message, 2)\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal impl = {}\n\n\tlocal function getValue()\n\t\tlocal value = {}\n\n\t\tfor key, upstream in pairs(upstreamBindings) do\n\t\t\tvalue[key] = upstream:getValue()\n\t\tend\n\n\t\treturn value\n\tend\n\n\tfunction impl.subscribe(callback)\n\t\tlocal disconnects = {}\n\n\t\tfor key, upstream in pairs(upstreamBindings) do\n\t\t\tdisconnects[key] = BindingInternalApi.subscribe(upstream, function(_newValue)\n\t\t\t\tcallback(getValue())\n\t\t\tend)\n\t\tend\n\n\t\treturn function()\n\t\t\tif disconnects == nil then\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\tfor _, disconnect in pairs(disconnects) do\n\t\t\t\tdisconnect()\n\t\t\tend\n\n\t\t\tdisconnects = nil\n\t\tend\n\tend\n\n\tfunction impl.update(_newValue)\n\t\terror(\"Bindings created by joinBindings(...) cannot be updated directly\", 2)\n\tend\n\n\tfunction impl.getValue()\n\t\treturn getValue()\n\tend\n\n\treturn setmetatable({\n\t\t[Type] = Type.Binding,\n\t\t[BindingImpl] = impl,\n\t}, BindingPublicMeta)\nend\n\nreturn BindingInternalApi\n",
                        "Children": [],
                        "Archivable": true
                    }
                ],
                "Archivable": true
            }
        ]
    }
]